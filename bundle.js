(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["es6Boilerplate"] = factory();
	else
		root["es6Boilerplate"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	__webpack_require__(1);
	
	window.onload = function () {
	  setTimeout(function () {
	    var main = document.getElementById("main");
	    main.className = "";
	    var preloader = document.getElementById("preloader");
	    preloader.className = "";
	
	    var page = document.getElementById("activePage");
	
	    if (page.innerHTML === "Virtual Lab") {
	      (function () {
	        var App = __webpack_require__(5);
	        var labs = __webpack_require__(12);
	        var app = new App();
	
	        var labSelector = document.getElementById("selectLab");
	        var labId = labSelector.value;
	        var data = labs[labId];
	
	        labSelector.addEventListener("change", function (e) {
	          console.log(e.target.value);
	          data = labs[e.target.value];
	          app.update(data);
	        });
	        app.start(data);
	
	        /* buttons */
	        var resetBtn = document.getElementById("resetBtn");
	        resetBtn.addEventListener("click", function (e) {
	          app.update(data);
	        });
	
	        var sendBtn = document.getElementById("sendBtn");
	        var instance = axios.create({
	          baseURL: "http://localhost:3000"
	        });
	
	        sendBtn.addEventListener("click", function (e) {
	          var data = app._getStandArray();
	          instance.post("/check", {
	            data: data
	          }).then(function (response) {
	            console.log(response);
	          })["catch"](function (error) {
	            console.log(error);
	          });
	        });
	      })();
	    }
	  }, 0);
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(2);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(4)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./style.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./style.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(3)();
	// imports
	
	
	// module
	exports.push([module.id, "#stand {\r\n\tborder: 1px solid #333;\r\n\tdisplay: inline-block;\r\n\theight: 80vh;\r\n\tmargin-bottom: 25px;\r\n}\r\n\r\n.info {\r\n\r\n}\r\n\r\n.info #selectLab {\r\n\tfont-size: 0.85em !important;\r\n\tpadding: 5px\r\n}\r\n\r\n.data {\r\n\tmargin-top: 10px;\r\n\tmargin-bottom: 10px;\r\n}\r\n\r\n#main.hide {\r\n\tdisplay: none;\r\n\tmax-height: 0;\r\n}\r\n#preloader.active {\r\n\tposition: fixed;\r\n\ttop: 0;\r\n\tleft: 0;\r\n\theight: 100vh;\r\n\twidth: 100vw;\r\n\tdisplay: flex;\r\n\tjustify-content: center;\r\n\talign-items: center;\r\n\tbackground: #bbd149;\r\n}\r\n\r\n#preloader.active #inner {\r\n\twidth: 50px;\r\n\theight: 50px;\r\n\tposition: relative;\r\n}\r\n\r\n#preloader.active #inner:before {\r\n\tcontent: '';\r\n  position: absolute;\r\n\ttop: 67px;\r\n\tleft: 0;\r\n\twidth: 50px;\r\n\theight: 6px;\r\n\tbackground: black;\r\n\topacity: .2;\r\n\tborder-radius: 50%;\r\n\tanimation: shadow .5s linear infinite;\r\n}\r\n#preloader.active #inner:after {\r\n\tcontent: '';\r\n  position: absolute;\r\n\ttop: 0;\r\n\tleft: 0;\r\n\twidth: 50px;\r\n\theight: 50px;\r\n\tbackground: white;\r\n\tanimation: rotate .5s linear infinite;\r\n\tborder-radius: 5px;\r\n}\r\n@keyframes rotate {\r\n\t0% {\r\n\t\ttransform: translateY(0) rotate(0deg);\r\n\t}\r\n\t25% {\r\n\t\t transform: translateY(10px) rotate(22.5deg);\r\n\t}\r\n\t50% {\r\n\t\t transform: translateY(20px) scale(1.1, 0.9) rotate(45deg);\r\n\t\t border-bottom-right-radius: 50px;\r\n\t}\r\n\t75% {\r\n\t\t transform: translateY(10px) rotate(67.5deg);\r\n\t}\r\n\t100% {\r\n\t\t transform: translateY(0) rotate(90deg);\r\n\t}\r\n}\r\n\r\n@keyframes shadow {\r\n\t0%, 100% {transform: scaleX(1);}\r\n\t50% {transform: scaleX(1.2);}\r\n}\r\n", ""]);
	
	// exports


/***/ },
/* 3 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	var Stand = _interopRequire(__webpack_require__(6));
	
	var App = (function () {
	  function App() {
	    _classCallCheck(this, App);
	
	    this.stand = new Stand();
	  }
	
	  _createClass(App, {
	    start: {
	      value: function start(data) {
	        this.stand.build(data);
	      }
	    },
	    update: {
	      value: function update(data) {
	        this.stand.update(data);
	      }
	    },
	    _getStandArray: {
	      value: function _getStandArray() {
	        return this.stand.getAsArray();
	      }
	    }
	  });
	
	  return App;
	})();
	
	module.exports = App;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	var _konva = __webpack_require__(7);
	
	var Stage = _konva.Stage;
	var Layer = _konva.Layer;
	var Rect = _konva.Rect;
	
	var Input = _interopRequire(__webpack_require__(10));
	
	var Meter = _interopRequire(__webpack_require__(14));
	
	var Resister = _interopRequire(__webpack_require__(15));
	
	var Stand = (function (_Stage) {
	  function Stand() {
	    _classCallCheck(this, Stand);
	
	    var standWrapper = document.getElementById("stand");
	    var width = standWrapper.scrollWidth;
	    var height = standWrapper.clientHeight;
	    _get(Object.getPrototypeOf(Stand.prototype), "constructor", this).call(this, {
	      container: "stand",
	      width: width,
	      height: height
	    });
	    this.panel = new Layer();
	    this.components = [];
	    this.add(this.panel);
	  }
	
	  _inherits(Stand, _Stage);
	
	  _createClass(Stand, {
	    build: {
	      value: function build(data) {
	        console.log("Building stand...");
	        var elements = this.parseJSON(data);
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var element = _step.value;
	
	            this.addElement(element);
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator["return"]) {
	              _iterator["return"]();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	
	        this.add(this.panel);
	      }
	    },
	    update: {
	      value: function update(data) {
	        this.panel.destroyChildren();
	        this.components = [];
	        this.build(data);
	      }
	    },
	    addElement: {
	      value: function addElement(element) {
	        if (element.type !== "undefined") this.components.push(element);
	        this.add(this.panel.add(element));
	      }
	    },
	    addElements: {
	      value: function addElements(elements) {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var element = _step.value;
	
	            if (element.type !== "undefined") this.components.push(element);
	            this.add(this.panel.add(element));
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator["return"]) {
	              _iterator["return"]();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      }
	    },
	    parseJSON: {
	      value: function parseJSON(data) {
	        var elements = [];
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var el = _step.value;
	
	            if (el.type) {
	              switch (el.type) {
	                case "Input":
	                  elements.push(new Input(el.x, el.y, this));
	                  break;
	                case "Meter":
	                  elements.push(new Meter(el.x, el.y, el.param, this));
	                  break;
	                case "Resister":
	                  elements.push(new Resister(el.x, el.y, el.value, this));
	                  break;
	              }
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator["return"]) {
	              _iterator["return"]();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	
	        return elements;
	      }
	    },
	    getAsArray: {
	      value: function getAsArray() {
	        return this.components.map(function (element) {
	          return {
	            type: element.type,
	            x: element.x,
	            y: element.y
	          };
	        });
	      }
	    }
	  });
	
	  return Stand;
	})(Stage);
	
	module.exports = Stand;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	 * Konva JavaScript Framework v1.2.2
	 * http://konvajs.github.io/
	 * Licensed under the MIT or GPL Version 2 licenses.
	 * Date: Tue Sep 20 2016
	 *
	 * Original work Copyright (C) 2011 - 2013 by Eric Rowell (KineticJS)
	 * Modified work Copyright (C) 2014 - 2015 by Anton Lavrenov (Konva)
	 *
	 * @license
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	
	// runtime check for already included Konva
	(function(global){
	    'use strict';
	    /**
	     * @namespace Konva
	     */
	
	    var PI_OVER_180 = Math.PI / 180;
	
	    var Konva = {
	        // public
	        version: '1.2.2',
	
	        // private
	        stages: [],
	        idCounter: 0,
	        ids: {},
	        names: {},
	        shapes: {},
	        listenClickTap: false,
	        inDblClickWindow: false,
	
	        // configurations
	        enableTrace: false,
	        traceArrMax: 100,
	        dblClickWindow: 400,
	        /**
	         * Global pixel ratio configuration. KonvaJS automatically detect pixel ratio of current device.
	         * But you may override such property, if you want to use your value.
	         * @property pixelRatio
	         * @default undefined
	         * @memberof Konva
	         * @example
	         * Konva.pixelRatio = 1;
	         */
	        pixelRatio: undefined,
	        /**
	         * Drag distance property. If you start to drag a node you may want to wait until pointer is moved to some distance from start point,
	         * only then start dragging.
	         * @property dragDistance
	         * @default 0
	         * @memberof Konva
	         * @example
	         * Konva.dragDistance = 10;
	         */
	        dragDistance: 0,
	        /**
	         * Use degree values for angle properties. You may set this property to false if you want to use radiant values.
	         * @property angleDeg
	         * @default true
	         * @memberof Konva
	         * @example
	         * node.rotation(45); // 45 degrees
	         * Konva.angleDeg = false;
	         * node.rotation(Math.PI / 2); // PI/2 radian
	         */
	        angleDeg: true,
	         /**
	         * Show different warnings about errors or wrong API usage
	         * @property showWarnings
	         * @default true
	         * @memberof Konva
	         * @example
	         * Konva.showWarnings = false;
	         */
	        showWarnings: true,
	
	
	
	        /**
	         * @namespace Filters
	         * @memberof Konva
	         */
	        Filters: {},
	
	        /**
	         * returns whether or not drag and drop is currently active
	         * @method
	         * @memberof Konva
	         */
	        isDragging: function() {
	            var dd = Konva.DD;
	
	            // if DD is not included with the build, then
	            // drag and drop is not even possible
	            if (dd) {
	                return dd.isDragging;
	            }
	            return false;
	        },
	        /**
	        * returns whether or not a drag and drop operation is ready, but may
	        *  not necessarily have started
	        * @method
	        * @memberof Konva
	        */
	        isDragReady: function() {
	            var dd = Konva.DD;
	
	            // if DD is not included with the build, then
	            // drag and drop is not even possible
	            if (dd) {
	                return !!dd.node;
	            }
	            return false;
	        },
	        _addId: function(node, id) {
	            if(id !== undefined) {
	                this.ids[id] = node;
	            }
	        },
	        _removeId: function(id) {
	            if(id !== undefined) {
	                delete this.ids[id];
	            }
	        },
	        _addName: function(node, name) {
	            if(name) {
	                if(!this.names[name]) {
	                    this.names[name] = [];
	                }
	                this.names[name].push(node);
	            }
	        },
	        _removeName: function(name, _id) {
	            if(!name) {
	                return;
	            }
	            var nodes = this.names[name];
	            if(!nodes) {
	                return;
	            }
	            for(var n = 0; n < nodes.length; n++) {
	                var no = nodes[n];
	                if(no._id === _id) {
	                    nodes.splice(n, 1);
	                }
	            }
	            if(nodes.length === 0) {
	                delete this.names[name];
	            }
	        },
	        getAngle: function(angle) {
	            return this.angleDeg ? angle * PI_OVER_180 : angle;
	        },
	        _detectIE: function(ua) {
	            var msie = ua.indexOf('msie ');
	            if (msie > 0) {
	                // IE 10 or older => return version number
	                return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
	            }
	
	            var trident = ua.indexOf('trident/');
	            if (trident > 0) {
	                // IE 11 => return version number
	                var rv = ua.indexOf('rv:');
	                return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
	            }
	
	            var edge = ua.indexOf('edge/');
	            if (edge > 0) {
	                // Edge (IE 12+) => return version number
	                return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
	            }
	
	            // other browser
	            return false;
	        },
	        _parseUA: function(userAgent) {
	            var ua = userAgent.toLowerCase(),
	                // jQuery UA regex
	                match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
	                /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
	                /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
	                /(msie) ([\w.]+)/.exec( ua ) ||
	                ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
	                [],
	
	                // adding mobile flag as well
	                mobile = !!(userAgent.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i)),
	                ieMobile = !!(userAgent.match(/IEMobile/i));
	
	            return {
	                browser: match[ 1 ] || '',
	                version: match[ 2 ] || '0',
	                isIE: Konva._detectIE(ua),
	                // adding mobile flab
	                mobile: mobile,
	                ieMobile: ieMobile  // If this is true (i.e., WP8), then Konva touch events are executed instead of equivalent Konva mouse events
	            };
	        },
	        // user agent
	        UA: undefined
	    };
	
	    var glob =
	        typeof window !== 'undefined' ? window :
	        typeof global !== 'undefined' ? global :
	        typeof WorkerGlobalScope !== 'undefined' ? self : {};
	
	
	    Konva.UA = Konva._parseUA((glob.navigator && glob.navigator.userAgent) || '');
	
	
	    if (glob.Konva) {
	        console.error(
	            'Konva instance is already exist in current eviroment. ' +
	            'Please use only one instance.'
	        );
	    }
	    glob.Konva = Konva;
	    Konva.global = glob;
	
	
	    if( true) {
	        // runtime-check for browserify and nw.js (node-webkit)
	        if(glob.window && glob.window.document) {
	            Konva.document = glob.window.document;
	            Konva.window = glob.window;
	        } else {
	            // Node. Does not work with strict CommonJS, but
	            // only CommonJS-like enviroments that support module.exports,
	            // like Node.
	            var Canvas = __webpack_require__(8);
	            var jsdom = __webpack_require__(9).jsdom;
	
	            Konva.window = jsdom('<!DOCTYPE html><html><head></head><body></body></html>').defaultView;
	            Konva.document = Konva.window.document;
	            Konva.window.Image = Canvas.Image;
	            Konva._nodeCanvas = Canvas;
	        }
	        module.exports = Konva;
	        return;
	    }
	    else if( typeof define === 'function' && define.amd) {
	        // AMD. Register as an anonymous module.
	        define(function() {
	            return Konva;
	        });
	    }
	    Konva.document = document;
	    Konva.window = window;
	})(typeof window !== 'undefined' ? window : global);
	
	/*eslint-disable  eqeqeq, no-cond-assign, no-empty*/
	(function() {
	    'use strict';
	    /**
	     * Collection constructor.  Collection extends
	     *  Array.  This class is used in conjunction with {@link Konva.Container#get}
	     * @constructor
	     * @memberof Konva
	     */
	    Konva.Collection = function() {
	        var args = [].slice.call(arguments), length = args.length, i = 0;
	
	        this.length = length;
	        for(; i < length; i++) {
	            this[i] = args[i];
	        }
	        return this;
	    };
	    Konva.Collection.prototype = [];
	    /**
	     * iterate through node array and run a function for each node.
	     *  The node and index is passed into the function
	     * @method
	     * @memberof Konva.Collection.prototype
	     * @param {Function} func
	     * @example
	     * // get all nodes with name foo inside layer, and set x to 10 for each
	     * layer.get('.foo').each(function(shape, n) {
	     *   shape.setX(10);
	     * });
	     */
	    Konva.Collection.prototype.each = function(func) {
	        for(var n = 0; n < this.length; n++) {
	            func(this[n], n);
	        }
	    };
	    /**
	     * convert collection into an array
	     * @method
	     * @memberof Konva.Collection.prototype
	     */
	    Konva.Collection.prototype.toArray = function() {
	        var arr = [],
	            len = this.length,
	            n;
	
	        for(n = 0; n < len; n++) {
	            arr.push(this[n]);
	        }
	        return arr;
	    };
	    /**
	     * convert array into a collection
	     * @method
	     * @memberof Konva.Collection
	     * @param {Array} arr
	     */
	    Konva.Collection.toCollection = function(arr) {
	        var collection = new Konva.Collection(),
	            len = arr.length,
	            n;
	
	        for(n = 0; n < len; n++) {
	            collection.push(arr[n]);
	        }
	        return collection;
	    };
	
	    // map one method by it's name
	    Konva.Collection._mapMethod = function(methodName) {
	        Konva.Collection.prototype[methodName] = function() {
	            var len = this.length,
	                i;
	
	            var args = [].slice.call(arguments);
	            for(i = 0; i < len; i++) {
	                this[i][methodName].apply(this[i], args);
	            }
	
	            return this;
	        };
	    };
	
	    Konva.Collection.mapMethods = function(constructor) {
	        var prot = constructor.prototype;
	        for(var methodName in prot) {
	            Konva.Collection._mapMethod(methodName);
	        }
	    };
	
	    /*
	    * Last updated November 2011
	    * By Simon Sarris
	    * www.simonsarris.com
	    * sarris@acm.org
	    *
	    * Free to use and distribute at will
	    * So long as you are nice to people, etc
	    */
	
	    /*
	    * The usage of this class was inspired by some of the work done by a forked
	    * project, KineticJS-Ext by Wappworks, which is based on Simon's Transform
	    * class.  Modified by Eric Rowell
	    */
	
	    /**
	     * Transform constructor
	     * @constructor
	     * @param {Array} [m] Optional six-element matrix
	     * @memberof Konva
	     */
	    Konva.Transform = function(m) {
	        this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];
	    };
	
	    Konva.Transform.prototype = {
	        /**
	         * Copy Konva.Transform object
	         * @method
	         * @memberof Konva.Transform.prototype
	         * @returns {Konva.Transform}
	         */
	        copy: function() {
	            return new Konva.Transform(this.m);
	        },
	        /**
	         * Transform point
	         * @method
	         * @memberof Konva.Transform.prototype
	         * @param {Object} point 2D point(x, y)
	         * @returns {Object} 2D point(x, y)
	         */
	        point: function(point) {
	            var m = this.m;
	            return {
	                x: m[0] * point.x + m[2] * point.y + m[4],
	                y: m[1] * point.x + m[3] * point.y + m[5]
	            };
	        },
	        /**
	         * Apply translation
	         * @method
	         * @memberof Konva.Transform.prototype
	         * @param {Number} x
	         * @param {Number} y
	         * @returns {Konva.Transform}
	         */
	        translate: function(x, y) {
	            this.m[4] += this.m[0] * x + this.m[2] * y;
	            this.m[5] += this.m[1] * x + this.m[3] * y;
	            return this;
	        },
	        /**
	         * Apply scale
	         * @method
	         * @memberof Konva.Transform.prototype
	         * @param {Number} sx
	         * @param {Number} sy
	         * @returns {Konva.Transform}
	         */
	        scale: function(sx, sy) {
	            this.m[0] *= sx;
	            this.m[1] *= sx;
	            this.m[2] *= sy;
	            this.m[3] *= sy;
	            return this;
	        },
	        /**
	         * Apply rotation
	         * @method
	         * @memberof Konva.Transform.prototype
	         * @param {Number} rad  Angle in radians
	         * @returns {Konva.Transform}
	         */
	        rotate: function(rad) {
	            var c = Math.cos(rad);
	            var s = Math.sin(rad);
	            var m11 = this.m[0] * c + this.m[2] * s;
	            var m12 = this.m[1] * c + this.m[3] * s;
	            var m21 = this.m[0] * -s + this.m[2] * c;
	            var m22 = this.m[1] * -s + this.m[3] * c;
	            this.m[0] = m11;
	            this.m[1] = m12;
	            this.m[2] = m21;
	            this.m[3] = m22;
	            return this;
	        },
	        /**
	         * Returns the translation
	         * @method
	         * @memberof Konva.Transform.prototype
	         * @returns {Object} 2D point(x, y)
	         */
	        getTranslation: function() {
	            return {
	                x: this.m[4],
	                y: this.m[5]
	            };
	        },
	        /**
	         * Apply skew
	         * @method
	         * @memberof Konva.Transform.prototype
	         * @param {Number} sx
	         * @param {Number} sy
	         * @returns {Konva.Transform}
	         */
	        skew: function(sx, sy) {
	            var m11 = this.m[0] + this.m[2] * sy;
	            var m12 = this.m[1] + this.m[3] * sy;
	            var m21 = this.m[2] + this.m[0] * sx;
	            var m22 = this.m[3] + this.m[1] * sx;
	            this.m[0] = m11;
	            this.m[1] = m12;
	            this.m[2] = m21;
	            this.m[3] = m22;
	            return this;
	         },
	        /**
	         * Transform multiplication
	         * @method
	         * @memberof Konva.Transform.prototype
	         * @param {Konva.Transform} matrix
	         * @returns {Konva.Transform}
	         */
	        multiply: function(matrix) {
	            var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
	            var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
	
	            var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
	            var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
	
	            var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
	            var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
	
	            this.m[0] = m11;
	            this.m[1] = m12;
	            this.m[2] = m21;
	            this.m[3] = m22;
	            this.m[4] = dx;
	            this.m[5] = dy;
	            return this;
	        },
	        /**
	         * Invert the matrix
	         * @method
	         * @memberof Konva.Transform.prototype
	         * @returns {Konva.Transform}
	         */
	        invert: function() {
	            var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
	            var m0 = this.m[3] * d;
	            var m1 = -this.m[1] * d;
	            var m2 = -this.m[2] * d;
	            var m3 = this.m[0] * d;
	            var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
	            var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
	            this.m[0] = m0;
	            this.m[1] = m1;
	            this.m[2] = m2;
	            this.m[3] = m3;
	            this.m[4] = m4;
	            this.m[5] = m5;
	            return this;
	        },
	        /**
	         * return matrix
	         * @method
	         * @memberof Konva.Transform.prototype
	         */
	        getMatrix: function() {
	            return this.m;
	        },
	        /**
	         * set to absolute position via translation
	         * @method
	         * @memberof Konva.Transform.prototype
	         * @returns {Konva.Transform}
	         * @author ericdrowell
	         */
	        setAbsolutePosition: function(x, y) {
	            var m0 = this.m[0],
	                m1 = this.m[1],
	                m2 = this.m[2],
	                m3 = this.m[3],
	                m4 = this.m[4],
	                m5 = this.m[5],
	                yt = ((m0 * (y - m5)) - (m1 * (x - m4))) / ((m0 * m3) - (m1 * m2)),
	                xt = (x - m4 - (m2 * yt)) / m0;
	
	            return this.translate(xt, yt);
	        }
	    };
	
	    // CONSTANTS
	    var CONTEXT_2D = '2d',
	        OBJECT_ARRAY = '[object Array]',
	        OBJECT_NUMBER = '[object Number]',
	        OBJECT_STRING = '[object String]',
	        PI_OVER_DEG180 = Math.PI / 180,
	        DEG180_OVER_PI = 180 / Math.PI,
	        HASH = '#',
	        EMPTY_STRING = '',
	        ZERO = '0',
	        KONVA_WARNING = 'Konva warning: ',
	        KONVA_ERROR = 'Konva error: ',
	        RGB_PAREN = 'rgb(',
	        COLORS = {
	            aliceblue: [240, 248, 255],
	            antiquewhite: [250, 235, 215],
	            aqua: [0, 255, 255],
	            aquamarine: [127, 255, 212],
	            azure: [240, 255, 255],
	            beige: [245, 245, 220],
	            bisque: [255, 228, 196],
	            black: [0, 0, 0],
	            blanchedalmond: [255, 235, 205],
	            blue: [0, 0, 255],
	            blueviolet: [138, 43, 226],
	            brown: [165, 42, 42],
	            burlywood: [222, 184, 135],
	            cadetblue: [95, 158, 160],
	            chartreuse: [127, 255, 0],
	            chocolate: [210, 105, 30],
	            coral: [255, 127, 80],
	            cornflowerblue: [100, 149, 237],
	            cornsilk: [255, 248, 220],
	            crimson: [220, 20, 60],
	            cyan: [0, 255, 255],
	            darkblue: [0, 0, 139],
	            darkcyan: [0, 139, 139],
	            darkgoldenrod: [184, 132, 11],
	            darkgray: [169, 169, 169],
	            darkgreen: [0, 100, 0],
	            darkgrey: [169, 169, 169],
	            darkkhaki: [189, 183, 107],
	            darkmagenta: [139, 0, 139],
	            darkolivegreen: [85, 107, 47],
	            darkorange: [255, 140, 0],
	            darkorchid: [153, 50, 204],
	            darkred: [139, 0, 0],
	            darksalmon: [233, 150, 122],
	            darkseagreen: [143, 188, 143],
	            darkslateblue: [72, 61, 139],
	            darkslategray: [47, 79, 79],
	            darkslategrey: [47, 79, 79],
	            darkturquoise: [0, 206, 209],
	            darkviolet: [148, 0, 211],
	            deeppink: [255, 20, 147],
	            deepskyblue: [0, 191, 255],
	            dimgray: [105, 105, 105],
	            dimgrey: [105, 105, 105],
	            dodgerblue: [30, 144, 255],
	            firebrick: [178, 34, 34],
	            floralwhite: [255, 255, 240],
	            forestgreen: [34, 139, 34],
	            fuchsia: [255, 0, 255],
	            gainsboro: [220, 220, 220],
	            ghostwhite: [248, 248, 255],
	            gold: [255, 215, 0],
	            goldenrod: [218, 165, 32],
	            gray: [128, 128, 128],
	            green: [0, 128, 0],
	            greenyellow: [173, 255, 47],
	            grey: [128, 128, 128],
	            honeydew: [240, 255, 240],
	            hotpink: [255, 105, 180],
	            indianred: [205, 92, 92],
	            indigo: [75, 0, 130],
	            ivory: [255, 255, 240],
	            khaki: [240, 230, 140],
	            lavender: [230, 230, 250],
	            lavenderblush: [255, 240, 245],
	            lawngreen: [124, 252, 0],
	            lemonchiffon: [255, 250, 205],
	            lightblue: [173, 216, 230],
	            lightcoral: [240, 128, 128],
	            lightcyan: [224, 255, 255],
	            lightgoldenrodyellow: [250, 250, 210],
	            lightgray: [211, 211, 211],
	            lightgreen: [144, 238, 144],
	            lightgrey: [211, 211, 211],
	            lightpink: [255, 182, 193],
	            lightsalmon: [255, 160, 122],
	            lightseagreen: [32, 178, 170],
	            lightskyblue: [135, 206, 250],
	            lightslategray: [119, 136, 153],
	            lightslategrey: [119, 136, 153],
	            lightsteelblue: [176, 196, 222],
	            lightyellow: [255, 255, 224],
	            lime: [0, 255, 0],
	            limegreen: [50, 205, 50],
	            linen: [250, 240, 230],
	            magenta: [255, 0, 255],
	            maroon: [128, 0, 0],
	            mediumaquamarine: [102, 205, 170],
	            mediumblue: [0, 0, 205],
	            mediumorchid: [186, 85, 211],
	            mediumpurple: [147, 112, 219],
	            mediumseagreen: [60, 179, 113],
	            mediumslateblue: [123, 104, 238],
	            mediumspringgreen: [0, 250, 154],
	            mediumturquoise: [72, 209, 204],
	            mediumvioletred: [199, 21, 133],
	            midnightblue: [25, 25, 112],
	            mintcream: [245, 255, 250],
	            mistyrose: [255, 228, 225],
	            moccasin: [255, 228, 181],
	            navajowhite: [255, 222, 173],
	            navy: [0, 0, 128],
	            oldlace: [253, 245, 230],
	            olive: [128, 128, 0],
	            olivedrab: [107, 142, 35],
	            orange: [255, 165, 0],
	            orangered: [255, 69, 0],
	            orchid: [218, 112, 214],
	            palegoldenrod: [238, 232, 170],
	            palegreen: [152, 251, 152],
	            paleturquoise: [175, 238, 238],
	            palevioletred: [219, 112, 147],
	            papayawhip: [255, 239, 213],
	            peachpuff: [255, 218, 185],
	            peru: [205, 133, 63],
	            pink: [255, 192, 203],
	            plum: [221, 160, 203],
	            powderblue: [176, 224, 230],
	            purple: [128, 0, 128],
	            rebeccapurple: [102, 51, 153],
	            red: [255, 0, 0],
	            rosybrown: [188, 143, 143],
	            royalblue: [65, 105, 225],
	            saddlebrown: [139, 69, 19],
	            salmon: [250, 128, 114],
	            sandybrown: [244, 164, 96],
	            seagreen: [46, 139, 87],
	            seashell: [255, 245, 238],
	            sienna: [160, 82, 45],
	            silver: [192, 192, 192],
	            skyblue: [135, 206, 235],
	            slateblue: [106, 90, 205],
	            slategray: [119, 128, 144],
	            slategrey: [119, 128, 144],
	            snow: [255, 255, 250],
	            springgreen: [0, 255, 127],
	            steelblue: [70, 130, 180],
	            tan: [210, 180, 140],
	            teal: [0, 128, 128],
	            thistle: [216, 191, 216],
	            transparent: [255, 255, 255, 0],
	            tomato: [255, 99, 71],
	            turquoise: [64, 224, 208],
	            violet: [238, 130, 238],
	            wheat: [245, 222, 179],
	            white: [255, 255, 255],
	            whitesmoke: [245, 245, 245],
	            yellow: [255, 255, 0],
	            yellowgreen: [154, 205, 5]
	        },
	
	        RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;
	
	    /**
	     * @namespace Util
	     * @memberof Konva
	     */
	    Konva.Util = {
	        /*
	         * cherry-picked utilities from underscore.js
	         */
	        _isElement: function(obj) {
	            return !!(obj && obj.nodeType == 1);
	        },
	        _isFunction: function(obj) {
	            return !!(obj && obj.constructor && obj.call && obj.apply);
	        },
	        _isObject: function(obj) {
	            return (!!obj && obj.constructor === Object);
	        },
	        _isArray: function(obj) {
	            return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
	        },
	        _isNumber: function(obj) {
	            return Object.prototype.toString.call(obj) === OBJECT_NUMBER;
	        },
	        _isString: function(obj) {
	            return Object.prototype.toString.call(obj) === OBJECT_STRING;
	        },
	        // Returns a function, that, when invoked, will only be triggered at most once
	        // during a given window of time. Normally, the throttled function will run
	        // as much as it can, without ever going more than once per `wait` duration;
	        // but if you'd like to disable the execution on the leading edge, pass
	        // `{leading: false}`. To disable execution on the trailing edge, ditto.
	        _throttle: function(func, wait, opts) {
	            var context, args, result;
	            var timeout = null;
	            var previous = 0;
	            var options = opts || {};
	            var later = function() {
	                previous = options.leading === false ? 0 : new Date().getTime();
	                timeout = null;
	                result = func.apply(context, args);
	                context = args = null;
	            };
	            return function() {
	                var now = new Date().getTime();
	                if (!previous && options.leading === false) {
	                    previous = now;
	                }
	                var remaining = wait - (now - previous);
	                context = this;
	                args = arguments;
	                if (remaining <= 0) {
	                  clearTimeout(timeout);
	                  timeout = null;
	                  previous = now;
	                  result = func.apply(context, args);
	                  context = args = null;
	                } else if (!timeout && options.trailing !== false) {
	                  timeout = setTimeout(later, remaining);
	                }
	                return result;
	            };
	        },
	        /*
	         * other utils
	         */
	        _hasMethods: function(obj) {
	            var names = [],
	                key;
	
	            for(key in obj) {
	                if (!obj.hasOwnProperty(key)) {
	                    continue;
	                }
	                if(this._isFunction(obj[key])) {
	                    names.push(key);
	                }
	            }
	            return names.length > 0;
	        },
	        isValidSelector: function(selector) {
	            if (typeof selector !== 'string') {
	                return false;
	            }
	            var firstChar = selector[0];
	            return firstChar === '#' || firstChar === '.' || firstChar === firstChar.toUpperCase();
	        },
	        createCanvasElement: function() {
	            var canvas = Konva.document.createElement('canvas');
	            // on some environments canvas.style is readonly
	            try {
	                canvas.style = canvas.style || {};
	            } catch (e) {
	            }
	            return canvas;
	        },
	        isBrowser: function() {
	            return (typeof exports !== 'object');
	        },
	        _isInDocument: function(el) {
	            while(el = el.parentNode) {
	                if(el == Konva.document) {
	                    return true;
	                }
	            }
	            return false;
	        },
	        _simplifyArray: function(arr) {
	            var retArr = [],
	                len = arr.length,
	                util = Konva.Util,
	                n, val;
	
	            for (n = 0; n < len; n++) {
	                val = arr[n];
	                if (util._isNumber(val)) {
	                    val = Math.round(val * 1000) / 1000;
	                }
	                else if (!util._isString(val)) {
	                    val = val.toString();
	                }
	
	                retArr.push(val);
	            }
	
	            return retArr;
	        },
	        /*
	         * arg can be an image object or image data
	         */
	        _getImage: function(arg, callback) {
	            var imageObj, canvas;
	
	            // if arg is null or undefined
	            if(!arg) {
	                callback(null);
	            }
	
	            // if arg is already an image object
	            else if(this._isElement(arg)) {
	                callback(arg);
	            }
	
	            // if arg is a string, then it's a data url
	            else if(this._isString(arg)) {
	                imageObj = new Konva.window.Image();
	                imageObj.onload = function() {
	                    callback(imageObj);
	                };
	                imageObj.src = arg;
	            }
	
	            //if arg is an object that contains the data property, it's an image object
	            else if(arg.data) {
	                canvas = Konva.Util.createCanvasElement();
	                canvas.width = arg.width;
	                canvas.height = arg.height;
	                var _context = canvas.getContext(CONTEXT_2D);
	                _context.putImageData(arg, 0, 0);
	                this._getImage(canvas.toDataURL(), callback);
	            }
	            else {
	                callback(null);
	            }
	        },
	        _getRGBAString: function(obj) {
	            var red = obj.red || 0,
	                green = obj.green || 0,
	                blue = obj.blue || 0,
	                alpha = obj.alpha || 1;
	
	            return [
	                'rgba(',
	                red,
	                ',',
	                green,
	                ',',
	                blue,
	                ',',
	                alpha,
	                ')'
	            ].join(EMPTY_STRING);
	        },
	        _rgbToHex: function(r, g, b) {
	            return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
	        },
	        _hexToRgb: function(hex) {
	            hex = hex.replace(HASH, EMPTY_STRING);
	            var bigint = parseInt(hex, 16);
	            return {
	                r: (bigint >> 16) & 255,
	                g: (bigint >> 8) & 255,
	                b: bigint & 255
	            };
	        },
	        /**
	         * return random hex color
	         * @method
	         * @memberof Konva.Util.prototype
	         */
	        getRandomColor: function() {
	            var randColor = (Math.random() * 0xFFFFFF << 0).toString(16);
	            while (randColor.length < 6) {
	                randColor = ZERO + randColor;
	            }
	            return HASH + randColor;
	        },
	        /**
	         * return value with default fallback
	         * @method
	         * @memberof Konva.Util.prototype
	         */
	        get: function(val, def) {
	            if (val === undefined) {
	                return def;
	            }
	            else {
	                return val;
	            }
	        },
	        /**
	         * get RGB components of a color
	         * @method
	         * @memberof Konva.Util.prototype
	         * @param {String} color
	         * @example
	         * // each of the following examples return {r:0, g:0, b:255}
	         * var rgb = Konva.Util.getRGB('blue');
	         * var rgb = Konva.Util.getRGB('#0000ff');
	         * var rgb = Konva.Util.getRGB('rgb(0,0,255)');
	         */
	        getRGB: function(color) {
	            var rgb;
	            // color string
	            if (color in COLORS) {
	                rgb = COLORS[color];
	                return {
	                    r: rgb[0],
	                    g: rgb[1],
	                    b: rgb[2]
	                };
	            }
	            // hex
	            else if (color[0] === HASH) {
	                return this._hexToRgb(color.substring(1));
	            }
	            // rgb string
	            else if (color.substr(0, 4) === RGB_PAREN) {
	                rgb = RGB_REGEX.exec(color.replace(/ /g, ''));
	                return {
	                    r: parseInt(rgb[1], 10),
	                    g: parseInt(rgb[2], 10),
	                    b: parseInt(rgb[3], 10)
	                };
	            }
	            // default
	            else {
	                return {
	                    r: 0,
	                    g: 0,
	                    b: 0
	                };
	            }
	        },
	        // convert any color string to RGBA object
	        // from https://github.com/component/color-parser
	        colorToRGBA: function(str) {
	            str = str || 'black';
	            return Konva.Util._namedColorToRBA(str)
	                || Konva.Util._hex3ColorToRGBA(str)
	                || Konva.Util._hex6ColorToRGBA(str)
	                || Konva.Util._rgbColorToRGBA(str)
	                || Konva.Util._rgbaColorToRGBA(str);
	        },
	        // Parse named css color. Like "green"
	        _namedColorToRBA: function(str) {
	            var c = COLORS[str.toLowerCase()];
	            if (!c) {
	                return null;
	            }
	            return {
	                r: c[0],
	                g: c[1],
	                b: c[2],
	                a: 1
	            };
	        },
	        // Parse rgb(n, n, n)
	        _rgbColorToRGBA: function(str) {
	            if (str.indexOf('rgb(') === 0) {
	                str = str.match(/rgb\(([^)]+)\)/)[1];
	                var parts = str.split(/ *, */).map(Number);
	                return {
	                    r: parts[0],
	                    g: parts[1],
	                    b: parts[2],
	                    a: 1
	                };
	            }
	        },
	        // Parse rgba(n, n, n, n)
	        _rgbaColorToRGBA: function(str) {
	            if (str.indexOf('rgba(') === 0) {
	                str = str.match(/rgba\(([^)]+)\)/)[1];
	                var parts = str.split(/ *, */).map(Number);
	                return {
	                    r: parts[0],
	                    g: parts[1],
	                    b: parts[2],
	                    a: parts[3]
	                };
	            }
	
	        },
	        // Parse #nnnnnn
	        _hex6ColorToRGBA: function(str) {
	            if ((str[0] === '#') && (str.length === 7)) {
	                return {
	                    r: parseInt(str.slice(1, 3), 16),
	                    g: parseInt(str.slice(3, 5), 16),
	                    b: parseInt(str.slice(5, 7), 16),
	                    a: 1
	                };
	            }
	        },
	        // Parse #nnn
	        _hex3ColorToRGBA: function(str) {
	            if ((str[0] === '#') && (str.length === 4)) {
	                return {
	                    r: parseInt(str[1] + str[1], 16),
	                    g: parseInt(str[2] + str[2], 16),
	                    b: parseInt(str[3] + str[3], 16),
	                    a: 1
	                };
	            }
	        },
	        // o1 takes precedence over o2
	        _merge: function(o1, o2) {
	            var retObj = this._clone(o2);
	            for(var key in o1) {
	                if(this._isObject(o1[key])) {
	                    retObj[key] = this._merge(o1[key], retObj[key]);
	                }
	                else {
	                    retObj[key] = o1[key];
	                }
	            }
	            return retObj;
	        },
	        cloneObject: function(obj) {
	            var retObj = {};
	            for(var key in obj) {
	                if(this._isObject(obj[key])) {
	                    retObj[key] = this.cloneObject(obj[key]);
	                }
	                else if (this._isArray(obj[key])) {
	                    retObj[key] = this.cloneArray(obj[key]);
	                } else {
	                    retObj[key] = obj[key];
	                }
	            }
	            return retObj;
	        },
	        cloneArray: function(arr) {
	            return arr.slice(0);
	        },
	        _degToRad: function(deg) {
	            return deg * PI_OVER_DEG180;
	        },
	        _radToDeg: function(rad) {
	            return rad * DEG180_OVER_PI;
	        },
	        _capitalize: function(str) {
	            return str.charAt(0).toUpperCase() + str.slice(1);
	        },
	        throw: function(str) {
	            throw new Error(KONVA_ERROR + str);
	        },
	        error: function(str) {
	          console.error(KONVA_ERROR + str);
	        },
	        warn: function(str) {
	            /*
	             * IE9 on Windows7 64bit will throw a JS error
	             * if we don't use window.console in the conditional
	             */
	            if(Konva.global.console && console.warn && Konva.showWarnings) {
	                console.warn(KONVA_WARNING + str);
	            }
	        },
	        extend: function(child, parent) {
	            function Ctor() {
	                this.constructor = child;
	            }
	            Ctor.prototype = parent.prototype;
	            var oldProto = child.prototype;
	            child.prototype = new Ctor();
	            for (var key in oldProto) {
	                if (oldProto.hasOwnProperty(key)) {
	                    child.prototype[key] = oldProto[key];
	                }
	            }
	            child.__super__ = parent.prototype;
	            // create reference to parent
	            child.super = parent;
	        },
	        /**
	         * adds methods to a constructor prototype
	         * @method
	         * @memberof Konva.Util.prototype
	         * @param {Function} constructor
	         * @param {Object} methods
	         */
	        addMethods: function(constructor, methods) {
	            var key;
	
	            for (key in methods) {
	                constructor.prototype[key] = methods[key];
	            }
	        },
	        _getControlPoints: function(x0, y0, x1, y1, x2, y2, t) {
	            var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)),
	                d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),
	                fa = t * d01 / (d01 + d12),
	                fb = t * d12 / (d01 + d12),
	                p1x = x1 - fa * (x2 - x0),
	                p1y = y1 - fa * (y2 - y0),
	                p2x = x1 + fb * (x2 - x0),
	                p2y = y1 + fb * (y2 - y0);
	
	            return [p1x, p1y, p2x, p2y];
	        },
	        _expandPoints: function(p, tension) {
	            var len = p.length,
	                allPoints = [],
	                n, cp;
	
	            for (n = 2; n < len - 2; n += 2) {
	                cp = Konva.Util._getControlPoints(p[n - 2], p[n - 1], p[n], p[n + 1], p[n + 2], p[n + 3], tension);
	                allPoints.push(cp[0]);
	                allPoints.push(cp[1]);
	                allPoints.push(p[n]);
	                allPoints.push(p[n + 1]);
	                allPoints.push(cp[2]);
	                allPoints.push(cp[3]);
	            }
	
	            return allPoints;
	        },
	        _removeLastLetter: function(str) {
	            return str.substring(0, str.length - 1);
	        },
	        each: function(obj, func) {
	            for (var key in obj) {
	                func(key, obj[key]);
	            }
	        },
	        _getProjectionToSegment: function(x1, y1, x2, y2, x3, y3) {
	            var x, y, dist;
	
	            var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	            if(pd2 == 0) {
	                x = x1;
	                y = y1;
	                dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
	            } else {
	                var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
	                if(u < 0) {
	                    x = x1;
	                    y = y1;
	                    dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
	                } else if (u > 1.0) {
	                    x = x2;
	                    y = y2;
	                    dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
	                } else {
	                    x = x1 + u * (x2 - x1);
	                    y = y1 + u * (y2 - y1);
	                    dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
	                }
	            }
	            return [x, y, dist];
	        },
	        // line as array of points.
	        // line might be closed
	        _getProjectionToLine: function(pt, line, isClosed) {
	            var pc = Konva.Util.cloneObject(pt);
	            var dist = Number.MAX_VALUE;
	            line.forEach(function(p1, i) {
	                if (!isClosed && i === line.length - 1) {
	                    return;
	                }
	                var p2 = line[(i + 1) % line.length];
	                var proj = Konva.Util._getProjectionToSegment(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
	                var px = proj[0], py = proj[1], pdist = proj[2];
	                if (pdist < dist) {
	                    pc.x = px;
	                    pc.y = py;
	                    dist = pdist;
	                }
	            });
	            return pc;
	        },
	        _prepareArrayForTween: function(startArray, endArray, isClosed) {
	            var n, start = [], end = [];
	            if (startArray.length > endArray.length) {
	                var temp = endArray;
	                endArray = startArray;
	                startArray = temp;
	            }
	            for (n = 0; n < startArray.length; n += 2) {
	                start.push({
	                    x: startArray[n],
	                    y: startArray[n + 1]
	                });
	            }
	            for (n = 0; n < endArray.length; n += 2) {
	                end.push({
	                    x: endArray[n],
	                    y: endArray[n + 1]
	                });
	            }
	
	
	            var newStart = [];
	            end.forEach(function(point) {
	                var pr = Konva.Util._getProjectionToLine(point, start, isClosed);
	                newStart.push(pr.x);
	                newStart.push(pr.y);
	            });
	            return newStart;
	        },
	        _prepareToStringify: function(obj) {
	            var desc;
	
	            obj.visitedByCircularReferenceRemoval = true;
	
	            for(var key in obj) {
	                if (!(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == 'object')) {
	                    continue;
	                }
	                desc = Object.getOwnPropertyDescriptor(obj, key);
	                if (obj[key].visitedByCircularReferenceRemoval || Konva.Util._isElement(obj[key])) {
	                    if (desc.configurable) {
	                        delete obj[key];
	                    } else {
	                        return null;
	                    }
	                } else if (Konva.Util._prepareToStringify(obj[key]) === null) {
	                    if (desc.configurable) {
	                        delete obj[key];
	                    } else {
	                        return null;
	                    }
	                }
	            }
	
	            delete obj.visitedByCircularReferenceRemoval;
	
	            return obj;
	        }
	    };
	})();
	
	(function() {
	    'use strict';
	    // calculate pixel ratio
	    var canvas = Konva.Util.createCanvasElement(),
	        context = canvas.getContext('2d'),
	        _pixelRatio = (function(){
	            var devicePixelRatio = Konva.window.devicePixelRatio || 1,
	            backingStoreRatio = context.webkitBackingStorePixelRatio
	                || context.mozBackingStorePixelRatio
	                || context.msBackingStorePixelRatio
	                || context.oBackingStorePixelRatio
	                || context.backingStorePixelRatio
	                || 1;
	            return devicePixelRatio / backingStoreRatio;
	        })();
	
	    /**
	     * Canvas Renderer constructor
	     * @constructor
	     * @abstract
	     * @memberof Konva
	     * @param {Object} config
	     * @param {Number} config.width
	     * @param {Number} config.height
	     * @param {Number} config.pixelRatio KonvaJS automatically handles pixel ratio adjustments in order to render crisp drawings
	     *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
	     *  of 1.  Some high end tablets and phones, like iPhones and iPads (not the mini) have a device pixel ratio
	     *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
	     *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
	     *  specified, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
	     *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
	     */
	    Konva.Canvas = function(config) {
	        this.init(config);
	    };
	
	    Konva.Canvas.prototype = {
	        init: function(config) {
	            var conf = config || {};
	
	            var pixelRatio = conf.pixelRatio || Konva.pixelRatio || _pixelRatio;
	
	            this.pixelRatio = pixelRatio;
	            this._canvas = Konva.Util.createCanvasElement();
	
	            // set inline styles
	            this._canvas.style.padding = 0;
	            this._canvas.style.margin = 0;
	            this._canvas.style.border = 0;
	            this._canvas.style.background = 'transparent';
	            this._canvas.style.position = 'absolute';
	            this._canvas.style.top = 0;
	            this._canvas.style.left = 0;
	        },
	        /**
	         * get canvas context
	         * @method
	         * @memberof Konva.Canvas.prototype
	         * @returns {CanvasContext} context
	         */
	        getContext: function() {
	            return this.context;
	        },
	        /**
	         * get pixel ratio
	         * @method
	         * @memberof Konva.Canvas.prototype
	         * @returns {Number} pixel ratio
	         */
	        getPixelRatio: function() {
	            return this.pixelRatio;
	        },
	        /**
	         * get pixel ratio
	         * @method
	         * @memberof Konva.Canvas.prototype
	         * @param {Number} pixelRatio KonvaJS automatically handles pixel ratio adustments in order to render crisp drawings
	         *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
	         *  of 1.  Some high end tablets and phones, like iPhones and iPads have a device pixel ratio
	         *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
	         *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
	         *  specificed, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
	         *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
	         */
	        setPixelRatio: function(pixelRatio) {
	            var previousRatio = this.pixelRatio;
	            this.pixelRatio = pixelRatio;
	            this.setSize(this.getWidth() / previousRatio, this.getHeight() / previousRatio);
	        },
	        /**
	         * set width
	         * @method
	         * @memberof Konva.Canvas.prototype
	         * @param {Number} width
	         */
	        setWidth: function(width) {
	            // take into account pixel ratio
	            this.width = this._canvas.width = width * this.pixelRatio;
	            this._canvas.style.width = width + 'px';
	
	            var pixelRatio = this.pixelRatio,
	                _context = this.getContext()._context;
	            _context.scale(pixelRatio, pixelRatio);
	        },
	        /**
	         * set height
	         * @method
	         * @memberof Konva.Canvas.prototype
	         * @param {Number} height
	         */
	        setHeight: function(height) {
	            // take into account pixel ratio
	            this.height = this._canvas.height = height * this.pixelRatio;
	            this._canvas.style.height = height + 'px';
	            var pixelRatio = this.pixelRatio,
	                _context = this.getContext()._context;
	            _context.scale(pixelRatio, pixelRatio);
	        },
	        /**
	         * get width
	         * @method
	         * @memberof Konva.Canvas.prototype
	         * @returns {Number} width
	         */
	        getWidth: function() {
	            return this.width;
	        },
	        /**
	         * get height
	         * @method
	         * @memberof Konva.Canvas.prototype
	         * @returns {Number} height
	         */
	        getHeight: function() {
	            return this.height;
	        },
	        /**
	         * set size
	         * @method
	         * @memberof Konva.Canvas.prototype
	         * @param {Number} width
	         * @param {Number} height
	         */
	        setSize: function(width, height) {
	            this.setWidth(width);
	            this.setHeight(height);
	        },
	        /**
	         * to data url
	         * @method
	         * @memberof Konva.Canvas.prototype
	         * @param {String} mimeType
	         * @param {Number} quality between 0 and 1 for jpg mime types
	         * @returns {String} data url string
	         */
	        toDataURL: function(mimeType, quality) {
	            try {
	                // If this call fails (due to browser bug, like in Firefox 3.6),
	                // then revert to previous no-parameter image/png behavior
	                return this._canvas.toDataURL(mimeType, quality);
	            }
	            catch(e) {
	                try {
	                    return this._canvas.toDataURL();
	                }
	                catch(err) {
	                    Konva.Util.warn('Unable to get data URL. ' + err.message);
	                    return '';
	                }
	            }
	        }
	    };
	
	    Konva.SceneCanvas = function(config) {
	        var conf = config || {};
	        var width = conf.width || 0,
	            height = conf.height || 0;
	
	        Konva.Canvas.call(this, conf);
	        this.context = new Konva.SceneContext(this);
	        this.setSize(width, height);
	    };
	
	    Konva.Util.extend(Konva.SceneCanvas, Konva.Canvas);
	
	    Konva.HitCanvas = function(config) {
	        var conf = config || {};
	        var width = conf.width || 0,
	            height = conf.height || 0;
	
	        Konva.Canvas.call(this, conf);
	        this.context = new Konva.HitContext(this);
	        this.setSize(width, height);
	        this.hitCanvas = true;
	    };
	    Konva.Util.extend(Konva.HitCanvas, Konva.Canvas);
	
	})();
	
	(function() {
	    'use strict';
	    var COMMA = ',',
	        OPEN_PAREN = '(',
	        CLOSE_PAREN = ')',
	        OPEN_PAREN_BRACKET = '([',
	        CLOSE_BRACKET_PAREN = '])',
	        SEMICOLON = ';',
	        DOUBLE_PAREN = '()',
	        // EMPTY_STRING = '',
	        EQUALS = '=',
	        // SET = 'set',
	        CONTEXT_METHODS = [
	            'arc',
	            'arcTo',
	            'beginPath',
	            'bezierCurveTo',
	            'clearRect',
	            'clip',
	            'closePath',
	            'createLinearGradient',
	            'createPattern',
	            'createRadialGradient',
	            'drawImage',
	            'fill',
	            'fillText',
	            'getImageData',
	            'createImageData',
	            'lineTo',
	            'moveTo',
	            'putImageData',
	            'quadraticCurveTo',
	            'rect',
	            'restore',
	            'rotate',
	            'save',
	            'scale',
	            'setLineDash',
	            'setTransform',
	            'stroke',
	            'strokeText',
	            'transform',
	            'translate'
	        ];
	
	    var CONTEXT_PROPERTIES = ['fillStyle', 'strokeStyle', 'shadowColor', 'shadowBlur', 'shadowOffsetX',
	        'shadowOffsetY', 'lineCap', 'lineJoin', 'lineWidth', 'miterLimit', 'font', 'textAlign', 'textBaseline',
	        'globalAlpha', 'globalCompositeOperation'];
	
	    /**
	     * Canvas Context constructor
	     * @constructor
	     * @abstract
	     * @memberof Konva
	     */
	    Konva.Context = function(canvas) {
	        this.init(canvas);
	    };
	
	    Konva.Context.prototype = {
	        init: function(canvas) {
	            this.canvas = canvas;
	            this._context = canvas._canvas.getContext('2d');
	
	            if (Konva.enableTrace) {
	                this.traceArr = [];
	                this._enableTrace();
	            }
	        },
	        /**
	         * fill shape
	         * @method
	         * @memberof Konva.Context.prototype
	         * @param {Konva.Shape} shape
	         */
	        fillShape: function(shape) {
	            if(shape.getFillEnabled()) {
	                this._fill(shape);
	            }
	        },
	        /**
	         * stroke shape
	         * @method
	         * @memberof Konva.Context.prototype
	         * @param {Konva.Shape} shape
	         */
	        strokeShape: function(shape) {
	            if(shape.getStrokeEnabled()) {
	                this._stroke(shape);
	            }
	        },
	        /**
	         * fill then stroke
	         * @method
	         * @memberof Konva.Context.prototype
	         * @param {Konva.Shape} shape
	         */
	        fillStrokeShape: function(shape) {
	            var fillEnabled = shape.getFillEnabled();
	            if(fillEnabled) {
	                this._fill(shape);
	            }
	            if(shape.getStrokeEnabled()) {
	                this._stroke(shape);
	            }
	        },
	        /**
	         * get context trace if trace is enabled
	         * @method
	         * @memberof Konva.Context.prototype
	         * @param {Boolean} relaxed if false, return strict context trace, which includes method names, method parameters
	         *  properties, and property values.  If true, return relaxed context trace, which only returns method names and
	         *  properites.
	         * @returns {String}
	         */
	        getTrace: function(relaxed) {
	            var traceArr = this.traceArr,
	                len = traceArr.length,
	                str = '',
	                n, trace, method, args;
	
	            for (n = 0; n < len; n++) {
	                trace = traceArr[n];
	                method = trace.method;
	
	                // methods
	                if (method) {
	                    args = trace.args;
	                    str += method;
	                    if (relaxed) {
	                        str += DOUBLE_PAREN;
	                    }
	                    else {
	                        if (Konva.Util._isArray(args[0])) {
	                            str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
	                        }
	                        else {
	                            str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
	                        }
	                    }
	                }
	                // properties
	                else {
	                    str += trace.property;
	                    if (!relaxed) {
	                        str += EQUALS + trace.val;
	                    }
	                }
	
	                str += SEMICOLON;
	            }
	
	            return str;
	        },
	        /**
	         * clear trace if trace is enabled
	         * @method
	         * @memberof Konva.Context.prototype
	         */
	        clearTrace: function() {
	            this.traceArr = [];
	        },
	        _trace: function(str) {
	            var traceArr = this.traceArr,
	                len;
	
	            traceArr.push(str);
	            len = traceArr.length;
	
	            if (len >= Konva.traceArrMax) {
	                traceArr.shift();
	            }
	        },
	        /**
	         * reset canvas context transform
	         * @method
	         * @memberof Konva.Context.prototype
	         */
	        reset: function() {
	            var pixelRatio = this.getCanvas().getPixelRatio();
	            this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
	        },
	        /**
	         * get canvas
	         * @method
	         * @memberof Konva.Context.prototype
	         * @returns {Konva.Canvas}
	         */
	        getCanvas: function() {
	            return this.canvas;
	        },
	        /**
	         * clear canvas
	         * @method
	         * @memberof Konva.Context.prototype
	         * @param {Object} [bounds]
	         * @param {Number} [bounds.x]
	         * @param {Number} [bounds.y]
	         * @param {Number} [bounds.width]
	         * @param {Number} [bounds.height]
	         */
	        clear: function(bounds) {
	            var canvas = this.getCanvas();
	
	            if (bounds) {
	                this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);
	            }
	            else {
	                this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);
	            }
	        },
	        _applyLineCap: function(shape) {
	            var lineCap = shape.getLineCap();
	            if(lineCap) {
	                this.setAttr('lineCap', lineCap);
	            }
	        },
	        _applyOpacity: function(shape) {
	            var absOpacity = shape.getAbsoluteOpacity();
	            if(absOpacity !== 1) {
	                this.setAttr('globalAlpha', absOpacity);
	            }
	        },
	        _applyLineJoin: function(shape) {
	            var lineJoin = shape.getLineJoin();
	            if(lineJoin) {
	                this.setAttr('lineJoin', lineJoin);
	            }
	        },
	        setAttr: function(attr, val) {
	            this._context[attr] = val;
	        },
	
	        // context pass through methods
	        arc: function() {
	            var a = arguments;
	            this._context.arc(a[0], a[1], a[2], a[3], a[4], a[5]);
	        },
	        beginPath: function() {
	            this._context.beginPath();
	        },
	        bezierCurveTo: function() {
	            var a = arguments;
	            this._context.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
	        },
	        clearRect: function() {
	            var a = arguments;
	            this._context.clearRect(a[0], a[1], a[2], a[3]);
	        },
	        clip: function() {
	            this._context.clip();
	        },
	        closePath: function() {
	            this._context.closePath();
	        },
	        createImageData: function() {
	            var a = arguments;
	            if(a.length === 2) {
	                return this._context.createImageData(a[0], a[1]);
	            }
	            else if(a.length === 1) {
	                return this._context.createImageData(a[0]);
	            }
	        },
	        createLinearGradient: function() {
	            var a = arguments;
	            return this._context.createLinearGradient(a[0], a[1], a[2], a[3]);
	        },
	        createPattern: function() {
	            var a = arguments;
	            return this._context.createPattern(a[0], a[1]);
	        },
	        createRadialGradient: function() {
	            var a = arguments;
	            return this._context.createRadialGradient(a[0], a[1], a[2], a[3], a[4], a[5]);
	        },
	        drawImage: function() {
	            var a = arguments,
	                _context = this._context;
	
	            if(a.length === 3) {
	                _context.drawImage(a[0], a[1], a[2]);
	            }
	            else if(a.length === 5) {
	                _context.drawImage(a[0], a[1], a[2], a[3], a[4]);
	            }
	            else if(a.length === 9) {
	                _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
	            }
	        },
	        isPointInPath: function(x, y) {
	            return this._context.isPointInPath(x, y);
	        },
	        fill: function() {
	            this._context.fill();
	        },
	        fillRect: function(x, y, width, height) {
	            this._context.fillRect(x, y, width, height);
	        },
	        strokeRect: function(x, y, width, height) {
	            this._context.strokeRect(x, y, width, height);
	        },
	        fillText: function() {
	            var a = arguments;
	            this._context.fillText(a[0], a[1], a[2]);
	        },
	        measureText: function(text) {
	            return this._context.measureText(text);
	        },
	        getImageData: function() {
	            var a = arguments;
	            return this._context.getImageData(a[0], a[1], a[2], a[3]);
	        },
	        lineTo: function() {
	            var a = arguments;
	            this._context.lineTo(a[0], a[1]);
	        },
	        moveTo: function() {
	            var a = arguments;
	            this._context.moveTo(a[0], a[1]);
	        },
	        rect: function() {
	            var a = arguments;
	            this._context.rect(a[0], a[1], a[2], a[3]);
	        },
	        putImageData: function() {
	            var a = arguments;
	            this._context.putImageData(a[0], a[1], a[2]);
	        },
	        quadraticCurveTo: function() {
	            var a = arguments;
	            this._context.quadraticCurveTo(a[0], a[1], a[2], a[3]);
	        },
	        restore: function() {
	            this._context.restore();
	        },
	        rotate: function() {
	            var a = arguments;
	            this._context.rotate(a[0]);
	        },
	        save: function() {
	            this._context.save();
	        },
	        scale: function() {
	            var a = arguments;
	            this._context.scale(a[0], a[1]);
	        },
	        setLineDash: function() {
	            var a = arguments,
	                _context = this._context;
	
	            // works for Chrome and IE11
	            if(this._context.setLineDash) {
	                _context.setLineDash(a[0]);
	            }
	            // verified that this works in firefox
	            else if('mozDash' in _context) {
	                _context.mozDash = a[0];
	            }
	            // does not currently work for Safari
	            else if('webkitLineDash' in _context) {
	                _context.webkitLineDash = a[0];
	            }
	
	            // no support for IE9 and IE10
	        },
	        getLineDash: function() {
	            return this._context.getLineDash();
	        },
	        setTransform: function() {
	            var a = arguments;
	            this._context.setTransform(a[0], a[1], a[2], a[3], a[4], a[5]);
	        },
	        stroke: function() {
	            this._context.stroke();
	        },
	        strokeText: function() {
	            var a = arguments;
	            this._context.strokeText(a[0], a[1], a[2]);
	        },
	        transform: function() {
	            var a = arguments;
	            this._context.transform(a[0], a[1], a[2], a[3], a[4], a[5]);
	        },
	        translate: function() {
	            var a = arguments;
	            this._context.translate(a[0], a[1]);
	        },
	        _enableTrace: function() {
	            var that = this,
	                len = CONTEXT_METHODS.length,
	                _simplifyArray = Konva.Util._simplifyArray,
	                origSetter = this.setAttr,
	                n, args;
	
	            // to prevent creating scope function at each loop
	            var func = function(methodName) {
	                    var origMethod = that[methodName],
	                        ret;
	
	                    that[methodName] = function() {
	                        args = _simplifyArray(Array.prototype.slice.call(arguments, 0));
	                        ret = origMethod.apply(that, arguments);
	
	                        that._trace({
	                            method: methodName,
	                            args: args
	                        });
	
	                        return ret;
	                    };
	            };
	            // methods
	            for (n = 0; n < len; n++) {
	                func(CONTEXT_METHODS[n]);
	            }
	
	            // attrs
	            that.setAttr = function() {
	                origSetter.apply(that, arguments);
	                that._trace({
	                    property: arguments[0],
	                    val: arguments[1]
	                });
	            };
	        }
	    };
	
	    CONTEXT_PROPERTIES.forEach(function(prop) {
	        Object.defineProperty(Konva.Context.prototype, prop, {
	            get: function () {
	                return this._context[prop];
	            },
	            set: function (val) {
	                this._context[prop] = val;
	            }
	        });
	    });
	
	    Konva.SceneContext = function(canvas) {
	        Konva.Context.call(this, canvas);
	    };
	
	    Konva.SceneContext.prototype = {
	        _fillColor: function(shape) {
	            var fill = shape.fill();
	
	            this.setAttr('fillStyle', fill);
	            shape._fillFunc(this);
	        },
	        _fillPattern: function(shape) {
	            var fillPatternX = shape.getFillPatternX(),
	                fillPatternY = shape.getFillPatternY(),
	                fillPatternScale = shape.getFillPatternScale(),
	                fillPatternRotation = Konva.getAngle(shape.getFillPatternRotation()),
	                fillPatternOffset = shape.getFillPatternOffset();
	
	            if(fillPatternX || fillPatternY) {
	                this.translate(fillPatternX || 0, fillPatternY || 0);
	            }
	            if(fillPatternRotation) {
	                this.rotate(fillPatternRotation);
	            }
	            if(fillPatternScale) {
	                this.scale(fillPatternScale.x, fillPatternScale.y);
	            }
	            if(fillPatternOffset) {
	                this.translate(-1 * fillPatternOffset.x, -1 * fillPatternOffset.y);
	            }
	
	            this.setAttr('fillStyle', this.createPattern(shape.getFillPatternImage(), shape.getFillPatternRepeat() || 'repeat'));
	            this.fill();
	        },
	        _fillLinearGradient: function(shape) {
	            var start = shape.getFillLinearGradientStartPoint(),
	                end = shape.getFillLinearGradientEndPoint(),
	                colorStops = shape.getFillLinearGradientColorStops(),
	                grd = this.createLinearGradient(start.x, start.y, end.x, end.y);
	
	            if (colorStops) {
	                // build color stops
	                for(var n = 0; n < colorStops.length; n += 2) {
	                    grd.addColorStop(colorStops[n], colorStops[n + 1]);
	                }
	                this.setAttr('fillStyle', grd);
	                shape._fillFunc(this);
	            }
	        },
	        _fillRadialGradient: function(shape) {
	            var start = shape.getFillRadialGradientStartPoint(),
	                end = shape.getFillRadialGradientEndPoint(),
	                startRadius = shape.getFillRadialGradientStartRadius(),
	                endRadius = shape.getFillRadialGradientEndRadius(),
	                colorStops = shape.getFillRadialGradientColorStops(),
	                grd = this.createRadialGradient(start.x, start.y, startRadius, end.x, end.y, endRadius);
	
	            // build color stops
	            for(var n = 0; n < colorStops.length; n += 2) {
	                grd.addColorStop(colorStops[n], colorStops[n + 1]);
	            }
	            this.setAttr('fillStyle', grd);
	            this.fill();
	        },
	        _fill: function(shape) {
	            var hasColor = shape.fill(),
	                hasPattern = shape.getFillPatternImage(),
	                hasLinearGradient = shape.getFillLinearGradientColorStops(),
	                hasRadialGradient = shape.getFillRadialGradientColorStops(),
	                fillPriority = shape.getFillPriority();
	
	            // priority fills
	            if(hasColor && fillPriority === 'color') {
	                this._fillColor(shape);
	            }
	            else if(hasPattern && fillPriority === 'pattern') {
	                this._fillPattern(shape);
	            }
	            else if(hasLinearGradient && fillPriority === 'linear-gradient') {
	                this._fillLinearGradient(shape);
	            }
	            else if(hasRadialGradient && fillPriority === 'radial-gradient') {
	                this._fillRadialGradient(shape);
	            }
	            // now just try and fill with whatever is available
	            else if(hasColor) {
	                this._fillColor(shape);
	            }
	            else if(hasPattern) {
	                this._fillPattern(shape);
	            }
	            else if(hasLinearGradient) {
	                this._fillLinearGradient(shape);
	            }
	            else if(hasRadialGradient) {
	                this._fillRadialGradient(shape);
	            }
	        },
	        _stroke: function(shape) {
	            var dash = shape.dash(),
	                // ignore strokeScaleEnabled for Text
	                strokeScaleEnabled = (shape.getStrokeScaleEnabled() || (shape instanceof Konva.Text));
	
	            if(shape.hasStroke()) {
	                if (!strokeScaleEnabled) {
	                    this.save();
	                    this.setTransform(1, 0, 0, 1, 0, 0);
	                }
	
	                this._applyLineCap(shape);
	                if(dash && shape.dashEnabled()) {
	                    this.setLineDash(dash);
	                }
	
	                this.setAttr('lineWidth', shape.strokeWidth());
	                this.setAttr('strokeStyle', shape.stroke());
	
	                if (!shape.getShadowForStrokeEnabled()) {
	                    this.setAttr('shadowColor', 'rgba(0,0,0,0)');
	                }
	                shape._strokeFunc(this);
	
	                if (!strokeScaleEnabled) {
	                    this.restore();
	                }
	            }
	        },
	        _applyShadow: function(shape) {
	            var util = Konva.Util,
	                color = util.get(shape.getShadowRGBA(), 'black'),
	                blur = util.get(shape.getShadowBlur(), 5),
	                offset = util.get(shape.getShadowOffset(), {
	                    x: 0,
	                    y: 0
	                }),
	                // TODO: get this info from transform??
	                scale = shape.getAbsoluteScale(),
	                scaleX = scale.x,
	                scaleY = scale.y;
	
	            this.setAttr('shadowColor', color);
	            this.setAttr('shadowBlur', blur);
	            this.setAttr('shadowOffsetX', offset.x * scaleX);
	            this.setAttr('shadowOffsetY', offset.y * scaleY);
	        }
	    };
	    Konva.Util.extend(Konva.SceneContext, Konva.Context);
	
	    Konva.HitContext = function(canvas) {
	        Konva.Context.call(this, canvas);
	    };
	
	    Konva.HitContext.prototype = {
	        _fill: function(shape) {
	            this.save();
	            this.setAttr('fillStyle', shape.colorKey);
	            shape._fillFuncHit(this);
	            this.restore();
	        },
	        _stroke: function(shape) {
	            if(shape.hasStroke() && shape.strokeHitEnabled()) {
	                // ignore strokeScaleEnabled for Text
	                var strokeScaleEnabled = (shape.getStrokeScaleEnabled() || (shape instanceof Konva.Text));
	                if (!strokeScaleEnabled) {
	                    this.save();
	                    this.setTransform(1, 0, 0, 1, 0, 0);
	                }
	                this._applyLineCap(shape);
	                this.setAttr('lineWidth', shape.strokeWidth());
	                this.setAttr('strokeStyle', shape.colorKey);
	                shape._strokeFuncHit(this);
	                if (!strokeScaleEnabled) {
	                    this.restore();
	                }
	            }
	        }
	    };
	    Konva.Util.extend(Konva.HitContext, Konva.Context);
	})();
	
	(function() {
	    'use strict';
	    // CONSTANTS
	    var GET = 'get',
	        SET = 'set';
	
	    Konva.Factory = {
	        addGetterSetter: function(constructor, attr, def, validator, after) {
	            this.addGetter(constructor, attr, def);
	            this.addSetter(constructor, attr, validator, after);
	            this.addOverloadedGetterSetter(constructor, attr);
	        },
	        addGetter: function(constructor, attr, def) {
	            var method = GET + Konva.Util._capitalize(attr);
	
	            constructor.prototype[method] = function() {
	                var val = this.attrs[attr];
	                return val === undefined ? def : val;
	            };
	        },
	        addSetter: function(constructor, attr, validator, after) {
	            var method = SET + Konva.Util._capitalize(attr);
	
	            constructor.prototype[method] = function(val) {
	                if (validator) {
	                    val = validator.call(this, val);
	                }
	
	                this._setAttr(attr, val);
	
	                if (after) {
	                    after.call(this);
	                }
	
	                return this;
	            };
	        },
	        addComponentsGetterSetter: function(constructor, attr, components, validator, after) {
	            var len = components.length,
	                capitalize = Konva.Util._capitalize,
	                getter = GET + capitalize(attr),
	                setter = SET + capitalize(attr),
	                n, component;
	
	            // getter
	            constructor.prototype[getter] = function() {
	                var ret = {};
	
	                for (n = 0; n < len; n++) {
	                    component = components[n];
	                    ret[component] = this.getAttr(attr + capitalize(component));
	                }
	
	                return ret;
	            };
	
	            // setter
	            constructor.prototype[setter] = function(val) {
	                var oldVal = this.attrs[attr],
	                    key;
	
	                if (validator) {
	                    val = validator.call(this, val);
	                }
	
	                for (key in val) {
	                    if (!val.hasOwnProperty(key)) {
	                        continue;
	                    }
	                    this._setAttr(attr + capitalize(key), val[key]);
	                }
	
	                this._fireChangeEvent(attr, oldVal, val);
	
	                if (after) {
	                    after.call(this);
	                }
	
	                return this;
	            };
	
	            this.addOverloadedGetterSetter(constructor, attr);
	        },
	        addOverloadedGetterSetter: function(constructor, attr) {
	            var capitalizedAttr = Konva.Util._capitalize(attr),
	                setter = SET + capitalizedAttr,
	                getter = GET + capitalizedAttr;
	
	            constructor.prototype[attr] = function() {
	                // setting
	                if (arguments.length) {
	                    this[setter](arguments[0]);
	                    return this;
	                }
	                // getting
	                return this[getter]();
	            };
	        },
	        addDeprecatedGetterSetter: function(constructor, attr, def, validator) {
	            var method = GET + Konva.Util._capitalize(attr);
	            var message = attr + ' property is deprecated and will be removed soon. Look at Konva change log for more information.';
	            constructor.prototype[method] = function() {
	                Konva.Util.error(message);
	                var val = this.attrs[attr];
	                return val === undefined ? def : val;
	            };
	            this.addSetter(constructor, attr, validator, function() {
	              Konva.Util.error(message);
	            });
	            this.addOverloadedGetterSetter(constructor, attr);
	        },
	        backCompat: function(constructor, methods) {
	            Konva.Util.each(methods, function(oldMethodName, newMethodName) {
	                var method = constructor.prototype[newMethodName];
	                constructor.prototype[oldMethodName] = function(){
	                    method.apply(this, arguments);
	                    Konva.Util.error(oldMethodName + ' method is deprecated and will be removed soon. Use ' + newMethodName + ' instead');
	                };
	            });
	        },
	        afterSetFilter: function() {
	            this._filterUpToDate = false;
	        }
	    };
	
	    Konva.Validators = {
	        /**
	         * @return {number}
	         */
	        RGBComponent: function(val) {
	            if (val > 255) {
	                return 255;
	            } else if (val < 0) {
	                return 0;
	            }
	            return Math.round(val);
	        },
	        alphaComponent: function(val) {
	            if (val > 1) {
	                return 1;
	            }
	            // chrome does not honor alpha values of 0
	            else if (val < 0.0001) {
	                return 0.0001;
	            }
	
	            return val;
	        }
	    };
	})();
	
	(function(Konva) {
	    'use strict';
	    // CONSTANTS
	    var ABSOLUTE_OPACITY = 'absoluteOpacity',
	        ABSOLUTE_TRANSFORM = 'absoluteTransform',
	        ABSOLUTE_SCALE = 'absoluteScale',
	        CHANGE = 'Change',
	        CHILDREN = 'children',
	        DOT = '.',
	        EMPTY_STRING = '',
	        GET = 'get',
	        ID = 'id',
	        KONVA = 'konva',
	        LISTENING = 'listening',
	        MOUSEENTER = 'mouseenter',
	        MOUSELEAVE = 'mouseleave',
	        NAME = 'name',
	        SET = 'set',
	        SHAPE = 'Shape',
	        SPACE = ' ',
	        STAGE = 'stage',
	        TRANSFORM = 'transform',
	        UPPER_STAGE = 'Stage',
	        VISIBLE = 'visible',
	        CLONE_BLACK_LIST = ['id'],
	
	        TRANSFORM_CHANGE_STR = [
	            'xChange.konva',
	            'yChange.konva',
	            'scaleXChange.konva',
	            'scaleYChange.konva',
	            'skewXChange.konva',
	            'skewYChange.konva',
	            'rotationChange.konva',
	            'offsetXChange.konva',
	            'offsetYChange.konva',
	            'transformsEnabledChange.konva'
	        ].join(SPACE),
	
	        SCALE_CHANGE_STR = [
	            'scaleXChange.konva',
	            'scaleYChange.konva'
	        ].join(SPACE);
	
	    /**
	     * Node constructor. Nodes are entities that can be transformed, layered,
	     * and have bound events. The stage, layers, groups, and shapes all extend Node.
	     * @constructor
	     * @memberof Konva
	     * @abstract
	     * @param {Object} config
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     */
	    Konva.Node = function(config) {
	        this._init(config);
	    };
	
	    Konva.Util.addMethods(Konva.Node, {
	        _init: function(config) {
	            var that = this;
	            this._id = Konva.idCounter++;
	            this.eventListeners = {};
	            this.attrs = {};
	            this._cache = {};
	            this._filterUpToDate = false;
	            this.setAttrs(config);
	
	            // event bindings for cache handling
	            this.on(TRANSFORM_CHANGE_STR, function() {
	                this._clearCache(TRANSFORM);
	                that._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	            });
	
	            this.on(SCALE_CHANGE_STR, function() {
	                that._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
	            });
	
	            this.on('visibleChange.konva', function() {
	                that._clearSelfAndDescendantCache(VISIBLE);
	            });
	            this.on('listeningChange.konva', function() {
	                that._clearSelfAndDescendantCache(LISTENING);
	            });
	            this.on('opacityChange.konva', function() {
	                that._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
	            });
	        },
	        _clearCache: function(attr){
	            if (attr) {
	                delete this._cache[attr];
	            }
	            else {
	                this._cache = {};
	            }
	        },
	        _getCache: function(attr, privateGetter){
	            var cache = this._cache[attr];
	
	            // if not cached, we need to set it using the private getter method.
	            if (cache === undefined) {
	                this._cache[attr] = privateGetter.call(this);
	            }
	
	            return this._cache[attr];
	        },
	        /*
	         * when the logic for a cached result depends on ancestor propagation, use this
	         * method to clear self and children cache
	         */
	        _clearSelfAndDescendantCache: function(attr) {
	            this._clearCache(attr);
	
	            if (this.children) {
	                this.getChildren().each(function(node) {
	                    node._clearSelfAndDescendantCache(attr);
	                });
	            }
	        },
	        /**
	        * clear cached canvas
	        * @method
	        * @memberof Konva.Node.prototype
	        * @returns {Konva.Node}
	        * @example
	        * node.clearCache();
	        */
	        clearCache: function() {
	            delete this._cache.canvas;
	            this._filterUpToDate = false;
	            return this;
	        },
	        /**
	        *  cache node to improve drawing performance, apply filters, or create more accurate
	        *  hit regions. For all basic shapes size of cache canvas will be automatically detected.
	        *  If you need to cache your custom `Konva.Shape` instance you have to pass shape's bounding box
	        *  properties. Look at [link to demo page](link to demo page) for more information.
	        * @method
	        * @memberof Konva.Node.prototype
	        * @param {Object} [config]
	        * @param {Number} [config.x]
	        * @param {Number} [config.y]
	        * @param {Number} [config.width]
	        * @param {Number} [config.height]
	        * @param {Number} [config.offset]  increase canvas size by `offset` pixel in all directions.
	        * @param {Boolean} [config.drawBorder] when set to true, a red border will be drawn around the cached
	        *  region for debugging purposes
	        * @returns {Konva.Node}
	        * @example
	        * // cache a shape with the x,y position of the bounding box at the center and
	        * // the width and height of the bounding box equal to the width and height of
	        * // the shape obtained from shape.width() and shape.height()
	        * image.cache();
	        *
	        * // cache a node and define the bounding box position and size
	        * node.cache({
	        *   x: -30,
	        *   y: -30,
	        *   width: 100,
	        *   height: 200
	        * });
	        *
	        * // cache a node and draw a red border around the bounding box
	        * // for debugging purposes
	        * node.cache({
	        *   x: -30,
	        *   y: -30,
	        *   width: 100,
	        *   height: 200,
	        *   offset : 10,
	        *   drawBorder: true
	        * });
	        */
	        cache: function(config) {
	            var conf = config || {},
	                rect = this.getClientRect(true),
	                width = conf.width || rect.width,
	                height = conf.height || rect.height,
	                x = conf.x || rect.x,
	                y = conf.y || rect.y,
	                offset = conf.offset || 0,
	                drawBorder = conf.drawBorder || false;
	
	            if (!width || !height) {
	                throw new Error('Width or height of caching configuration equals 0.');
	            }
	
	            width += offset * 2;
	            height += offset * 2;
	
	            x -= offset;
	            y -= offset;
	
	
	            var cachedSceneCanvas = new Konva.SceneCanvas({
	                width: width,
	                height: height
	            }),
	            cachedFilterCanvas = new Konva.SceneCanvas({
	                width: width,
	                height: height
	            }),
	            cachedHitCanvas = new Konva.HitCanvas({
	                pixelRatio: 1,
	                width: width,
	                height: height
	            }),
	            sceneContext = cachedSceneCanvas.getContext(),
	            hitContext = cachedHitCanvas.getContext();
	
	            cachedHitCanvas.isCache = true;
	
	            this.clearCache();
	
	            sceneContext.save();
	            hitContext.save();
	
	            sceneContext.translate(-x, -y);
	            hitContext.translate(-x, -y);
	
	            this.drawScene(cachedSceneCanvas, this, true);
	            this.drawHit(cachedHitCanvas, this, true);
	
	            sceneContext.restore();
	            hitContext.restore();
	
	            // this will draw a red border around the cached box for
	            // debugging purposes
	            if (drawBorder) {
	                sceneContext.save();
	                sceneContext.beginPath();
	                sceneContext.rect(0, 0, width, height);
	                sceneContext.closePath();
	                sceneContext.setAttr('strokeStyle', 'red');
	                sceneContext.setAttr('lineWidth', 5);
	                sceneContext.stroke();
	                sceneContext.restore();
	            }
	
	            this._cache.canvas = {
	                scene: cachedSceneCanvas,
	                filter: cachedFilterCanvas,
	                hit: cachedHitCanvas,
	                x: x,
	                y: y
	            };
	
	            return this;
	        },
	        /**
	         * Return client rectangle {x, y, width, height} of node. This rectangle also include all styling (strokes, shadows, etc).
	         * The rectangle position is relative to parent container.
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {Boolean} [skipTransform] flag should we skip transformation to rectangle
	         * @returns {Object} rect with {x, y, width, height} properties
	         * @example
	         * var rect = new Konva.Rect({
	         *      width : 100,
	         *      height : 100,
	         *      x : 50,
	         *      y : 50,
	         *      strokeWidth : 4,
	         *      stroke : 'black',
	         *      offsetX : 50,
	         *      scaleY : 2
	         * });
	         *
	         * // get client rect without think off transformations (position, rotation, scale, offset, etc)
	         * rect.getClientRect(true);
	         * // returns {
	         * //     x : -2,   // two pixels for stroke / 2
	         * //     y : -2,
	         * //     width : 104, // increased by 4 for stroke
	         * //     height : 104
	         * //}
	         *
	         * // get client rect with transformation applied
	         * rect.getClientRect();
	         * // returns Object {x: -2, y: 46, width: 104, height: 208}
	         */
	        getClientRect: function() {
	            // abstract method
	            // redefine in Container and Shape
	            throw new Error('abstract "getClientRect" method call');
	        },
	        _transformedRect: function(rect) {
	            var points = [
	                {x: rect.x, y: rect.y},
	                {x: rect.x + rect.width, y: rect.y},
	                {x: rect.x + rect.width, y: rect.y + rect.height},
	                {x: rect.x, y: rect.y + rect.height}
	            ];
	            var minX, minY, maxX, maxY;
	            var trans = this.getTransform();
	            points.forEach(function(point) {
	                var transformed = trans.point(point);
	                if (minX === undefined) {
	                    minX = maxX = transformed.x;
	                    minY = maxY = transformed.y;
	                }
	                minX = Math.min(minX, transformed.x);
	                minY = Math.min(minY, transformed.y);
	                maxX = Math.max(maxX, transformed.x);
	                maxY = Math.max(maxY, transformed.y);
	            });
	            return {
	                x: minX,
	                y: minY,
	                width: maxX - minX,
	                height: maxY - minY
	            };
	        },
	        _drawCachedSceneCanvas: function(context) {
	            context.save();
	            context._applyOpacity(this);
	            context.translate(
	                this._cache.canvas.x,
	                this._cache.canvas.y
	            );
	
	            var cacheCanvas = this._getCachedSceneCanvas();
	            var ratio = cacheCanvas.pixelRatio;
	
	            context.drawImage(cacheCanvas._canvas, 0, 0, cacheCanvas.width / ratio, cacheCanvas.height / ratio);
	            context.restore();
	        },
	        _drawCachedHitCanvas: function(context) {
	            var cachedCanvas = this._cache.canvas,
	                hitCanvas = cachedCanvas.hit;
	            context.save();
	            context.translate(
	                this._cache.canvas.x,
	                this._cache.canvas.y
	            );
	            context.drawImage(hitCanvas._canvas, 0, 0);
	            context.restore();
	        },
	        _getCachedSceneCanvas: function() {
	            var filters = this.filters(),
	                cachedCanvas = this._cache.canvas,
	                sceneCanvas = cachedCanvas.scene,
	                filterCanvas = cachedCanvas.filter,
	                filterContext = filterCanvas.getContext(),
	                len, imageData, n, filter;
	
	            if (filters) {
	                if (!this._filterUpToDate) {
	                    var ratio = sceneCanvas.pixelRatio;
	
	                    try {
	                        len = filters.length;
	                        filterContext.clear();
	
	                        // copy cached canvas onto filter context
	                        filterContext.drawImage(sceneCanvas._canvas, 0, 0, sceneCanvas.getWidth() / ratio, sceneCanvas.getHeight() / ratio);
	                        imageData = filterContext.getImageData(0, 0, filterCanvas.getWidth(), filterCanvas.getHeight());
	
	                        // apply filters to filter context
	                        for (n = 0; n < len; n++) {
	                            filter = filters[n];
	                            if (typeof filter !== 'function') {
	                                Konva.Util.error(
	                                  'Filter should be type of function, but got ' +
	                                  (typeof filter) + ' insted. Please check correct filters'
	                                );
	                                continue;
	                            }
	                            filter.call(this, imageData);
	                            filterContext.putImageData(imageData, 0, 0);
	                        }
	                    }
	                    catch(e) {
	                        Konva.Util.error('Unable to apply filter. ' + e.message);
	                    }
	
	                    this._filterUpToDate = true;
	                }
	
	                return filterCanvas;
	            }
	            return sceneCanvas;
	        },
	        /**
	         * bind events to the node. KonvaJS supports mouseover, mousemove,
	         *  mouseout, mouseenter, mouseleave, mousedown, mouseup, wheel, click, dblclick, touchstart, touchmove,
	         *  touchend, tap, dbltap, dragstart, dragmove, and dragend events. The Konva Stage supports
	         *  contentMouseover, contentMousemove, contentMouseout, contentMousedown, contentMouseup, contentWheel
	         *  contentClick, contentDblclick, contentTouchstart, contentTouchmove, contentTouchend, contentTap,
	         *  and contentDblTap.  Pass in a string of events delimmited by a space to bind multiple events at once
	         *  such as 'mousedown mouseup mousemove'. Include a namespace to bind an
	         *  event by name such as 'click.foobar'.
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo touchstart.foo'
	         * @param {Function} handler The handler function is passed an event object
	         * @returns {Konva.Node}
	         * @example
	         * // add click listener
	         * node.on('click', function() {
	         *   console.log('you clicked me!');
	         * });
	         *
	         * // get the target node
	         * node.on('click', function(evt) {
	         *   console.log(evt.target);
	         * });
	         *
	         * // stop event propagation
	         * node.on('click', function(evt) {
	         *   evt.cancelBubble = true;
	         * });
	         *
	         * // bind multiple listeners
	         * node.on('click touchstart', function() {
	         *   console.log('you clicked/touched me!');
	         * });
	         *
	         * // namespace listener
	         * node.on('click.foo', function() {
	         *   console.log('you clicked/touched me!');
	         * });
	         *
	         * // get the event type
	         * node.on('click tap', function(evt) {
	         *   var eventType = evt.type;
	         * });
	         *
	         * // get native event object
	         * node.on('click tap', function(evt) {
	         *   var nativeEvent = evt.evt;
	         * });
	         *
	         * // for change events, get the old and new val
	         * node.on('xChange', function(evt) {
	         *   var oldVal = evt.oldVal;
	         *   var newVal = evt.newVal;
	         * });
	         *
	         * // get event targets
	         * // with event delegations
	         * layer.on('click', 'Group', function(evt) {
	         *   var shape = evt.target;
	         *   var group = evtn.currentTarger;
	         * });
	         */
	        on: function(evtStr, handler) {
	            if (arguments.length === 3) {
	                return this._delegate.apply(this, arguments);
	            }
	            var events = evtStr.split(SPACE),
	                len = events.length,
	                n, event, parts, baseEvent, name;
	
	             /*
	             * loop through types and attach event listeners to
	             * each one.  eg. 'click mouseover.namespace mouseout'
	             * will create three event bindings
	             */
	            for(n = 0; n < len; n++) {
	                event = events[n];
	                parts = event.split(DOT);
	                baseEvent = parts[0];
	                name = parts[1] || EMPTY_STRING;
	
	                // create events array if it doesn't exist
	                if(!this.eventListeners[baseEvent]) {
	                    this.eventListeners[baseEvent] = [];
	                }
	
	                this.eventListeners[baseEvent].push({
	                    name: name,
	                    handler: handler
	                });
	            }
	
	            return this;
	        },
	        /**
	         * remove event bindings from the node. Pass in a string of
	         *  event types delimmited by a space to remove multiple event
	         *  bindings at once such as 'mousedown mouseup mousemove'.
	         *  include a namespace to remove an event binding by name
	         *  such as 'click.foobar'. If you only give a name like '.foobar',
	         *  all events in that namespace will be removed.
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {String} evtStr e.g. 'click', 'mousedown touchstart', '.foobar'
	         * @returns {Konva.Node}
	         * @example
	         * // remove listener
	         * node.off('click');
	         *
	         * // remove multiple listeners
	         * node.off('click touchstart');
	         *
	         * // remove listener by name
	         * node.off('click.foo');
	         */
	        off: function(evtStr) {
	            var events = (evtStr || '').split(SPACE),
	                len = events.length,
	                n, t, event, parts, baseEvent, name;
	
	            if (!evtStr) {
	                // remove all events
	                for(t in this.eventListeners) {
	                    this._off(t);
	                }
	            }
	            for(n = 0; n < len; n++) {
	                event = events[n];
	                parts = event.split(DOT);
	                baseEvent = parts[0];
	                name = parts[1];
	
	                if(baseEvent) {
	                    if(this.eventListeners[baseEvent]) {
	                        this._off(baseEvent, name);
	                    }
	                }
	                else {
	                    for(t in this.eventListeners) {
	                        this._off(t, name);
	                    }
	                }
	            }
	            return this;
	        },
	        // some event aliases for third party integration like HammerJS
	        dispatchEvent: function(evt) {
	            var e = {
	              target: this,
	              type: evt.type,
	              evt: evt
	            };
	            this.fire(evt.type, e);
	            return this;
	        },
	        addEventListener: function(type, handler) {
	            // we have to pass native event to handler
	            this.on(type, function(evt){
	                handler.call(this, evt.evt);
	            });
	            return this;
	        },
	        removeEventListener: function(type) {
	            this.off(type);
	            return this;
	        },
	        // like node.on
	        _delegate: function(event, selector, handler) {
	            var stopNode = this;
	            this.on(event, function(evt) {
	                var targets = evt.target.findAncestors(selector, true, stopNode);
	                for(var i = 0; i < targets.length; i++) {
	                    evt = Konva.Util.cloneObject(evt);
	                    evt.currentTarget = targets[i];
	                    handler.call(targets[i], evt);
	                }
	            });
	        },
	        /**
	         * remove self from parent, but don't destroy
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Konva.Node}
	         * @example
	         * node.remove();
	         */
	        remove: function() {
	            var parent = this.getParent();
	
	            if(parent && parent.children) {
	                parent.children.splice(this.index, 1);
	                parent._setChildrenIndices();
	                delete this.parent;
	            }
	
	            // every cached attr that is calculated via node tree
	            // traversal must be cleared when removing a node
	            this._clearSelfAndDescendantCache(STAGE);
	            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	            this._clearSelfAndDescendantCache(VISIBLE);
	            this._clearSelfAndDescendantCache(LISTENING);
	            this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
	
	            return this;
	        },
	        /**
	         * remove and destroy self
	         * @method
	         * @memberof Konva.Node.prototype
	         * @example
	         * node.destroy();
	         */
	        destroy: function() {
	            // remove from ids and names hashes
	            Konva._removeId(this.getId());
	            Konva._removeName(this.getName(), this._id);
	
	            this.remove();
	            return this;
	        },
	        /**
	         * get attr
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {String} attr
	         * @returns {Integer|String|Object|Array}
	         * @example
	         * var x = node.getAttr('x');
	         */
	        getAttr: function(attr) {
	            var method = GET + Konva.Util._capitalize(attr);
	            if(Konva.Util._isFunction(this[method])) {
	                return this[method]();
	            }
	            // otherwise get directly
	            return this.attrs[attr];
	        },
	        /**
	        * get ancestors
	        * @method
	        * @memberof Konva.Node.prototype
	        * @returns {Konva.Collection}
	        * @example
	        * shape.getAncestors().each(function(node) {
	        *   console.log(node.getId());
	        * })
	        */
	        getAncestors: function() {
	            var parent = this.getParent(),
	                ancestors = new Konva.Collection();
	
	            while (parent) {
	                ancestors.push(parent);
	                parent = parent.getParent();
	            }
	
	            return ancestors;
	        },
	        /**
	         * get attrs object literal
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Object}
	         */
	        getAttrs: function() {
	            return this.attrs || {};
	        },
	        /**
	         * set multiple attrs at once using an object literal
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {Object} config object containing key value pairs
	         * @returns {Konva.Node}
	         * @example
	         * node.setAttrs({
	         *   x: 5,
	         *   fill: 'red'
	         * });
	         */
	        setAttrs: function(config) {
	            var key, method;
	
	            if(!config) {
	                return this;
	            }
	            for(key in config) {
	                if (key === CHILDREN) {
	                    continue;
	                }
	                method = SET + Konva.Util._capitalize(key);
	                // use setter if available
	                if(Konva.Util._isFunction(this[method])) {
	                    this[method](config[key]);
	                }
	                // otherwise set directly
	                else {
	                    this._setAttr(key, config[key]);
	                }
	            }
	            return this;
	        },
	        /**
	         * determine if node is listening for events by taking into account ancestors.
	         *
	         * Parent    | Self      | isListening
	         * listening | listening |
	         * ----------+-----------+------------
	         * T         | T         | T
	         * T         | F         | F
	         * F         | T         | T
	         * F         | F         | F
	         * ----------+-----------+------------
	         * T         | I         | T
	         * F         | I         | F
	         * I         | I         | T
	         *
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Boolean}
	         */
	        isListening: function() {
	            return this._getCache(LISTENING, this._isListening);
	        },
	        _isListening: function() {
	            var listening = this.getListening(),
	                parent = this.getParent();
	
	            // the following conditions are a simplification of the truth table above.
	            // please modify carefully
	            if (listening === 'inherit') {
	                if (parent) {
	                    return parent.isListening();
	                }
	                else {
	                    return true;
	                }
	            }
	            else {
	                return listening;
	            }
	        },
	        /**
	         * determine if node is visible by taking into account ancestors.
	         *
	         * Parent    | Self      | isVisible
	         * visible   | visible   |
	         * ----------+-----------+------------
	         * T         | T         | T
	         * T         | F         | F
	         * F         | T         | T
	         * F         | F         | F
	         * ----------+-----------+------------
	         * T         | I         | T
	         * F         | I         | F
	         * I         | I         | T
	
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Boolean}
	         */
	        isVisible: function() {
	            return this._getCache(VISIBLE, this._isVisible);
	        },
	        _isVisible: function() {
	            var visible = this.getVisible(),
	                parent = this.getParent();
	
	            // the following conditions are a simplification of the truth table above.
	            // please modify carefully
	            if (visible === 'inherit') {
	                if (parent) {
	                    return parent.isVisible();
	                }
	                else {
	                    return true;
	                }
	            }
	            else {
	                return visible;
	            }
	        },
	        /**
	         * determine if listening is enabled by taking into account descendants.  If self or any children
	         * have _isListeningEnabled set to true, then self also has listening enabled.
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Boolean}
	         */
	        shouldDrawHit: function(canvas) {
	            var layer = this.getLayer();
	            return (canvas && canvas.isCache) || (layer && layer.hitGraphEnabled())
	                && this.isListening() && this.isVisible();
	        },
	        /**
	         * show node
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Konva.Node}
	         */
	        show: function() {
	            this.setVisible(true);
	            return this;
	        },
	        /**
	         * hide node.  Hidden nodes are no longer detectable
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Konva.Node}
	         */
	        hide: function() {
	            this.setVisible(false);
	            return this;
	        },
	        /**
	         * get zIndex relative to the node's siblings who share the same parent
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Integer}
	         */
	        getZIndex: function() {
	            return this.index || 0;
	        },
	        /**
	         * get absolute z-index which takes into account sibling
	         *  and ancestor indices
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Integer}
	         */
	        getAbsoluteZIndex: function() {
	            var depth = this.getDepth(),
	                that = this,
	                index = 0,
	                nodes, len, n, child;
	
	            function addChildren(children) {
	                nodes = [];
	                len = children.length;
	                for(n = 0; n < len; n++) {
	                    child = children[n];
	                    index++;
	
	                    if(child.nodeType !== SHAPE) {
	                        nodes = nodes.concat(child.getChildren().toArray());
	                    }
	
	                    if(child._id === that._id) {
	                        n = len;
	                    }
	                }
	
	                if(nodes.length > 0 && nodes[0].getDepth() <= depth) {
	                    addChildren(nodes);
	                }
	            }
	            if(that.nodeType !== UPPER_STAGE) {
	                addChildren(that.getStage().getChildren());
	            }
	
	            return index;
	        },
	        /**
	         * get node depth in node tree.  Returns an integer.
	         *  e.g. Stage depth will always be 0.  Layers will always be 1.  Groups and Shapes will always
	         *  be >= 2
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Integer}
	         */
	        getDepth: function() {
	            var depth = 0,
	                parent = this.parent;
	
	            while(parent) {
	                depth++;
	                parent = parent.parent;
	            }
	            return depth;
	        },
	        setPosition: function(pos) {
	            this.setX(pos.x);
	            this.setY(pos.y);
	            return this;
	        },
	        getPosition: function() {
	            return {
	                x: this.getX(),
	                y: this.getY()
	            };
	        },
	        /**
	         * get absolute position relative to the top left corner of the stage container div
	         * or relative to passed node
	         * @method
	         * @param {Object} [top] optional parent node
	         * @memberof Konva.Node.prototype
	         * @returns {Object}
	         */
	        getAbsolutePosition: function(top) {
	            var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(),
	                absoluteTransform = new Konva.Transform(),
	                offset = this.offset();
	
	            // clone the matrix array
	            absoluteTransform.m = absoluteMatrix.slice();
	            absoluteTransform.translate(offset.x, offset.y);
	
	            return absoluteTransform.getTranslation();
	        },
	        /**
	         * set absolute position
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {Object} pos
	         * @param {Number} pos.x
	         * @param {Number} pos.y
	         * @returns {Konva.Node}
	         */
	        setAbsolutePosition: function(pos) {
	            var origTrans = this._clearTransform(),
	                it;
	
	            // don't clear translation
	            this.attrs.x = origTrans.x;
	            this.attrs.y = origTrans.y;
	            delete origTrans.x;
	            delete origTrans.y;
	
	            // unravel transform
	            it = this.getAbsoluteTransform();
	
	            it.invert();
	            it.translate(pos.x, pos.y);
	            pos = {
	                x: this.attrs.x + it.getTranslation().x,
	                y: this.attrs.y + it.getTranslation().y
	            };
	
	            this.setPosition({x: pos.x, y: pos.y});
	            this._setTransform(origTrans);
	
	            return this;
	        },
	        _setTransform: function(trans) {
	            var key;
	
	            for(key in trans) {
	                this.attrs[key] = trans[key];
	            }
	
	            this._clearCache(TRANSFORM);
	            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	        },
	        _clearTransform: function() {
	            var trans = {
	                x: this.getX(),
	                y: this.getY(),
	                rotation: this.getRotation(),
	                scaleX: this.getScaleX(),
	                scaleY: this.getScaleY(),
	                offsetX: this.getOffsetX(),
	                offsetY: this.getOffsetY(),
	                skewX: this.getSkewX(),
	                skewY: this.getSkewY()
	            };
	
	            this.attrs.x = 0;
	            this.attrs.y = 0;
	            this.attrs.rotation = 0;
	            this.attrs.scaleX = 1;
	            this.attrs.scaleY = 1;
	            this.attrs.offsetX = 0;
	            this.attrs.offsetY = 0;
	            this.attrs.skewX = 0;
	            this.attrs.skewY = 0;
	
	            this._clearCache(TRANSFORM);
	            this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
	
	            // return original transform
	            return trans;
	        },
	        /**
	         * move node by an amount relative to its current position
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {Object} change
	         * @param {Number} change.x
	         * @param {Number} change.y
	         * @returns {Konva.Node}
	         * @example
	         * // move node in x direction by 1px and y direction by 2px
	         * node.move({
	         *   x: 1,
	         *   y: 2)
	         * });
	         */
	        move: function(change) {
	            var changeX = change.x,
	                changeY = change.y,
	                x = this.getX(),
	                y = this.getY();
	
	            if(changeX !== undefined) {
	                x += changeX;
	            }
	
	            if(changeY !== undefined) {
	                y += changeY;
	            }
	
	            this.setPosition({x: x, y: y});
	            return this;
	        },
	        _eachAncestorReverse: function(func, top) {
	            var family = [],
	                parent = this.getParent(),
	                len, n;
	
	            // if top node is defined, and this node is top node,
	            // there's no need to build a family tree.  just execute
	            // func with this because it will be the only node
	            if (top && top._id === this._id) {
	                func(this);
	                return true;
	            }
	
	            family.unshift(this);
	
	            while(parent && (!top || parent._id !== top._id)) {
	                family.unshift(parent);
	                parent = parent.parent;
	            }
	
	            len = family.length;
	            for(n = 0; n < len; n++) {
	                func(family[n]);
	            }
	        },
	        /**
	         * rotate node by an amount in degrees relative to its current rotation
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {Number} theta
	         * @returns {Konva.Node}
	         */
	        rotate: function(theta) {
	            this.setRotation(this.getRotation() + theta);
	            return this;
	        },
	        /**
	         * move node to the top of its siblings
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Boolean}
	         */
	        moveToTop: function() {
	            if (!this.parent) {
	                Konva.Util.warn('Node has no parent. moveToTop function is ignored.');
	                return false;
	            }
	            var index = this.index;
	            this.parent.children.splice(index, 1);
	            this.parent.children.push(this);
	            this.parent._setChildrenIndices();
	            return true;
	        },
	        /**
	         * move node up
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Boolean} flag is moved or not
	         */
	        moveUp: function() {
	            if (!this.parent) {
	                Konva.Util.warn('Node has no parent. moveUp function is ignored.');
	                return false;
	            }
	            var index = this.index,
	                len = this.parent.getChildren().length;
	            if(index < len - 1) {
	                this.parent.children.splice(index, 1);
	                this.parent.children.splice(index + 1, 0, this);
	                this.parent._setChildrenIndices();
	                return true;
	            }
	            return false;
	        },
	        /**
	         * move node down
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Boolean}
	         */
	        moveDown: function() {
	            if (!this.parent) {
	                Konva.Util.warn('Node has no parent. moveDown function is ignored.');
	                return false;
	            }
	            var index = this.index;
	            if(index > 0) {
	                this.parent.children.splice(index, 1);
	                this.parent.children.splice(index - 1, 0, this);
	                this.parent._setChildrenIndices();
	                return true;
	            }
	            return false;
	        },
	        /**
	         * move node to the bottom of its siblings
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Boolean}
	         */
	        moveToBottom: function() {
	            if (!this.parent) {
	                Konva.Util.warn('Node has no parent. moveToBottom function is ignored.');
	                return false;
	            }
	            var index = this.index;
	            if(index > 0) {
	                this.parent.children.splice(index, 1);
	                this.parent.children.unshift(this);
	                this.parent._setChildrenIndices();
	                return true;
	            }
	            return false;
	        },
	        /**
	         * set zIndex relative to siblings
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {Integer} zIndex
	         * @returns {Konva.Node}
	         */
	        setZIndex: function(zIndex) {
	            if (!this.parent) {
	                Konva.Util.warn('Node has no parent. zIndex parameter is ignored.');
	                return false;
	            }
	            var index = this.index;
	            this.parent.children.splice(index, 1);
	            this.parent.children.splice(zIndex, 0, this);
	            this.parent._setChildrenIndices();
	            return this;
	        },
	        /**
	         * get absolute opacity
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Number}
	         */
	        getAbsoluteOpacity: function() {
	            return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
	        },
	        _getAbsoluteOpacity: function() {
	            var absOpacity = this.getOpacity();
	            if(this.getParent()) {
	                absOpacity *= this.getParent().getAbsoluteOpacity();
	            }
	            return absOpacity;
	        },
	        /**
	         * move node to another container
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {Container} newContainer
	         * @returns {Konva.Node}
	         * @example
	         * // move node from current layer into layer2
	         * node.moveTo(layer2);
	         */
	        moveTo: function(newContainer) {
	            // do nothing if new container is already parent
	            if (this.getParent() !== newContainer) {
	                this.remove();
	                newContainer.add(this);
	            }
	            return this;
	        },
	        /**
	         * convert Node into an object for serialization.  Returns an object.
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Object}
	         */
	        toObject: function() {
	            var obj = {},
	                attrs = this.getAttrs(),
	                key, val, getter, defaultValue;
	
	            obj.attrs = {};
	
	            for(key in attrs) {
	                val = attrs[key];
	                getter = this[key];
	                // remove attr value so that we can extract the default value from the getter
	                delete attrs[key];
	                defaultValue = getter ? getter.call(this) : null;
	                // restore attr value
	                attrs[key] = val;
	                if (defaultValue !== val) {
	                    obj.attrs[key] = val;
	                }
	            }
	
	            obj.className = this.getClassName();
	            return Konva.Util._prepareToStringify(obj);
	        },
	        /**
	         * convert Node into a JSON string.  Returns a JSON string.
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {String}}
	         */
	        toJSON: function() {
	            return JSON.stringify(this.toObject());
	        },
	        /**
	         * get parent container
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Konva.Node}
	         */
	        getParent: function() {
	            return this.parent;
	        },
	        /**
	         * get all ancestros (parent then parent of the parent, etc) of the node
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {String} [selector] selector for search
	         * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
	         * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
	         * @returns {Array} [ancestors]
	         * @example
	         * // get one of the parent group
	         * var parentGroups = node.findAncestors('Group');
	         */
	        findAncestors: function(selector, includeSelf, stopNode) {
	            var res = [];
	
	            if (includeSelf && this._isMatch(selector)) {
	                res.push(this);
	            }
	            var ancestor = this.parent;
	            while(ancestor) {
	                if (ancestor === stopNode) {
	                    return res;
	                }
	                if (ancestor._isMatch(selector)) {
	                    res.push(ancestor);
	                }
	                ancestor = ancestor.parent;
	            }
	            return res;
	        },
	        /**
	         * get ancestor (parent or parent of the parent, etc) of the node that match passed selector
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {String} [selector] selector for search
	         * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
	         * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
	         * @returns {Konva.Node} ancestor
	         * @example
	         * // get one of the parent group
	         * var group = node.findAncestors('.mygroup');
	         */
	        findAncestor: function(selector, includeSelf, stopNode) {
	            return this.findAncestors(selector, includeSelf, stopNode)[0];
	        },
	        // is current node match passed selector?
	        _isMatch: function(selector) {
	            if (!selector) {
	                return false;
	            }
	            var selectorArr = selector.replace(/ /g, '').split(','),
	                len = selectorArr.length,
	                n, sel;
	
	            for (n = 0; n < len; n++) {
	                sel = selectorArr[n];
	                if (!Konva.Util.isValidSelector(sel)) {
	                    Konva.Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
	                    Konva.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
	                    Konva.Util.warn('Konva is awesome, right?');
	                }
	                // id selector
	                if(sel.charAt(0) === '#') {
	                    if (this.id() === sel.slice(1)) {
	                        return true;
	                    }
	                }
	                // name selector
	                else if(sel.charAt(0) === '.') {
	                    if (this.hasName(sel.slice(1))) {
	                        return true;
	                    }
	                } else if (this._get(sel).length !== 0) {
	                    return true;
	                }
	            }
	            return false;
	        },
	        /**
	         * get layer ancestor
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Konva.Layer}
	         */
	        getLayer: function() {
	            var parent = this.getParent();
	            return parent ? parent.getLayer() : null;
	        },
	        /**
	         * get stage ancestor
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Konva.Stage}
	         */
	        getStage: function() {
	            return this._getCache(STAGE, this._getStage);
	        },
	        _getStage: function() {
	            var parent = this.getParent();
	            if(parent) {
	                return parent.getStage();
	            }
	            else {
	                return undefined;
	            }
	        },
	        /**
	         * fire event
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {String} eventType event type.  can be a regular event, like click, mouseover, or mouseout, or it can be a custom event, like myCustomEvent
	         * @param {Event} [evt] event object
	         * @param {Boolean} [bubble] setting the value to false, or leaving it undefined, will result in the event
	         *  not bubbling.  Setting the value to true will result in the event bubbling.
	         * @returns {Konva.Node}
	         * @example
	         * // manually fire click event
	         * node.fire('click');
	         *
	         * // fire custom event
	         * node.fire('foo');
	         *
	         * // fire custom event with custom event object
	         * node.fire('foo', {
	         *   bar: 10
	         * });
	         *
	         * // fire click event that bubbles
	         * node.fire('click', null, true);
	         */
	        fire: function(eventType, evt, bubble) {
	            evt = evt || {};
	            evt.target = evt.target || this;
	            // bubble
	            if (bubble) {
	                this._fireAndBubble(eventType, evt);
	            }
	            // no bubble
	            else {
	                this._fire(eventType, evt);
	            }
	            return this;
	        },
	        /**
	         * get absolute transform of the node which takes into
	         *  account its ancestor transforms
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Konva.Transform}
	         */
	        getAbsoluteTransform: function(top) {
	            // if using an argument, we can't cache the result.
	            if (top) {
	                return this._getAbsoluteTransform(top);
	            }
	            // if no argument, we can cache the result
	            else {
	                return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
	            }
	        },
	        _getAbsoluteTransform: function(top) {
	            var at = new Konva.Transform(),
	                transformsEnabled, trans;
	
	            // start with stage and traverse downwards to self
	            this._eachAncestorReverse(function(node) {
	                transformsEnabled = node.transformsEnabled();
	                trans = node.getTransform();
	
	                if (transformsEnabled === 'all') {
	                    at.multiply(trans);
	                }
	                else if (transformsEnabled === 'position') {
	                    at.translate(node.x(), node.y());
	                }
	            }, top);
	            return at;
	        },
	        /**
	         * get absolute scale of the node which takes into
	         *  account its ancestor scales
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Konva.Transform}
	         */
	        getAbsoluteScale: function(top) {
	            // if using an argument, we can't cache the result.
	            if (top) {
	                return this._getAbsoluteTransform(top);
	            }
	            // if no argument, we can cache the result
	            else {
	                return this._getCache(ABSOLUTE_SCALE, this._getAbsoluteScale);
	            }
	        },
	        _getAbsoluteScale: function(top) {
	            var scaleX = 1, scaleY = 1;
	
	            // start with stage and traverse downwards to self
	            this._eachAncestorReverse(function(node) {
	                scaleX *= node.scaleX();
	                scaleY *= node.scaleY();
	            }, top);
	            return {
	                x: scaleX,
	                y: scaleY
	            };
	        },
	        /**
	         * get transform of the node
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Konva.Transform}
	         */
	        getTransform: function() {
	            return this._getCache(TRANSFORM, this._getTransform);
	        },
	        _getTransform: function() {
	            var m = new Konva.Transform(),
	                x = this.getX(),
	                y = this.getY(),
	                rotation = Konva.getAngle(this.getRotation()),
	                scaleX = this.getScaleX(),
	                scaleY = this.getScaleY(),
	                skewX = this.getSkewX(),
	                skewY = this.getSkewY(),
	                offsetX = this.getOffsetX(),
	                offsetY = this.getOffsetY();
	
	            if(x !== 0 || y !== 0) {
	                m.translate(x, y);
	            }
	            if(rotation !== 0) {
	                m.rotate(rotation);
	            }
	            if(skewX !== 0 || skewY !== 0) {
	                m.skew(skewX, skewY);
	            }
	            if(scaleX !== 1 || scaleY !== 1) {
	                m.scale(scaleX, scaleY);
	            }
	            if(offsetX !== 0 || offsetY !== 0) {
	                m.translate(-1 * offsetX, -1 * offsetY);
	            }
	
	            return m;
	        },
	        /**
	         * clone node.  Returns a new Node instance with identical attributes.  You can also override
	         *  the node properties with an object literal, enabling you to use an existing node as a template
	         *  for another node
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {Object} obj override attrs
	         * @returns {Konva.Node}
	         * @example
	         * // simple clone
	         * var clone = node.clone();
	         *
	         * // clone a node and override the x position
	         * var clone = rect.clone({
	         *   x: 5
	         * });
	         */
	        clone: function(obj) {
	            // instantiate new node
	            var attrs = Konva.Util.cloneObject(this.attrs),
	                key, allListeners, len, n, listener;
	            // filter black attrs
	            for (var i in CLONE_BLACK_LIST) {
	                var blockAttr = CLONE_BLACK_LIST[i];
	                delete attrs[blockAttr];
	            }
	            // apply attr overrides
	            for (key in obj) {
	                attrs[key] = obj[key];
	            }
	
	            var node = new this.constructor(attrs);
	            // copy over listeners
	            for(key in this.eventListeners) {
	                allListeners = this.eventListeners[key];
	                len = allListeners.length;
	                for(n = 0; n < len; n++) {
	                    listener = allListeners[n];
	                    /*
	                     * don't include konva namespaced listeners because
	                     *  these are generated by the constructors
	                     */
	                    if(listener.name.indexOf(KONVA) < 0) {
	                        // if listeners array doesn't exist, then create it
	                        if(!node.eventListeners[key]) {
	                            node.eventListeners[key] = [];
	                        }
	                        node.eventListeners[key].push(listener);
	                    }
	                }
	            }
	            return node;
	        },
	        /**
	         * Creates a composite data URL. If MIME type is not
	         * specified, then "image/png" will result. For "image/jpeg", specify a quality
	         * level as quality (range 0.0 - 1.0)
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {Object} config
	         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
	         *  "image/png" is the default
	         * @param {Number} [config.x] x position of canvas section
	         * @param {Number} [config.y] y position of canvas section
	         * @param {Number} [config.width] width of canvas section
	         * @param {Number} [config.height] height of canvas section
	         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
	         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
	         *  is very high quality
	         * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image url. Default is 1
	         * @returns {String}
	         */
	        toDataURL: function(config) {
	            config = config || {};
	
	            var mimeType = config.mimeType || null,
	                quality = config.quality || null,
	                stage = this.getStage(),
	                x = config.x || 0,
	                y = config.y || 0,
	                pixelRatio = config.pixelRatio || 1,
	                canvas = new Konva.SceneCanvas({
	                    width: config.width || this.getWidth() || (stage ? stage.getWidth() : 0),
	                    height: config.height || this.getHeight() || (stage ? stage.getHeight() : 0),
	                    pixelRatio: pixelRatio
	                }),
	                context = canvas.getContext();
	
	            context.save();
	
	            if(x || y) {
	                context.translate(-1 * x, -1 * y);
	            }
	
	            this.drawScene(canvas);
	            context.restore();
	
	            return canvas.toDataURL(mimeType, quality);
	        },
	        /**
	         * converts node into an image.  Since the toImage
	         *  method is asynchronous, a callback is required.  toImage is most commonly used
	         *  to cache complex drawings as an image so that they don't have to constantly be redrawn
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {Object} config
	         * @param {Function} config.callback function executed when the composite has completed
	         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
	         *  "image/png" is the default
	         * @param {Number} [config.x] x position of canvas section
	         * @param {Number} [config.y] y position of canvas section
	         * @param {Number} [config.width] width of canvas section
	         * @param {Number} [config.height] height of canvas section
	         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
	         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
	         *  is very high quality
	         * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image.  Default is 1.
	         * @example
	         * var image = node.toImage({
	         *   callback: function(img) {
	         *     // do stuff with img
	         *   }
	         * });
	         */
	        toImage: function(config) {
	            if (!config || !config.callback) {
	                throw 'callback required for toImage method config argument';
	            }
	            Konva.Util._getImage(this.toDataURL(config), function(img) {
	                config.callback(img);
	            });
	        },
	        setSize: function(size) {
	            this.setWidth(size.width);
	            this.setHeight(size.height);
	            return this;
	        },
	        getSize: function() {
	            return {
	                width: this.getWidth(),
	                height: this.getHeight()
	            };
	        },
	        getWidth: function() {
	            return this.attrs.width || 0;
	        },
	        getHeight: function() {
	            return this.attrs.height || 0;
	        },
	        /**
	         * get class name, which may return Stage, Layer, Group, or shape class names like Rect, Circle, Text, etc.
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {String}
	         */
	        getClassName: function() {
	            return this.className || this.nodeType;
	        },
	        /**
	         * get the node type, which may return Stage, Layer, Group, or Node
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {String}
	         */
	        getType: function() {
	            return this.nodeType;
	        },
	        getDragDistance: function() {
	            // compare with undefined because we need to track 0 value
	            if (this.attrs.dragDistance !== undefined) {
	                return this.attrs.dragDistance;
	            } else if (this.parent) {
	                return this.parent.getDragDistance();
	            } else {
	                return Konva.dragDistance;
	            }
	        },
	        _get: function(selector) {
	            return this.className === selector || this.nodeType === selector ? [this] : [];
	        },
	        _off: function(type, name) {
	            var evtListeners = this.eventListeners[type],
	                i, evtName;
	
	            for(i = 0; i < evtListeners.length; i++) {
	                evtName = evtListeners[i].name;
	                // the following two conditions must be true in order to remove a handler:
	                // 1) the current event name cannot be konva unless the event name is konva
	                //    this enables developers to force remove a konva specific listener for whatever reason
	                // 2) an event name is not specified, or if one is specified, it matches the current event name
	                if((evtName !== 'konva' || name === 'konva') && (!name || evtName === name)) {
	                    evtListeners.splice(i, 1);
	                    if(evtListeners.length === 0) {
	                        delete this.eventListeners[type];
	                        break;
	                    }
	                    i--;
	                }
	            }
	        },
	        _fireChangeEvent: function(attr, oldVal, newVal) {
	            this._fire(attr + CHANGE, {
	                oldVal: oldVal,
	                newVal: newVal
	            });
	        },
	        setId: function(id) {
	            var oldId = this.getId();
	
	            Konva._removeId(oldId);
	            Konva._addId(this, id);
	            this._setAttr(ID, id);
	            return this;
	        },
	        setName: function(name) {
	            var oldNames = (this.getName() || '').split(/\s/g);
	            var newNames = (name || '').split(/\s/g);
	            var subname, i;
	            // remove all subnames
	            for(i = 0; i < oldNames.length; i++) {
	                subname = oldNames[i];
	                if ((newNames.indexOf(subname)) === -1 && subname) {
	                    Konva._removeName(subname, this._id);
	                }
	            }
	
	            // add new names
	            for(i = 0; i < newNames.length; i++) {
	                subname = newNames[i];
	                if ((oldNames.indexOf(subname) === -1) && subname) {
	                    Konva._addName(this, subname);
	                }
	            }
	
	            this._setAttr(NAME, name);
	            return this;
	        },
	        // naming methods
	        /**
	         * add name to node
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {String} name
	         * @returns {Konva.Node}
	         * @example
	         * node.name('red');
	         * node.addName('selected');
	         * node.name(); // return 'red selected'
	         */
	        addName: function(name) {
	            if (!this.hasName(name)) {
	                var oldName = this.name();
	                var newName = oldName ? (oldName + ' ' + name) : name;
	                this.setName(newName);
	            }
	            return this;
	        },
	        /**
	         * check is node has name
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {String} name
	         * @returns {Boolean}
	         * @example
	         * node.name('red');
	         * node.hasName('red');   // return true
	         * node.hasName('selected'); // return false
	         */
	        hasName: function(name) {
	            var names = (this.name() || '').split(/\s/g);
	            return names.indexOf(name) !== -1;
	        },
	        /**
	         * remove name from node
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {String} name
	         * @returns {Konva.Node}
	         * @example
	         * node.name('red selected');
	         * node.removeName('selected');
	         * node.hasName('selected'); // return false
	         * node.name(); // return 'red'
	         */
	        removeName: function(name) {
	            var names = (this.name() || '').split(/\s/g);
	            var index = names.indexOf(name);
	            if (index !== -1) {
	                names.splice(index, 1);
	                this.setName(names.join(' '));
	            }
	            return this;
	        },
	        /**
	         * set attr
	         * @method
	         * @memberof Konva.Node.prototype
	         * @param {String} attr
	         * @param {*} val
	         * @returns {Konva.Node}
	         * @example
	         * node.setAttr('x', 5);
	         */
	        setAttr: function(attr, val) {
	            var method = SET + Konva.Util._capitalize(attr),
	                func = this[method];
	
	            if(Konva.Util._isFunction(func)) {
	                func.call(this, val);
	            }
	            // otherwise set directly
	            else {
	                this._setAttr(attr, val);
	            }
	            return this;
	        },
	        _setAttr: function(key, val) {
	            var oldVal;
	            oldVal = this.attrs[key];
	            if (oldVal === val) {
	                return;
	            }
	            if (val === undefined || val === null) {
	              delete this.attrs[key];
	            } else {
	              this.attrs[key] = val;
	            }
	            this._fireChangeEvent(key, oldVal, val);
	        },
	        _setComponentAttr: function(key, component, val) {
	            var oldVal;
	            if(val !== undefined) {
	                oldVal = this.attrs[key];
	
	                if (!oldVal) {
	                    // set value to default value using getAttr
	                    this.attrs[key] = this.getAttr(key);
	                }
	
	                this.attrs[key][component] = val;
	                this._fireChangeEvent(key, oldVal, val);
	            }
	        },
	        _fireAndBubble: function(eventType, evt, compareShape) {
	            var okayToRun = true;
	
	            if(evt && this.nodeType === SHAPE) {
	                evt.target = this;
	            }
	
	            if(eventType === MOUSEENTER && compareShape && (this._id === compareShape._id || (this.isAncestorOf && this.isAncestorOf(compareShape)))) {
	                okayToRun = false;
	            }
	            else if(eventType === MOUSELEAVE && compareShape && (this._id === compareShape._id || (this.isAncestorOf && this.isAncestorOf(compareShape)))) {
	                okayToRun = false;
	            }
	            if(okayToRun) {
	                this._fire(eventType, evt);
	
	                // simulate event bubbling
	                var stopBubble =
	                    (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&
	                    ((compareShape && compareShape.isAncestorOf && compareShape.isAncestorOf(this) && !compareShape.isAncestorOf(this.parent)));
	                if((evt && !evt.cancelBubble || !evt) && this.parent && this.parent.isListening() && (!stopBubble)) {
	                    if (compareShape && compareShape.parent) {
	                        this._fireAndBubble.call(this.parent, eventType, evt, compareShape.parent);
	                    }
	                    else {
	                        this._fireAndBubble.call(this.parent, eventType, evt);
	                    }
	                }
	            }
	        },
	        _fire: function(eventType, evt) {
	            var events = this.eventListeners[eventType],
	                i;
	
	            evt = evt || {};
	            evt.currentTarget = this;
	            evt.type = eventType;
	
	            if (events) {
	                for(i = 0; i < events.length; i++) {
	                    events[i].handler.call(this, evt);
	                }
	            }
	        },
	        /**
	         * draw both scene and hit graphs.  If the node being drawn is the stage, all of the layers will be cleared and redrawn
	         * @method
	         * @memberof Konva.Node.prototype
	         * @returns {Konva.Node}
	         */
	        draw: function() {
	            this.drawScene();
	            this.drawHit();
	            return this;
	        }
	    });
	
	    /**
	     * create node with JSON string or an Object.  De-serializtion does not generate custom
	     *  shape drawing functions, images, or event handlers (this would make the
	     *  serialized object huge).  If your app uses custom shapes, images, and
	     *  event handlers (it probably does), then you need to select the appropriate
	     *  shapes after loading the stage and set these properties via on(), setDrawFunc(),
	     *  and setImage() methods
	     * @method
	     * @memberof Konva.Node
	     * @param {String|Object} json string or object
	     * @param {Element} [container] optional container dom element used only if you're
	     *  creating a stage node
	     */
	    Konva.Node.create = function(data, container) {
	        if (Konva.Util._isString(data)) {
	            data = JSON.parse(data);
	        }
	        return this._createNode(data, container);
	    };
	    Konva.Node._createNode = function(obj, container) {
	        var className = Konva.Node.prototype.getClassName.call(obj),
	            children = obj.children,
	            no, len, n;
	
	        // if container was passed in, add it to attrs
	        if(container) {
	            obj.attrs.container = container;
	        }
	
	        no = new Konva[className](obj.attrs);
	        if(children) {
	            len = children.length;
	            for(n = 0; n < len; n++) {
	                no.add(this._createNode(children[n]));
	            }
	        }
	
	        return no;
	    };
	
	
	    // =========================== add getters setters ===========================
	
	    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'position');
	    /**
	     * get/set node position relative to parent
	     * @name position
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Object} pos
	     * @param {Number} pos.x
	     * @param {Number} pos.y
	     * @returns {Object}
	     * @example
	     * // get position
	     * var position = node.position();
	     *
	     * // set position
	     * node.position({
	     *   x: 5
	     *   y: 10
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'x', 0);
	
	    /**
	     * get/set x position
	     * @name x
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Number} x
	     * @returns {Object}
	     * @example
	     * // get x
	     * var x = node.x();
	     *
	     * // set x
	     * node.x(5);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'y', 0);
	
	    /**
	     * get/set y position
	     * @name y
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Number} y
	     * @returns {Integer}
	     * @example
	     * // get y
	     * var y = node.y();
	     *
	     * // set y
	     * node.y(5);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'opacity', 1);
	
	    /**
	     * get/set opacity.  Opacity values range from 0 to 1.
	     *  A node with an opacity of 0 is fully transparent, and a node
	     *  with an opacity of 1 is fully opaque
	     * @name opacity
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Object} opacity
	     * @returns {Number}
	     * @example
	     * // get opacity
	     * var opacity = node.opacity();
	     *
	     * // set opacity
	     * node.opacity(0.5);
	     */
	
	    Konva.Factory.addGetter(Konva.Node, 'name');
	    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'name');
	
	    /**
	     * get/set name
	     * @name name
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {String} name
	     * @returns {String}
	     * @example
	     * // get name
	     * var name = node.name();
	     *
	     * // set name
	     * node.name('foo');
	     *
	     * // also node may have multiple names (as css classes)
	     * node.name('foo bar');
	     */
	
	    Konva.Factory.addGetter(Konva.Node, 'id');
	    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'id');
	
	    /**
	     * get/set id. Id is global for whole page.
	     * @name id
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {String} id
	     * @returns {String}
	     * @example
	     * // get id
	     * var name = node.id();
	     *
	     * // set id
	     * node.id('foo');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'rotation', 0);
	
	    /**
	     * get/set rotation in degrees
	     * @name rotation
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Number} rotation
	     * @returns {Number}
	     * @example
	     * // get rotation in degrees
	     * var rotation = node.rotation();
	     *
	     * // set rotation in degrees
	     * node.rotation(45);
	     */
	
	    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'scale', ['x', 'y']);
	
	    /**
	     * get/set scale
	     * @name scale
	     * @param {Object} scale
	     * @param {Number} scale.x
	     * @param {Number} scale.y
	     * @method
	     * @memberof Konva.Node.prototype
	     * @returns {Object}
	     * @example
	     * // get scale
	     * var scale = node.scale();
	     *
	     * // set scale
	     * shape.scale({
	     *   x: 2
	     *   y: 3
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'scaleX', 1);
	
	    /**
	     * get/set scale x
	     * @name scaleX
	     * @param {Number} x
	     * @method
	     * @memberof Konva.Node.prototype
	     * @returns {Number}
	     * @example
	     * // get scale x
	     * var scaleX = node.scaleX();
	     *
	     * // set scale x
	     * node.scaleX(2);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'scaleY', 1);
	
	    /**
	     * get/set scale y
	     * @name scaleY
	     * @param {Number} y
	     * @method
	     * @memberof Konva.Node.prototype
	     * @returns {Number}
	     * @example
	     * // get scale y
	     * var scaleY = node.scaleY();
	     *
	     * // set scale y
	     * node.scaleY(2);
	     */
	
	    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'skew', ['x', 'y']);
	
	    /**
	     * get/set skew
	     * @name skew
	     * @param {Object} skew
	     * @param {Number} skew.x
	     * @param {Number} skew.y
	     * @method
	     * @memberof Konva.Node.prototype
	     * @returns {Object}
	     * @example
	     * // get skew
	     * var skew = node.skew();
	     *
	     * // set skew
	     * node.skew({
	     *   x: 20
	     *   y: 10
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'skewX', 0);
	
	    /**
	     * get/set skew x
	     * @name skewX
	     * @param {Number} x
	     * @method
	     * @memberof Konva.Node.prototype
	     * @returns {Number}
	     * @example
	     * // get skew x
	     * var skewX = node.skewX();
	     *
	     * // set skew x
	     * node.skewX(3);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'skewY', 0);
	
	    /**
	     * get/set skew y
	     * @name skewY
	     * @param {Number} y
	     * @method
	     * @memberof Konva.Node.prototype
	     * @returns {Number}
	     * @example
	     * // get skew y
	     * var skewY = node.skewY();
	     *
	     * // set skew y
	     * node.skewY(3);
	     */
	
	    Konva.Factory.addComponentsGetterSetter(Konva.Node, 'offset', ['x', 'y']);
	
	    /**
	     * get/set offset.  Offsets the default position and rotation point
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Object} offset
	     * @param {Number} offset.x
	     * @param {Number} offset.y
	     * @returns {Object}
	     * @example
	     * // get offset
	     * var offset = node.offset();
	     *
	     * // set offset
	     * node.offset({
	     *   x: 20
	     *   y: 10
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'offsetX', 0);
	
	    /**
	     * get/set offset x
	     * @name offsetX
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get offset x
	     * var offsetX = node.offsetX();
	     *
	     * // set offset x
	     * node.offsetX(3);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'offsetY', 0);
	
	    /**
	     * get/set offset y
	     * @name offsetY
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get offset y
	     * var offsetY = node.offsetY();
	     *
	     * // set offset y
	     * node.offsetY(3);
	     */
	
	    Konva.Factory.addSetter(Konva.Node, 'dragDistance');
	    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'dragDistance');
	
	    /**
	     * get/set drag distance
	     * @name dragDistance
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Number} distance
	     * @returns {Number}
	     * @example
	     * // get drag distance
	     * var dragDistance = node.dragDistance();
	     *
	     * // set distance
	     * // node starts dragging only if pointer moved more then 3 pixels
	     * node.dragDistance(3);
	     * // or set globally
	     * Konva.dragDistance = 3;
	     */
	
	
	    Konva.Factory.addSetter(Konva.Node, 'width', 0);
	    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'width');
	    /**
	     * get/set width
	     * @name width
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Number} width
	     * @returns {Number}
	     * @example
	     * // get width
	     * var width = node.width();
	     *
	     * // set width
	     * node.width(100);
	     */
	
	    Konva.Factory.addSetter(Konva.Node, 'height', 0);
	    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'height');
	    /**
	     * get/set height
	     * @name height
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Number} height
	     * @returns {Number}
	     * @example
	     * // get height
	     * var height = node.height();
	     *
	     * // set height
	     * node.height(100);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'listening', 'inherit');
	    /**
	     * get/set listenig attr.  If you need to determine if a node is listening or not
	     *   by taking into account its parents, use the isListening() method
	     * @name listening
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Boolean|String} listening Can be "inherit", true, or false.  The default is "inherit".
	     * @returns {Boolean|String}
	     * @example
	     * // get listening attr
	     * var listening = node.listening();
	     *
	     * // stop listening for events
	     * node.listening(false);
	     *
	     * // listen for events
	     * node.listening(true);
	     *
	     * // listen to events according to the parent
	     * node.listening('inherit');
	     */
	
	
	
	     /**
	      * get/set preventDefault
	      * By default all shapes will prevent default behaviour
	      * of a browser on a pointer move or tap.
	      * that will prevent native scrolling when you are trying to drag&drop a node
	      * but sometimes you may need to enable default actions
	      * in that case you can set the property to false
	      * @name preventDefault
	      * @method
	      * @memberof Konva.Node.prototype
	      * @param {Number} preventDefault
	      * @returns {Number}
	      * @example
	      * // get preventDefault
	      * var shouldPrevent = shape.preventDefault();
	      *
	      * // set preventDefault
	      * shape.preventDefault(false);
	      */
	
	     Konva.Factory.addGetterSetter(Konva.Node, 'preventDefault', true);
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'filters', undefined, function(val) {this._filterUpToDate = false; return val; });
	    /**
	     * get/set filters.  Filters are applied to cached canvases
	     * @name filters
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Array} filters array of filters
	     * @returns {Array}
	     * @example
	     * // get filters
	     * var filters = node.filters();
	     *
	     * // set a single filter
	     * node.cache();
	     * node.filters([Konva.Filters.Blur]);
	     *
	     * // set multiple filters
	     * node.cache();
	     * node.filters([
	     *   Konva.Filters.Blur,
	     *   Konva.Filters.Sepia,
	     *   Konva.Filters.Invert
	     * ]);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'visible', 'inherit');
	    /**
	     * get/set visible attr.  Can be "inherit", true, or false.  The default is "inherit".
	     *   If you need to determine if a node is visible or not
	     *   by taking into account its parents, use the isVisible() method
	     * @name visible
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Boolean|String} visible
	     * @returns {Boolean|String}
	     * @example
	     * // get visible attr
	     * var visible = node.visible();
	     *
	     * // make invisible
	     * node.visible(false);
	     *
	     * // make visible
	     * node.visible(true);
	     *
	     * // make visible according to the parent
	     * node.visible('inherit');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'transformsEnabled', 'all');
	
	    /**
	     * get/set transforms that are enabled.  Can be "all", "none", or "position".  The default
	     *  is "all"
	     * @name transformsEnabled
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {String} enabled
	     * @returns {String}
	     * @example
	     * // enable position transform only to improve draw performance
	     * node.transformsEnabled('position');
	     *
	     * // enable all transforms
	     * node.transformsEnabled('all');
	     */
	
	
	
	    /**
	     * get/set node size
	     * @name size
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Object} size
	     * @param {Number} size.width
	     * @param {Number} size.height
	     * @returns {Object}
	     * @example
	     * // get node size
	     * var size = node.size();
	     * var x = size.x;
	     * var y = size.y;
	     *
	     * // set size
	     * node.size({
	     *   width: 100,
	     *   height: 200
	     * });
	     */
	    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'size');
	
	    Konva.Factory.backCompat(Konva.Node, {
	        rotateDeg: 'rotate',
	        setRotationDeg: 'setRotation',
	        getRotationDeg: 'getRotation'
	    });
	
	    Konva.Collection.mapMethods(Konva.Node);
	})(Konva);
	
	(function() {
	    'use strict';
	    /**
	    * Grayscale Filter
	    * @function
	    * @memberof Konva.Filters
	    * @param {Object} imageData
	    * @example
	    * node.cache();
	    * node.filters([Konva.Filters.Grayscale]);
	    */
	    Konva.Filters.Grayscale = function(imageData) {
	        var data = imageData.data,
	            len = data.length,
	            i, brightness;
	
	        for(i = 0; i < len; i += 4) {
	            brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
	            // red
	            data[i] = brightness;
	            // green
	            data[i + 1] = brightness;
	            // blue
	            data[i + 2] = brightness;
	        }
	    };
	})();
	
	(function() {
	    'use strict';
	    /**
	     * Brighten Filter.
	     * @function
	     * @memberof Konva.Filters
	     * @param {Object} imageData
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.Brighten]);
	     * node.brightness(0.8);
	     */
	    Konva.Filters.Brighten = function(imageData) {
	        var brightness = this.brightness() * 255,
	            data = imageData.data,
	            len = data.length,
	            i;
	
	        for(i = 0; i < len; i += 4) {
	            // red
	            data[i] += brightness;
	            // green
	            data[i + 1] += brightness;
	            // blue
	            data[i + 2] += brightness;
	        }
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'brightness', 0, null, Konva.Factory.afterSetFilter);
	    /**
	    * get/set filter brightness.  The brightness is a number between -1 and 1.&nbsp; Positive values
	    *  brighten the pixels and negative values darken them. Use with {@link Konva.Filters.Brighten} filter.
	    * @name brightness
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} brightness value between -1 and 1
	    * @returns {Number}
	    */
	
	})();
	
	(function() {
	    'use strict';
	    /**
	    * Invert Filter
	    * @function
	    * @memberof Konva.Filters
	    * @param {Object} imageData
	    * @example
	    * node.cache();
	    * node.filters([Konva.Filters.Invert]);
	    */
	    Konva.Filters.Invert = function(imageData) {
	        var data = imageData.data,
	            len = data.length,
	            i;
	
	        for(i = 0; i < len; i += 4) {
	            // red
	            data[i] = 255 - data[i];
	            // green
	            data[i + 1] = 255 - data[i + 1];
	            // blue
	            data[i + 2] = 255 - data[i + 2];
	        }
	    };
	})();
	
	/*
	 the Gauss filter
	 master repo: https://github.com/pavelpower/kineticjsGaussFilter
	*/
	(function() {
	    'use strict';
	    /*
	
	     StackBlur - a fast almost Gaussian Blur For Canvas
	
	     Version:   0.5
	     Author:    Mario Klingemann
	     Contact:   mario@quasimondo.com
	     Website:   http://www.quasimondo.com/StackBlurForCanvas
	     Twitter:   @quasimondo
	
	     In case you find this class useful - especially in commercial projects -
	     I am not totally unhappy for a small donation to my PayPal account
	     mario@quasimondo.de
	
	     Or support me on flattr:
	     https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript
	
	     Copyright (c) 2010 Mario Klingemann
	
	     Permission is hereby granted, free of charge, to any person
	     obtaining a copy of this software and associated documentation
	     files (the "Software"), to deal in the Software without
	     restriction, including without limitation the rights to use,
	     copy, modify, merge, publish, distribute, sublicense, and/or sell
	     copies of the Software, and to permit persons to whom the
	     Software is furnished to do so, subject to the following
	     conditions:
	
	     The above copyright notice and this permission notice shall be
	     included in all copies or substantial portions of the Software.
	
	     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	     OTHER DEALINGS IN THE SOFTWARE.
	     */
	
	    function BlurStack() {
	        this.r = 0;
	        this.g = 0;
	        this.b = 0;
	        this.a = 0;
	        this.next = null;
	    }
	
	    var mul_table = [
	        512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512,
	        454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512,
	        482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456,
	        437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512,
	        497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328,
	        320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456,
	        446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335,
	        329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512,
	        505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405,
	        399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328,
	        324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271,
	        268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456,
	        451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388,
	        385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335,
	        332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292,
	        289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259
	    ];
	
	    var shg_table = [
	        9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
	        17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
	        19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
	        20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
	        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
	        21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
	        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
	        22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
	        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
	        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
	        23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
	        23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	        24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
	    ];
	
	    function filterGaussBlurRGBA( imageData, radius) {
	
	        var pixels = imageData.data,
	            width = imageData.width,
	            height = imageData.height;
	
	        var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
	            r_out_sum, g_out_sum, b_out_sum, a_out_sum,
	            r_in_sum, g_in_sum, b_in_sum, a_in_sum,
	            pr, pg, pb, pa, rbs;
	
	        var div = radius + radius + 1,
	            widthMinus1 = width - 1,
	            heightMinus1 = height - 1,
	            radiusPlus1 = radius + 1,
	            sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2,
	            stackStart = new BlurStack(),
	            stackEnd = null,
	            stack = stackStart,
	            stackIn = null,
	            stackOut = null,
	            mul_sum = mul_table[radius],
	            shg_sum = shg_table[radius];
	
	        for ( i = 1; i < div; i++ ) {
	            stack = stack.next = new BlurStack();
	            if ( i === radiusPlus1 ){
	                stackEnd = stack;
	            }
	        }
	
	        stack.next = stackStart;
	
	        yw = yi = 0;
	
	        for ( y = 0; y < height; y++ )
	        {
	            r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
	
	            r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
	            g_out_sum = radiusPlus1 * ( pg = pixels[yi + 1] );
	            b_out_sum = radiusPlus1 * ( pb = pixels[yi + 2] );
	            a_out_sum = radiusPlus1 * ( pa = pixels[yi + 3] );
	
	            r_sum += sumFactor * pr;
	            g_sum += sumFactor * pg;
	            b_sum += sumFactor * pb;
	            a_sum += sumFactor * pa;
	
	            stack = stackStart;
	
	            for( i = 0; i < radiusPlus1; i++ )
	            {
	                stack.r = pr;
	                stack.g = pg;
	                stack.b = pb;
	                stack.a = pa;
	                stack = stack.next;
	            }
	
	            for( i = 1; i < radiusPlus1; i++ )
	            {
	                p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
	                r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
	                g_sum += ( stack.g = ( pg = pixels[p + 1])) * rbs;
	                b_sum += ( stack.b = ( pb = pixels[p + 2])) * rbs;
	                a_sum += ( stack.a = ( pa = pixels[p + 3])) * rbs;
	
	                r_in_sum += pr;
	                g_in_sum += pg;
	                b_in_sum += pb;
	                a_in_sum += pa;
	
	                stack = stack.next;
	            }
	
	
	            stackIn = stackStart;
	            stackOut = stackEnd;
	            for ( x = 0; x < width; x++ )
	            {
	                pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
	                if ( pa !== 0 )
	                {
	                    pa = 255 / pa;
	                    pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
	                    pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
	                    pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
	                } else {
	                    pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
	                }
	
	                r_sum -= r_out_sum;
	                g_sum -= g_out_sum;
	                b_sum -= b_out_sum;
	                a_sum -= a_out_sum;
	
	                r_out_sum -= stackIn.r;
	                g_out_sum -= stackIn.g;
	                b_out_sum -= stackIn.b;
	                a_out_sum -= stackIn.a;
	
	                p = (yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
	
	                r_in_sum += ( stackIn.r = pixels[p]);
	                g_in_sum += ( stackIn.g = pixels[p + 1]);
	                b_in_sum += ( stackIn.b = pixels[p + 2]);
	                a_in_sum += ( stackIn.a = pixels[p + 3]);
	
	                r_sum += r_in_sum;
	                g_sum += g_in_sum;
	                b_sum += b_in_sum;
	                a_sum += a_in_sum;
	
	                stackIn = stackIn.next;
	
	                r_out_sum += ( pr = stackOut.r );
	                g_out_sum += ( pg = stackOut.g );
	                b_out_sum += ( pb = stackOut.b );
	                a_out_sum += ( pa = stackOut.a );
	
	                r_in_sum -= pr;
	                g_in_sum -= pg;
	                b_in_sum -= pb;
	                a_in_sum -= pa;
	
	                stackOut = stackOut.next;
	
	                yi += 4;
	            }
	            yw += width;
	        }
	
	
	        for ( x = 0; x < width; x++ )
	        {
	            g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
	
	            yi = x << 2;
	            r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
	            g_out_sum = radiusPlus1 * ( pg = pixels[yi + 1]);
	            b_out_sum = radiusPlus1 * ( pb = pixels[yi + 2]);
	            a_out_sum = radiusPlus1 * ( pa = pixels[yi + 3]);
	
	            r_sum += sumFactor * pr;
	            g_sum += sumFactor * pg;
	            b_sum += sumFactor * pb;
	            a_sum += sumFactor * pa;
	
	            stack = stackStart;
	
	            for( i = 0; i < radiusPlus1; i++ )
	            {
	                stack.r = pr;
	                stack.g = pg;
	                stack.b = pb;
	                stack.a = pa;
	                stack = stack.next;
	            }
	
	            yp = width;
	
	            for( i = 1; i <= radius; i++ )
	            {
	                yi = ( yp + x ) << 2;
	
	                r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
	                g_sum += ( stack.g = ( pg = pixels[yi + 1])) * rbs;
	                b_sum += ( stack.b = ( pb = pixels[yi + 2])) * rbs;
	                a_sum += ( stack.a = ( pa = pixels[yi + 3])) * rbs;
	
	                r_in_sum += pr;
	                g_in_sum += pg;
	                b_in_sum += pb;
	                a_in_sum += pa;
	
	                stack = stack.next;
	
	                if( i < heightMinus1 )
	                {
	                    yp += width;
	                }
	            }
	
	            yi = x;
	            stackIn = stackStart;
	            stackOut = stackEnd;
	            for ( y = 0; y < height; y++ )
	            {
	                p = yi << 2;
	                pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
	                if ( pa > 0 )
	                {
	                    pa = 255 / pa;
	                    pixels[p] = ((r_sum * mul_sum) >> shg_sum ) * pa;
	                    pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
	                    pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
	                } else {
	                    pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
	                }
	
	                r_sum -= r_out_sum;
	                g_sum -= g_out_sum;
	                b_sum -= b_out_sum;
	                a_sum -= a_out_sum;
	
	                r_out_sum -= stackIn.r;
	                g_out_sum -= stackIn.g;
	                b_out_sum -= stackIn.b;
	                a_out_sum -= stackIn.a;
	
	                p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
	
	                r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
	                g_sum += ( g_in_sum += ( stackIn.g = pixels[p + 1]));
	                b_sum += ( b_in_sum += ( stackIn.b = pixels[p + 2]));
	                a_sum += ( a_in_sum += ( stackIn.a = pixels[p + 3]));
	
	                stackIn = stackIn.next;
	
	                r_out_sum += ( pr = stackOut.r );
	                g_out_sum += ( pg = stackOut.g );
	                b_out_sum += ( pb = stackOut.b );
	                a_out_sum += ( pa = stackOut.a );
	
	                r_in_sum -= pr;
	                g_in_sum -= pg;
	                b_in_sum -= pb;
	                a_in_sum -= pa;
	
	                stackOut = stackOut.next;
	
	                yi += width;
	            }
	        }
	    }
	
	    /**
	     * Blur Filter
	     * @function
	     * @name Blur
	     * @memberof Konva.Filters
	     * @param {Object} imageData
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.Blur]);
	     * node.blurRadius(10);
	     */
	    Konva.Filters.Blur = function Blur(imageData) {
	        var radius = Math.round(this.blurRadius());
	
	        if (radius > 0) {
	            filterGaussBlurRGBA(imageData, radius);
	        }
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'blurRadius', 0, null, Konva.Factory.afterSetFilter);
	
	    /**
	    * get/set blur radius. Use with {@link Konva.Filters.Blur} filter
	    * @name blurRadius
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Integer} radius
	    * @returns {Integer}
	    */
	})();
	
	/*eslint-disable  max-depth */
	(function() {
		'use strict';
		function pixelAt(idata, x, y) {
			var idx = (y * idata.width + x) * 4;
			var d = [];
			d.push(idata.data[idx++], idata.data[idx++], idata.data[idx++], idata.data[idx++]);
			return d;
		}
	
		function rgbDistance(p1, p2) {
			return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
		}
	
		function rgbMean(pTab) {
			var m = [0, 0, 0];
	
			for (var i = 0; i < pTab.length; i++) {
				m[0] += pTab[i][0];
				m[1] += pTab[i][1];
				m[2] += pTab[i][2];
			}
	
			m[0] /= pTab.length;
			m[1] /= pTab.length;
			m[2] /= pTab.length;
	
			return m;
		}
	
		function backgroundMask(idata, threshold) {
			var rgbv_no = pixelAt(idata, 0, 0);
			var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
			var rgbv_so = pixelAt(idata, 0, idata.height - 1);
			var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);
	
	
			var thres = threshold || 10;
			if (rgbDistance(rgbv_no, rgbv_ne) < thres && rgbDistance(rgbv_ne, rgbv_se) < thres && rgbDistance(rgbv_se, rgbv_so) < thres && rgbDistance(rgbv_so, rgbv_no) < thres) {
	
				// Mean color
				var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);
	
				// Mask based on color distance
				var mask = [];
				for (var i = 0; i < idata.width * idata.height; i++) {
					var d = rgbDistance(mean, [idata.data[i * 4], idata.data[i * 4 + 1], idata.data[i * 4 + 2]]);
					mask[i] = (d < thres) ? 0 : 255;
				}
	
				return mask;
			}
		}
	
		function applyMask(idata, mask) {
			for (var i = 0; i < idata.width * idata.height; i++) {
				idata.data[4 * i + 3] = mask[i];
			}
		}
	
		function erodeMask(mask, sw, sh) {
	
			var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
			var side = Math.round(Math.sqrt(weights.length));
			var halfSide = Math.floor(side / 2);
	
			var maskResult = [];
			for (var y = 0; y < sh; y++) {
				for (var x = 0; x < sw; x++) {
	
					var so = y * sw + x;
					var a = 0;
					for (var cy = 0; cy < side; cy++) {
						for (var cx = 0; cx < side; cx++) {
							var scy = y + cy - halfSide;
							var scx = x + cx - halfSide;
	
							if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
	
								var srcOff = scy * sw + scx;
								var wt = weights[cy * side + cx];
	
								a += mask[srcOff] * wt;
							}
						}
					}
	
					maskResult[so] = (a === 255 * 8) ? 255 : 0;
				}
			}
	
			return maskResult;
		}
	
		function dilateMask(mask, sw, sh) {
	
			var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
			var side = Math.round(Math.sqrt(weights.length));
			var halfSide = Math.floor(side / 2);
	
			var maskResult = [];
			for (var y = 0; y < sh; y++) {
				for (var x = 0; x < sw; x++) {
	
					var so = y * sw + x;
					var a = 0;
					for (var cy = 0; cy < side; cy++) {
						for (var cx = 0; cx < side; cx++) {
							var scy = y + cy - halfSide;
							var scx = x + cx - halfSide;
	
							if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
	
								var srcOff = scy * sw + scx;
								var wt = weights[cy * side + cx];
	
								a += mask[srcOff] * wt;
							}
						}
					}
	
					maskResult[so] = (a >= 255 * 4) ? 255 : 0;
				}
			}
	
			return maskResult;
		}
	
		function smoothEdgeMask(mask, sw, sh) {
	
			var weights = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9];
			var side = Math.round(Math.sqrt(weights.length));
			var halfSide = Math.floor(side / 2);
	
			var maskResult = [];
			for (var y = 0; y < sh; y++) {
				for (var x = 0; x < sw; x++) {
	
					var so = y * sw + x;
					var a = 0;
					for (var cy = 0; cy < side; cy++) {
						for (var cx = 0; cx < side; cx++) {
							var scy = y + cy - halfSide;
							var scx = x + cx - halfSide;
	
							if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
	
								var srcOff = scy * sw + scx;
								var wt = weights[cy * side + cx];
	
								a += mask[srcOff] * wt;
							}
						}
					}
	
					maskResult[so] = a;
				}
			}
	
			return maskResult;
		}
	
		/**
		 * Mask Filter
		 * @function
		 * @name Mask
		 * @memberof Konva.Filters
		 * @param {Object} imageData
		 * @example
	     * node.cache();
	     * node.filters([Konva.Filters.Mask]);
	     * node.threshold(200);
		 */
		Konva.Filters.Mask = function(imageData) {
			// Detect pixels close to the background color
			var threshold = this.threshold(),
	        mask = backgroundMask(imageData, threshold);
			if (mask) {
				// Erode
				mask = erodeMask(mask, imageData.width, imageData.height);
	
				// Dilate
				mask = dilateMask(mask, imageData.width, imageData.height);
	
				// Gradient
				mask = smoothEdgeMask(mask, imageData.width, imageData.height);
	
				// Apply mask
				applyMask(imageData, mask);
	
				// todo : Update hit region function according to mask
			}
	
			return imageData;
		};
	
		Konva.Factory.addGetterSetter(Konva.Node, 'threshold', 0, null, Konva.Factory.afterSetFilter);
	})();
	
	(function () {
	    'use strict';
	    /**
	     * RGB Filter
	     * @function
	     * @name RGB
	     * @memberof Konva.Filters
	     * @param {Object} imageData
	     * @author ippo615
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.RGB]);
	     * node.blue(120);
	     * node.green(200);
	     */
	    Konva.Filters.RGB = function (imageData) {
	        var data = imageData.data,
	            nPixels = data.length,
	            red = this.red(),
	            green = this.green(),
	            blue = this.blue(),
	            i, brightness;
	
	        for (i = 0; i < nPixels; i += 4) {
	            brightness = (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
	            data[i] = brightness * red; // r
	            data[i + 1] = brightness * green; // g
	            data[i + 2] = brightness * blue; // b
	            data[i + 3] = data[i + 3]; // alpha
	        }
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
	        this._filterUpToDate = false;
	        if (val > 255) {
	            return 255;
	        }
	        else if (val < 0) {
	            return 0;
	        }
	        else {
	            return Math.round(val);
	        }
	    });
	    /**
	    * get/set filter red value. Use with {@link Konva.Filters.RGB} filter.
	    * @name red
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Integer} red value between 0 and 255
	    * @returns {Integer}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
	        this._filterUpToDate = false;
	        if (val > 255) {
	            return 255;
	        }
	        else if (val < 0) {
	            return 0;
	        }
	        else {
	            return Math.round(val);
	        }
	    });
	    /**
	    * get/set filter green value. Use with {@link Konva.Filters.RGB} filter.
	    * @name green
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Integer} green value between 0 and 255
	    * @returns {Integer}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'blue', 0, Konva.Validators.RGBComponent, Konva.Factory.afterSetFilter);
	    /**
	    * get/set filter blue value. Use with {@link Konva.Filters.RGB} filter.
	    * @name blue
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Integer} blue value between 0 and 255
	    * @returns {Integer}
	    */
	})();
	
	(function () {
	    'use strict';
	    /**
	     * RGBA Filter
	     * @function
	     * @name RGBA
	     * @memberof Konva.Filters
	     * @param {Object} imageData
	     * @author codefo
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.RGBA]);
	     * node.blue(120);
	     * node.green(200);
	     * node.alpha(0.3);
	     */
	    Konva.Filters.RGBA = function (imageData) {
	        var data = imageData.data,
	            nPixels = data.length,
	            red = this.red(),
	            green = this.green(),
	            blue = this.blue(),
	            alpha = this.alpha(),
	            i, ia;
	
	        for (i = 0; i < nPixels; i += 4) {
	            ia = 1 - alpha;
	
	            data[i] = red * alpha + data[i] * ia; // r
	            data[i + 1] = green * alpha + data[i + 1] * ia; // g
	            data[i + 2] = blue * alpha + data[i + 2] * ia; // b
	        }
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
	        this._filterUpToDate = false;
	        if (val > 255) {
	            return 255;
	        }
	        else if (val < 0) {
	            return 0;
	        }
	        else {
	            return Math.round(val);
	        }
	    });
	    /**
	    * get/set filter red value. Use with {@link Konva.Filters.RGBA} filter.
	    * @name red
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Integer} red value between 0 and 255
	    * @returns {Integer}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
	        this._filterUpToDate = false;
	        if (val > 255) {
	            return 255;
	        }
	        else if (val < 0) {
	            return 0;
	        }
	        else {
	            return Math.round(val);
	        }
	    });
	    /**
	    * get/set filter green value. Use with {@link Konva.Filters.RGBA} filter.
	    * @name green
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Integer} green value between 0 and 255
	    * @returns {Integer}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'blue', 0, Konva.Validators.RGBComponent, Konva.Factory.afterSetFilter);
	    /**
	    * get/set filter blue value. Use with {@link Konva.Filters.RGBA} filter.
	    * @name blue
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Integer} blue value between 0 and 255
	    * @returns {Integer}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'alpha', 1, function(val) {
	        this._filterUpToDate = false;
	        if (val > 1) {
	            return 1;
	        }
	        else if (val < 0) {
	            return 0;
	        }
	        else {
	            return val;
	        }
	    });
	    /**
	     * get/set filter alpha value. Use with {@link Konva.Filters.RGBA} filter.
	     * @name alpha
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Float} alpha value between 0 and 1
	     * @returns {Float}
	     */
	})();
	
	(function () {
	    'use strict';
	    /**
	    * HSV Filter. Adjusts the hue, saturation and value
	    * @function
	    * @name HSV
	    * @memberof Konva.Filters
	    * @param {Object} imageData
	    * @author ippo615
	    * @example
	    * image.filters([Konva.Filters.HSV]);
	    * image.value(200);
	    */
	
	    Konva.Filters.HSV = function (imageData) {
	        var data = imageData.data,
	            nPixels = data.length,
	            v = Math.pow(2, this.value()),
	            s = Math.pow(2, this.saturation()),
	            h = Math.abs((this.hue()) + 360) % 360,
	            i;
	
	        // Basis for the technique used:
	        // http://beesbuzz.biz/code/hsv_color_transforms.php
	        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
	        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
	        // H is the hue shift in degrees (0 to 360)
	        // vsu = V*S*cos(H*PI/180);
	        // vsw = V*S*sin(H*PI/180);
	        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
	        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
	        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]
	
	        // Precompute the values in the matrix:
	        var vsu = v * s * Math.cos(h * Math.PI / 180),
	            vsw = v * s * Math.sin(h * Math.PI / 180);
	        // (result spot)(source spot)
	        var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
	            rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
	            rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
	        var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
	            gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
	            gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
	        var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
	            bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
	            bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;
	
	        var r, g, b, a;
	
	        for (i = 0; i < nPixels; i += 4) {
	            r = data[i + 0];
	            g = data[i + 1];
	            b = data[i + 2];
	            a = data[i + 3];
	
	            data[i + 0] = rr * r + rg * g + rb * b;
	            data[i + 1] = gr * r + gg * g + gb * b;
	            data[i + 2] = br * r + bg * g + bb * b;
	            data[i + 3] = a; // alpha
	        }
	
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'hue', 0, null, Konva.Factory.afterSetFilter);
	    /**
	    * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
	    * @name hue
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} hue value between 0 and 359
	    * @returns {Number}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'saturation', 0, null, Konva.Factory.afterSetFilter);
	    /**
	    * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
	    * @name saturation
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
	    * @returns {Number}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'value', 0, null, Konva.Factory.afterSetFilter);
	    /**
	    * get/set hsv value. Use with {@link Konva.Filters.HSV} filter.
	    * @name value
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
	    * @returns {Number}
	    */
	
	})();
	
	(function () {
	    'use strict';
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'hue', 0, null, Konva.Factory.afterSetFilter);
	    /**
	    * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
	    * @name hue
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} hue value between 0 and 359
	    * @returns {Number}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'saturation', 0, null, Konva.Factory.afterSetFilter);
	    /**
	    * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
	    * @name saturation
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
	    * @returns {Number}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'luminance', 0, null, Konva.Factory.afterSetFilter);
	    /**
	    * get/set hsl luminance. Use with {@link Konva.Filters.HSL} filter.
	    * @name value
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
	    * @returns {Number}
	    */
	
	    /**
	    * HSL Filter. Adjusts the hue, saturation and luminance (or lightness)
	    * @function
	    * @memberof Konva.Filters
	    * @param {Object} imageData
	    * @author ippo615
	    * @example
	    * image.filters([Konva.Filters.HSL]);
	    * image.luminance(200);
	    */
	
	    Konva.Filters.HSL = function (imageData) {
	        var data = imageData.data,
	            nPixels = data.length,
	            v = 1,
	            s = Math.pow(2, this.saturation()),
	            h = Math.abs((this.hue()) + 360) % 360,
	            l = this.luminance() * 127,
	            i;
	
	        // Basis for the technique used:
	        // http://beesbuzz.biz/code/hsv_color_transforms.php
	        // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
	        // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
	        // H is the hue shift in degrees (0 to 360)
	        // vsu = V*S*cos(H*PI/180);
	        // vsw = V*S*sin(H*PI/180);
	        //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
	        //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
	        //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]
	
	        // Precompute the values in the matrix:
	        var vsu = v * s * Math.cos(h * Math.PI / 180),
	            vsw = v * s * Math.sin(h * Math.PI / 180);
	        // (result spot)(source spot)
	        var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
	            rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
	            rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
	        var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
	            gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
	            gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
	        var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
	            bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
	            bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;
	
	        var r, g, b, a;
	
	        for (i = 0; i < nPixels; i += 4) {
	            r = data[i + 0];
	            g = data[i + 1];
	            b = data[i + 2];
	            a = data[i + 3];
	
	            data[i + 0] = rr * r + rg * g + rb * b + l;
	            data[i + 1] = gr * r + gg * g + gb * b + l;
	            data[i + 2] = br * r + bg * g + bb * b + l;
	            data[i + 3] = a; // alpha
	        }
	    };
	})();
	
	(function () {
	    'use strict';
	    /**
	     * Emboss Filter.
	     * Pixastic Lib - Emboss filter - v0.1.0
	     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
	     * License: [http://www.pixastic.com/lib/license.txt]
	     * @function
	     * @memberof Konva.Filters
	     * @param {Object} imageData
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.Emboss]);
	     * node.embossStrength(0.8);
	     * node.embossWhiteLevel(0.3);
	     * node.embossDirection('right');
	     * node.embossBlend(true);
	     */
	    Konva.Filters.Emboss = function (imageData) {
	
	        // pixastic strength is between 0 and 10.  I want it between 0 and 1
	        // pixastic greyLevel is between 0 and 255.  I want it between 0 and 1.  Also,
	        // a max value of greyLevel yields a white emboss, and the min value yields a black
	        // emboss.  Therefore, I changed greyLevel to whiteLevel
	        var strength = this.embossStrength() * 10,
	            greyLevel = this.embossWhiteLevel() * 255,
	            direction = this.embossDirection(),
	            blend = this.embossBlend(),
	            dirY = 0,
	            dirX = 0,
	            data = imageData.data,
	            w = imageData.width,
	            h = imageData.height,
	            w4 = w * 4,
	            y = h;
	
	        switch (direction) {
	            case 'top-left':
	                dirY = -1;
	                dirX = -1;
	                break;
	            case 'top':
	                dirY = -1;
	                dirX = 0;
	                break;
	            case 'top-right':
	                dirY = -1;
	                dirX = 1;
	                break;
	            case 'right':
	                dirY = 0;
	                dirX = 1;
	                break;
	            case 'bottom-right':
	                dirY = 1;
	                dirX = 1;
	                break;
	            case 'bottom':
	                dirY = 1;
	                dirX = 0;
	                break;
	            case 'bottom-left':
	                dirY = 1;
	                dirX = -1;
	                break;
	            case 'left':
	                dirY = 0;
	                dirX = -1;
	                break;
	            default:
	                Konva.Util.error('Unknwo emboss direction: ' + direction);
	        }
	
	        do {
	            var offsetY = (y - 1) * w4;
	
	            var otherY = dirY;
	            if (y + otherY < 1){
	                otherY = 0;
	            }
	            if (y + otherY > h) {
	                otherY = 0;
	            }
	
	            var offsetYOther = (y - 1 + otherY) * w * 4;
	
	            var x = w;
	            do {
	                var offset = offsetY + (x - 1) * 4;
	
	                var otherX = dirX;
	                if (x + otherX < 1){
	                    otherX = 0;
	                }
	                if (x + otherX > w) {
	                    otherX = 0;
	                }
	
	                var offsetOther = offsetYOther + (x - 1 + otherX) * 4;
	
	                var dR = data[offset] - data[offsetOther];
	                var dG = data[offset + 1] - data[offsetOther + 1];
	                var dB = data[offset + 2] - data[offsetOther + 2];
	
	                var dif = dR;
	                var absDif = dif > 0 ? dif : -dif;
	
	                var absG = dG > 0 ? dG : -dG;
	                var absB = dB > 0 ? dB : -dB;
	
	                if (absG > absDif) {
	                    dif = dG;
	                }
	                if (absB > absDif) {
	                    dif = dB;
	                }
	
	                dif *= strength;
	
	                if (blend) {
	                    var r = data[offset] + dif;
	                    var g = data[offset + 1] + dif;
	                    var b = data[offset + 2] + dif;
	
	                    data[offset] = (r > 255) ? 255 : (r < 0 ? 0 : r);
	                    data[offset + 1] = (g > 255) ? 255 : (g < 0 ? 0 : g);
	                    data[offset + 2] = (b > 255) ? 255 : (b < 0 ? 0 : b);
	                } else {
	                    var grey = greyLevel - dif;
	                    if (grey < 0) {
	                        grey = 0;
	                    } else if (grey > 255) {
	                        grey = 255;
	                    }
	
	                    data[offset] = data[offset + 1] = data[offset + 2] = grey;
	                }
	
	            } while (--x);
	        } while (--y);
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'embossStrength', 0.5, null, Konva.Factory.afterSetFilter);
	    /**
	    * get/set emboss strength. Use with {@link Konva.Filters.Emboss} filter.
	    * @name embossStrength
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} level between 0 and 1.  Default is 0.5
	    * @returns {Number}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'embossWhiteLevel', 0.5, null, Konva.Factory.afterSetFilter);
	    /**
	    * get/set emboss white level. Use with {@link Konva.Filters.Emboss} filter.
	    * @name embossWhiteLevel
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} embossWhiteLevel between 0 and 1.  Default is 0.5
	    * @returns {Number}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'embossDirection', 'top-left', null, Konva.Factory.afterSetFilter);
	    /**
	    * get/set emboss direction. Use with {@link Konva.Filters.Emboss} filter.
	    * @name embossDirection
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {String} embossDirection can be top-left, top, top-right, right, bottom-right, bottom, bottom-left or left
	    *   The default is top-left
	    * @returns {String}
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'embossBlend', false, null, Konva.Factory.afterSetFilter);
	    /**
	    * get/set emboss blend. Use with {@link Konva.Filters.Emboss} filter.
	    * @name embossBlend
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Boolean} embossBlend
	    * @returns {Boolean}
	    */
	})();
	
	(function () {
	    'use strict';
	    function remap(fromValue, fromMin, fromMax, toMin, toMax) {
	        // Compute the range of the data
	        var fromRange = fromMax - fromMin,
	          toRange = toMax - toMin,
	          toValue;
	
	        // If either range is 0, then the value can only be mapped to 1 value
	        if (fromRange === 0) {
	            return toMin + toRange / 2;
	        }
	        if (toRange === 0) {
	            return toMin;
	        }
	
	        // (1) untranslate, (2) unscale, (3) rescale, (4) retranslate
	        toValue = (fromValue - fromMin) / fromRange;
	        toValue = (toRange * toValue) + toMin;
	
	        return toValue;
	    }
	
	
	    /**
	    * Enhance Filter. Adjusts the colors so that they span the widest
	    *  possible range (ie 0-255). Performs w*h pixel reads and w*h pixel
	    *  writes.
	    * @function
	    * @name Enhance
	    * @memberof Konva.Filters
	    * @param {Object} imageData
	    * @author ippo615
	    * @example
	    * node.cache();
	    * node.filters([Konva.Filters.Enhance]);
	    * node.enhance(0.4);
	    */
	    Konva.Filters.Enhance = function (imageData) {
	        var data = imageData.data,
	            nSubPixels = data.length,
	            rMin = data[0], rMax = rMin, r,
	            gMin = data[1], gMax = gMin, g,
	            bMin = data[2], bMax = bMin, b,
	            i;
	
	        // If we are not enhancing anything - don't do any computation
	        var enhanceAmount = this.enhance();
	        if( enhanceAmount === 0 ){ return; }
	
	        // 1st Pass - find the min and max for each channel:
	        for (i = 0; i < nSubPixels; i += 4) {
	            r = data[i + 0];
	            if (r < rMin) { rMin = r; }
	            else if (r > rMax) { rMax = r; }
	            g = data[i + 1];
	            if (g < gMin) { gMin = g; } else
	            if (g > gMax) { gMax = g; }
	            b = data[i + 2];
	            if (b < bMin) { bMin = b; } else
	            if (b > bMax) { bMax = b; }
	            //a = data[i + 3];
	            //if (a < aMin) { aMin = a; } else
	            //if (a > aMax) { aMax = a; }
	        }
	
	        // If there is only 1 level - don't remap
	        if( rMax === rMin ){ rMax = 255; rMin = 0; }
	        if( gMax === gMin ){ gMax = 255; gMin = 0; }
	        if( bMax === bMin ){ bMax = 255; bMin = 0; }
	
	        var rMid, rGoalMax, rGoalMin,
	            gMid, gGoalMax, gGoalMin,
	            bMid, bGoalMax, bGoalMin;
	
	        // If the enhancement is positive - stretch the histogram
	        if ( enhanceAmount > 0 ){
	            rGoalMax = rMax + enhanceAmount * (255 - rMax);
	            rGoalMin = rMin - enhanceAmount * (rMin - 0);
	            gGoalMax = gMax + enhanceAmount * (255 - gMax);
	            gGoalMin = gMin - enhanceAmount * (gMin - 0);
	            bGoalMax = bMax + enhanceAmount * (255 - bMax);
	            bGoalMin = bMin - enhanceAmount * (bMin - 0);
	        // If the enhancement is negative -   compress the histogram
	        } else {
	            rMid = (rMax + rMin) * 0.5;
	            rGoalMax = rMax + enhanceAmount * (rMax - rMid);
	            rGoalMin = rMin + enhanceAmount * (rMin - rMid);
	            gMid = (gMax + gMin) * 0.5;
	            gGoalMax = gMax + enhanceAmount * (gMax - gMid);
	            gGoalMin = gMin + enhanceAmount * (gMin - gMid);
	            bMid = (bMax + bMin) * 0.5;
	            bGoalMax = bMax + enhanceAmount * (bMax - bMid);
	            bGoalMin = bMin + enhanceAmount * (bMin - bMid);
	        }
	
	        // Pass 2 - remap everything, except the alpha
	        for (i = 0; i < nSubPixels; i += 4) {
	            data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
	            data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
	            data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
	            //data[i + 3] = remap(data[i + 3], aMin, aMax, aGoalMin, aGoalMax);
	        }
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'enhance', 0, null, Konva.Factory.afterSetFilter);
	
	    /**
	    * get/set enhance. Use with {@link Konva.Filters.Enhance} filter.
	    * @name enhance
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Float} amount
	    * @returns {Float}
	    */
	})();
	
	(function () {
	    'use strict';
	    /**
	     * Posterize Filter. Adjusts the channels so that there are no more
	     *  than n different values for that channel. This is also applied
	     *  to the alpha channel.
	     * @function
	     * @name Posterize
	     * @author ippo615
	     * @memberof Konva.Filters
	     * @param {Object} imageData
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.Posterize]);
	     * node.levels(0.8); // between 0 and 1
	     */
	
	    Konva.Filters.Posterize = function (imageData) {
	        // level must be between 1 and 255
	        var levels = Math.round(this.levels() * 254) + 1,
	            data = imageData.data,
	            len = data.length,
	            scale = (255 / levels),
	            i;
	
	        for (i = 0; i < len; i += 1) {
	            data[i] = Math.floor(data[i] / scale) * scale;
	        }
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'levels', 0.5, null, Konva.Factory.afterSetFilter);
	
	    /**
	    * get/set levels.  Must be a number between 0 and 1.  Use with {@link Konva.Filters.Posterize} filter.
	    * @name levels
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} level between 0 and 1
	    * @returns {Number}
	    */
	})();
	
	(function () {
	    'use strict';
	
	    /**
	     * Noise Filter. Randomly adds or substracts to the color channels
	     * @function
	     * @name Noise
	     * @memberof Konva.Filters
	     * @param {Object} imageData
	     * @author ippo615
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.Noise]);
	     * node.noise(0.8);
	     */
	    Konva.Filters.Noise = function (imageData) {
	        var amount = this.noise() * 255,
	            data = imageData.data,
	            nPixels = data.length,
	            half = amount / 2,
	            i;
	
	        for (i = 0; i < nPixels; i += 4) {
	            data[i + 0] += half - 2 * half * Math.random();
	            data[i + 1] += half - 2 * half * Math.random();
	            data[i + 2] += half - 2 * half * Math.random();
	        }
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'noise', 0.2, null, Konva.Factory.afterSetFilter);
	
	    /**
	    * get/set noise amount.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Noise} filter.
	    * @name noise
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} noise
	    * @returns {Number}
	    */
	})();
	
	/*eslint-disable max-depth */
	(function () {
	    'use strict';
	    /**
	     * Pixelate Filter. Averages groups of pixels and redraws
	     *  them as larger pixels
	     * @function
	     * @name Pixelate
	     * @memberof Konva.Filters
	     * @param {Object} imageData
	     * @author ippo615
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.Pixelate]);
	     * node.pixelSize(10);
	     */
	
	    Konva.Filters.Pixelate = function (imageData) {
	
	        var pixelSize = Math.ceil(this.pixelSize()),
	            width = imageData.width,
	            height = imageData.height,
	            x, y, i,
	            //pixelsPerBin = pixelSize * pixelSize,
	            red, green, blue, alpha,
	            nBinsX = Math.ceil(width / pixelSize),
	            nBinsY = Math.ceil(height / pixelSize),
	            xBinStart, xBinEnd, yBinStart, yBinEnd,
	            xBin, yBin, pixelsInBin;
	        imageData = imageData.data;
	
	        if (pixelSize <= 0) {
	            Konva.Util.error('pixelSize value can not be <= 0');
	            return;
	        }
	
	        for (xBin = 0; xBin < nBinsX; xBin += 1) {
	            for (yBin = 0; yBin < nBinsY; yBin += 1) {
	
	                // Initialize the color accumlators to 0
	                red = 0;
	                green = 0;
	                blue = 0;
	                alpha = 0;
	
	                // Determine which pixels are included in this bin
	                xBinStart = xBin * pixelSize;
	                xBinEnd = xBinStart + pixelSize;
	                yBinStart = yBin * pixelSize;
	                yBinEnd = yBinStart + pixelSize;
	
	                // Add all of the pixels to this bin!
	                pixelsInBin = 0;
	                for (x = xBinStart; x < xBinEnd; x += 1) {
	                    if( x >= width ){ continue; }
	                    for (y = yBinStart; y < yBinEnd; y += 1) {
	                        if( y >= height ){ continue; }
	                        i = (width * y + x) * 4;
	                        red += imageData[i + 0];
	                        green += imageData[i + 1];
	                        blue += imageData[i + 2];
	                        alpha += imageData[i + 3];
	                        pixelsInBin += 1;
	                    }
	                }
	
	                // Make sure the channels are between 0-255
	                red = red / pixelsInBin;
	                green = green / pixelsInBin;
	                blue = blue / pixelsInBin;
	
	                // Draw this bin
	                for (x = xBinStart; x < xBinEnd; x += 1) {
	                    if( x >= width ){ continue; }
	                    for (y = yBinStart; y < yBinEnd; y += 1) {
	                        if( y >= height ){ continue; }
	                        i = (width * y + x) * 4;
	                        imageData[i + 0] = red;
	                        imageData[i + 1] = green;
	                        imageData[i + 2] = blue;
	                        imageData[i + 3] = alpha;
	                    }
	                }
	            }
	        }
	
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'pixelSize', 8, null, Konva.Factory.afterSetFilter);
	
	    /**
	    * get/set pixel size. Use with {@link Konva.Filters.Pixelate} filter.
	    * @name pixelSize
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Integer} pixelSize
	    * @returns {Integer}
	    */
	})();
	
	(function () {
	    'use strict';
	    /**
	     * Threshold Filter. Pushes any value above the mid point to
	     *  the max and any value below the mid point to the min.
	     *  This affects the alpha channel.
	     * @function
	     * @name Threshold
	     * @memberof Konva.Filters
	     * @param {Object} imageData
	     * @author ippo615
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.Threshold]);
	     * node.threshold(0.1);
	     */
	
	    Konva.Filters.Threshold = function (imageData) {
	        var level = this.threshold() * 255,
	            data = imageData.data,
	            len = data.length,
	            i;
	
	        for (i = 0; i < len; i += 1) {
	            data[i] = data[i] < level ? 0 : 255;
	        }
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'threshold', 0.5, null, Konva.Factory.afterSetFilter);
	
	    /**
	    * get/set threshold.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Threshold} or {@link Konva.Filters.Mask} filter.
	    * @name threshold
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Number} threshold
	    * @returns {Number}
	    */
	})();
	
	(function() {
	    'use strict';
	    /**
	     * Sepia Filter
	     * Based on: Pixastic Lib - Sepia filter - v0.1.0
	     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
	     * @function
	     * @name Sepia
	     * @memberof Konva.Filters
	     * @param {Object} imageData
	     * @author Jacob Seidelin <jseidelin@nihilogic.dk>
	     * @license MPL v1.1 [http://www.pixastic.com/lib/license.txt]
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.Sepia]);
	     */
	    Konva.Filters.Sepia = function (imageData) {
	        var data = imageData.data,
	            w = imageData.width,
	            y = imageData.height,
	            w4 = w * 4,
	            offsetY, x, offset, or, og, ob, r, g, b;
	
	        do {
	            offsetY = (y - 1) * w4;
	            x = w;
	            do {
	                offset = offsetY + (x - 1) * 4;
	
	                or = data[offset];
	                og = data[offset + 1];
	                ob = data[offset + 2];
	
	                r = or * 0.393 + og * 0.769 + ob * 0.189;
	                g = or * 0.349 + og * 0.686 + ob * 0.168;
	                b = or * 0.272 + og * 0.534 + ob * 0.131;
	
	                data[offset] = r > 255 ? 255 : r;
	                data[offset + 1] = g > 255 ? 255 : g;
	                data[offset + 2] = b > 255 ? 255 : b;
	                data[offset + 3] = data[offset + 3];
	            } while (--x);
	        } while (--y);
	    };
	})();
	
	(function () {
	    'use strict';
	    /**
	     * Solarize Filter
	     * Pixastic Lib - Solarize filter - v0.1.0
	     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
	     * License: [http://www.pixastic.com/lib/license.txt]
	     * @function
	     * @name Solarize
	     * @memberof Konva.Filters
	     * @param {Object} imageData
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.Solarize]);
	     */
	    Konva.Filters.Solarize = function (imageData) {
	        var data = imageData.data,
	            w = imageData.width,
	            h = imageData.height,
	            w4 = w * 4,
	            y = h;
	
	        do {
	            var offsetY = (y - 1) * w4;
	            var x = w;
	            do {
	                var offset = offsetY + (x - 1) * 4;
	                var r = data[offset];
	                var g = data[offset + 1];
	                var b = data[offset + 2];
	
	                if (r > 127) {
	                    r = 255 - r;
	                }
	                if (g > 127) {
	                    g = 255 - g;
	                }
	                if (b > 127) {
	                    b = 255 - b;
	                }
	
	                data[offset] = r;
	                data[offset + 1] = g;
	                data[offset + 2] = b;
	            } while (--x);
	        } while (--y);
	    };
	})();
	
	
	
	(function () {
	    'use strict';
	
	  /*
	   * ToPolar Filter. Converts image data to polar coordinates. Performs
	   *  w*h*4 pixel reads and w*h pixel writes. The r axis is placed along
	   *  what would be the y axis and the theta axis along the x axis.
	   * @function
	   * @author ippo615
	   * @memberof Konva.Filters
	   * @param {ImageData} src, the source image data (what will be transformed)
	   * @param {ImageData} dst, the destination image data (where it will be saved)
	   * @param {Object} opt
	   * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
	   *  default is in the middle
	   * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
	   *  default is in the middle
	   */
	
	    var ToPolar = function(src, dst, opt){
	
	        var srcPixels = src.data,
	            dstPixels = dst.data,
	            xSize = src.width,
	            ySize = src.height,
	            xMid = opt.polarCenterX || xSize / 2,
	            yMid = opt.polarCenterY || ySize / 2,
	            i, x, y, r = 0, g = 0, b = 0, a = 0;
	
	        // Find the largest radius
	        var rad, rMax = Math.sqrt( xMid * xMid + yMid * yMid );
	        x = xSize - xMid;
	        y = ySize - yMid;
	        rad = Math.sqrt( x * x + y * y );
	        rMax = (rad > rMax) ? rad : rMax;
	
	        // We'll be uisng y as the radius, and x as the angle (theta=t)
	        var rSize = ySize,
	            tSize = xSize,
	            radius, theta;
	
	        // We want to cover all angles (0-360) and we need to convert to
	        // radians (*PI/180)
	        var conversion = 360 / tSize * Math.PI / 180, sin, cos;
	
	        // var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;
	
	        for( theta = 0; theta < tSize; theta += 1 ){
	            sin = Math.sin(theta * conversion);
	            cos = Math.cos(theta * conversion);
	            for( radius = 0; radius < rSize; radius += 1 ){
	                x = Math.floor(xMid + rMax * radius / rSize * cos);
	                y = Math.floor(yMid + rMax * radius / rSize * sin);
	                i = (y * xSize + x) * 4;
	                r = srcPixels[i + 0];
	                g = srcPixels[i + 1];
	                b = srcPixels[i + 2];
	                a = srcPixels[i + 3];
	
	                // Store it
	                //i = (theta * xSize  +  radius) * 4;
	                i = (theta + radius * xSize) * 4;
	                dstPixels[i + 0] = r;
	                dstPixels[i + 1] = g;
	                dstPixels[i + 2] = b;
	                dstPixels[i + 3] = a;
	
	            }
	        }
	    };
	
	    /*
	     * FromPolar Filter. Converts image data from polar coordinates back to rectangular.
	     *  Performs w*h*4 pixel reads and w*h pixel writes.
	     * @function
	     * @author ippo615
	     * @memberof Konva.Filters
	     * @param {ImageData} src, the source image data (what will be transformed)
	     * @param {ImageData} dst, the destination image data (where it will be saved)
	     * @param {Object} opt
	     * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
	     *  default is in the middle
	     * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
	     *  default is in the middle
	     * @param {Number} [opt.polarRotation] amount to rotate the image counterclockwis,
	     *  0 is no rotation, 360 degrees is a full rotation
	     */
	
	    var FromPolar = function(src, dst, opt){
	
	        var srcPixels = src.data,
	            dstPixels = dst.data,
	            xSize = src.width,
	            ySize = src.height,
	            xMid = opt.polarCenterX || xSize / 2,
	            yMid = opt.polarCenterY || ySize / 2,
	            i, x, y, dx, dy, r = 0, g = 0, b = 0, a = 0;
	
	
	        // Find the largest radius
	        var rad, rMax = Math.sqrt( xMid * xMid + yMid * yMid );
	        x = xSize - xMid;
	        y = ySize - yMid;
	        rad = Math.sqrt( x * x + y * y );
	        rMax = (rad > rMax) ? rad : rMax;
	
	        // We'll be uisng x as the radius, and y as the angle (theta=t)
	        var rSize = ySize,
	        tSize = xSize,
	        radius, theta,
	        phaseShift = opt.polarRotation || 0;
	
	        // We need to convert to degrees and we need to make sure
	        // it's between (0-360)
	        // var conversion = tSize/360*180/Math.PI;
	        //var conversion = tSize/360*180/Math.PI;
	
	        var x1, y1;
	
	        for( x = 0; x < xSize; x += 1 ){
	            for( y = 0; y < ySize; y += 1 ){
	                dx = x - xMid;
	                dy = y - yMid;
	                radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
	                theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
	                theta = theta * tSize / 360;
	                x1 = Math.floor(theta);
	                y1 = Math.floor(radius);
	                i = (y1 * xSize + x1) * 4;
	                r = srcPixels[i + 0];
	                g = srcPixels[i + 1];
	                b = srcPixels[i + 2];
	                a = srcPixels[i + 3];
	
	                // Store it
	                i = (y * xSize + x) * 4;
	                dstPixels[i + 0] = r;
	                dstPixels[i + 1] = g;
	                dstPixels[i + 2] = b;
	                dstPixels[i + 3] = a;
	            }
	        }
	
	    };
	
	    //Konva.Filters.ToPolar = Konva.Util._FilterWrapDoubleBuffer(ToPolar);
	    //Konva.Filters.FromPolar = Konva.Util._FilterWrapDoubleBuffer(FromPolar);
	
	    // create a temporary canvas for working - shared between multiple calls
	    var tempCanvas = Konva.Util.createCanvasElement();
	
	    /*
	     * Kaleidoscope Filter.
	     * @function
	     * @name Kaleidoscope
	     * @author ippo615
	     * @memberof Konva.Filters
	     * @example
	     * node.cache();
	     * node.filters([Konva.Filters.Kaleidoscope]);
	     * node.kaleidoscopePower(3);
	     * node.kaleidoscopeAngle(45);
	     */
	    Konva.Filters.Kaleidoscope = function(imageData){
	        var xSize = imageData.width,
	            ySize = imageData.height;
	
	        var x, y, xoff, i, r, g, b, a, srcPos, dstPos;
	        var power = Math.round( this.kaleidoscopePower() );
	        var angle = Math.round( this.kaleidoscopeAngle() );
	        var offset = Math.floor(xSize * (angle % 360) / 360);
	
	        if( power < 1 ){return; }
	
	        // Work with our shared buffer canvas
	        tempCanvas.width = xSize;
	        tempCanvas.height = ySize;
	        var scratchData = tempCanvas.getContext('2d').getImageData(0, 0, xSize, ySize);
	
	        // Convert thhe original to polar coordinates
	        ToPolar( imageData, scratchData, {
	            polarCenterX: xSize / 2,
	            polarCenterY: ySize / 2
	        });
	
	        // Determine how big each section will be, if it's too small
	        // make it bigger
	        var minSectionSize = xSize / Math.pow(2, power);
	        while( minSectionSize <= 8){
	            minSectionSize = minSectionSize * 2;
	            power -= 1;
	        }
	        minSectionSize = Math.ceil(minSectionSize);
	        var sectionSize = minSectionSize;
	
	        // Copy the offset region to 0
	        // Depending on the size of filter and location of the offset we may need
	        // to copy the section backwards to prevent it from rewriting itself
	        var xStart = 0,
	          xEnd = sectionSize,
	          xDelta = 1;
	        if( offset + minSectionSize > xSize ){
	            xStart = sectionSize;
	            xEnd = 0;
	            xDelta = -1;
	        }
	        for( y = 0; y < ySize; y += 1 ){
	            for( x = xStart; x !== xEnd; x += xDelta ){
	                xoff = Math.round(x + offset) % xSize;
	                srcPos = (xSize * y + xoff) * 4;
	                r = scratchData.data[srcPos + 0];
	                g = scratchData.data[srcPos + 1];
	                b = scratchData.data[srcPos + 2];
	                a = scratchData.data[srcPos + 3];
	                dstPos = (xSize * y + x) * 4;
	                scratchData.data[dstPos + 0] = r;
	                scratchData.data[dstPos + 1] = g;
	                scratchData.data[dstPos + 2] = b;
	                scratchData.data[dstPos + 3] = a;
	            }
	        }
	
	        // Perform the actual effect
	        for( y = 0; y < ySize; y += 1 ){
	            sectionSize = Math.floor( minSectionSize );
	            for( i = 0; i < power; i += 1 ){
	                for( x = 0; x < sectionSize + 1; x += 1 ){
	                    srcPos = (xSize * y + x) * 4;
	                    r = scratchData.data[srcPos + 0];
	                    g = scratchData.data[srcPos + 1];
	                    b = scratchData.data[srcPos + 2];
	                    a = scratchData.data[srcPos + 3];
	                    dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
	                    scratchData.data[dstPos + 0] = r;
	                    scratchData.data[dstPos + 1] = g;
	                    scratchData.data[dstPos + 2] = b;
	                    scratchData.data[dstPos + 3] = a;
	                }
	                sectionSize *= 2;
	            }
	        }
	
	        // Convert back from polar coordinates
	        FromPolar(scratchData, imageData, {polarRotation: 0});
	    };
	
	    /**
	    * get/set kaleidoscope power. Use with {@link Konva.Filters.Kaleidoscope} filter.
	    * @name kaleidoscopePower
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Integer} power of kaleidoscope
	    * @returns {Integer}
	    */
	    Konva.Factory.addGetterSetter(Konva.Node, 'kaleidoscopePower', 2, null, Konva.Factory.afterSetFilter);
	
	    /**
	    * get/set kaleidoscope angle. Use with {@link Konva.Filters.Kaleidoscope} filter.
	    * @name kaleidoscopeAngle
	    * @method
	    * @memberof Konva.Node.prototype
	    * @param {Integer} degrees
	    * @returns {Integer}
	    */
	    Konva.Factory.addGetterSetter(Konva.Node, 'kaleidoscopeAngle', 0, null, Konva.Factory.afterSetFilter);
	
	})();
	
	(function() {
	    'use strict';
	    /**
	     * Container constructor.&nbsp; Containers are used to contain nodes or other containers
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Node
	     * @abstract
	     * @param {Object} config
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * * @param {Object} [config.clip] set clip
	     * @param {Number} [config.clipX] set clip x
	     * @param {Number} [config.clipY] set clip y
	     * @param {Number} [config.clipWidth] set clip width
	     * @param {Number} [config.clipHeight] set clip height
	     * @param {Function} [config.clipFunc] set clip func
	
	     */
	    Konva.Container = function(config) {
	        this.__init(config);
	    };
	
	    Konva.Util.addMethods(Konva.Container, {
	        __init: function(config) {
	            this.children = new Konva.Collection();
	            Konva.Node.call(this, config);
	        },
	        /**
	         * returns a {@link Konva.Collection} of direct descendant nodes
	         * @method
	         * @memberof Konva.Container.prototype
	         * @param {Function} [filterFunc] filter function
	         * @returns {Konva.Collection}
	         * @example
	         * // get all children
	         * var children = layer.getChildren();
	         *
	         * // get only circles
	         * var circles = layer.getChildren(function(node){
	         *    return node.getClassName() === 'Circle';
	         * });
	         */
	        getChildren: function(filterFunc) {
	            if (!filterFunc) {
	                return this.children;
	            }
	
	            var results = new Konva.Collection();
	            this.children.each(function(child){
	                if (filterFunc(child)) {
	                    results.push(child);
	                }
	            });
	            return results;
	        },
	        /**
	         * determine if node has children
	         * @method
	         * @memberof Konva.Container.prototype
	         * @returns {Boolean}
	         */
	        hasChildren: function() {
	            return this.getChildren().length > 0;
	        },
	        /**
	         * remove all children
	         * @method
	         * @memberof Konva.Container.prototype
	         */
	        removeChildren: function() {
	            var children = Konva.Collection.toCollection(this.children);
	            var child;
	            for (var i = 0; i < children.length; i++) {
	                child = children[i];
	                // reset parent to prevent many _setChildrenIndices calls
	                delete child.parent;
	                child.index = 0;
	                child.remove();
	            }
	            children = null;
	            this.children = new Konva.Collection();
	            return this;
	        },
	        /**
	         * destroy all children
	         * @method
	         * @memberof Konva.Container.prototype
	         */
	        destroyChildren: function() {
	           var children = Konva.Collection.toCollection(this.children);
	            var child;
	            for (var i = 0; i < children.length; i++) {
	                child = children[i];
	                // reset parent to prevent many _setChildrenIndices calls
	                delete child.parent;
	                child.index = 0;
	                child.destroy();
	            }
	            children = null;
	            this.children = new Konva.Collection();
	            return this;
	        },
	        /**
	         * Add node or nodes to container.
	         * @method
	         * @memberof Konva.Container.prototype
	         * @param {...Konva.Node} child
	         * @returns {Container}
	         * @example
	         * layer.add(shape1, shape2, shape3);
	         */
	        add: function(child) {
	            if (arguments.length > 1) {
	                for (var i = 0; i < arguments.length; i++) {
	                    this.add(arguments[i]);
	                }
	                return this;
	            }
	            if (child.getParent()) {
	                child.moveTo(this);
	                return this;
	            }
	            var children = this.children;
	            this._validateAdd(child);
	            child.index = children.length;
	            child.parent = this;
	            children.push(child);
	            this._fire('add', {
	                child: child
	            });
	
	            // if node under drag we need to update drag animation
	            if (Konva.DD && child.isDragging()) {
	                Konva.DD.anim.setLayers(child.getLayer());
	            }
	
	            // chainable
	            return this;
	        },
	        destroy: function() {
	            // destroy children
	            if (this.hasChildren()) {
	                this.destroyChildren();
	            }
	            // then destroy self
	            Konva.Node.prototype.destroy.call(this);
	            return this;
	        },
	        /**
	         * return a {@link Konva.Collection} of nodes that match the selector.  Use '#' for id selections
	         * and '.' for name selections.  You can also select by type or class name. Pass multiple selectors
	         * separated by a space.
	         * @method
	         * @memberof Konva.Container.prototype
	         * @param {String} selector
	         * @returns {Collection}
	         * @example
	         * // select node with id foo
	         * var node = stage.find('#foo');
	         *
	         * // select nodes with name bar inside layer
	         * var nodes = layer.find('.bar');
	         *
	         * // select all groups inside layer
	         * var nodes = layer.find('Group');
	         *
	         * // select all rectangles inside layer
	         * var nodes = layer.find('Rect');
	         *
	         * // select node with an id of foo or a name of bar inside layer
	         * var nodes = layer.find('#foo, .bar');
	         */
	        find: function(selector) {
	            var retArr = [],
	                selectorArr = selector.replace(/ /g, '').split(','),
	                len = selectorArr.length,
	                n, i, sel, arr, node, children, clen;
	
	            for (n = 0; n < len; n++) {
	                sel = selectorArr[n];
	                if (!Konva.Util.isValidSelector(sel)) {
	                    Konva.Util.warn('Selector "' + sel + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".');
	                    Konva.Util.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".');
	                    Konva.Util.warn('Konva is awesome, right?');
	                }
	                // id selector
	                if(sel.charAt(0) === '#') {
	                    node = this._getNodeById(sel.slice(1));
	                    if(node) {
	                        retArr.push(node);
	                    }
	                }
	                // name selector
	                else if(sel.charAt(0) === '.') {
	                    arr = this._getNodesByName(sel.slice(1));
	                    retArr = retArr.concat(arr);
	                }
	                // unrecognized selector, pass to children
	                else {
	                    children = this.getChildren();
	                    clen = children.length;
	                    for(i = 0; i < clen; i++) {
	                        retArr = retArr.concat(children[i]._get(sel));
	                    }
	                }
	            }
	
	            return Konva.Collection.toCollection(retArr);
	        },
	        /**
	         * return a first node from `find` method
	         * @method
	         * @memberof Konva.Container.prototype
	         * @param {String} selector
	         * @returns {Konva.Node}
	         * @example
	         * // select node with id foo
	         * var node = stage.findOne('#foo');
	         *
	         * // select node with name bar inside layer
	         * var nodes = layer.findOne('.bar');
	         */
	        findOne: function(selector) {
	            return this.find(selector)[0];
	        },
	        _getNodeById: function(key) {
	            var node = Konva.ids[key];
	
	            if(node !== undefined && this.isAncestorOf(node)) {
	                return node;
	            }
	            return null;
	        },
	        _getNodesByName: function(key) {
	            var arr = Konva.names[key] || [];
	            return this._getDescendants(arr);
	        },
	        _get: function(selector) {
	            var retArr = Konva.Node.prototype._get.call(this, selector);
	            var children = this.getChildren();
	            var len = children.length;
	            for(var n = 0; n < len; n++) {
	                retArr = retArr.concat(children[n]._get(selector));
	            }
	            return retArr;
	        },
	        // extenders
	        toObject: function() {
	            var obj = Konva.Node.prototype.toObject.call(this);
	
	            obj.children = [];
	
	            var children = this.getChildren();
	            var len = children.length;
	            for(var n = 0; n < len; n++) {
	                var child = children[n];
	                obj.children.push(child.toObject());
	            }
	
	            return obj;
	        },
	        _getDescendants: function(arr) {
	            var retArr = [];
	            var len = arr.length;
	            for(var n = 0; n < len; n++) {
	                var node = arr[n];
	                if(this.isAncestorOf(node)) {
	                    retArr.push(node);
	                }
	            }
	
	            return retArr;
	        },
	        /**
	         * determine if node is an ancestor
	         * of descendant
	         * @method
	         * @memberof Konva.Container.prototype
	         * @param {Konva.Node} node
	         */
	        isAncestorOf: function(node) {
	            var parent = node.getParent();
	            while(parent) {
	                if(parent._id === this._id) {
	                    return true;
	                }
	                parent = parent.getParent();
	            }
	
	            return false;
	        },
	        clone: function(obj) {
	            // call super method
	            var node = Konva.Node.prototype.clone.call(this, obj);
	
	            this.getChildren().each(function(no) {
	                node.add(no.clone());
	            });
	            return node;
	        },
	        /**
	         * get all shapes that intersect a point.  Note: because this method must clear a temporary
	         * canvas and redraw every shape inside the container, it should only be used for special sitations
	         * because it performs very poorly.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
	         * because it performs much better
	         * @method
	         * @memberof Konva.Container.prototype
	         * @param {Object} pos
	         * @param {Number} pos.x
	         * @param {Number} pos.y
	         * @returns {Array} array of shapes
	         */
	        getAllIntersections: function(pos) {
	            var arr = [];
	
	            this.find('Shape').each(function(shape) {
	                if(shape.isVisible() && shape.intersects(pos)) {
	                    arr.push(shape);
	                }
	            });
	
	            return arr;
	        },
	        _setChildrenIndices: function() {
	            this.children.each(function(child, n) {
	                child.index = n;
	            });
	        },
	        drawScene: function(can, top, caching) {
	            var layer = this.getLayer(),
	                canvas = can || (layer && layer.getCanvas()),
	                context = canvas && canvas.getContext(),
	                cachedCanvas = this._cache.canvas,
	                cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;
	
	            if (this.isVisible()) {
	                if (!caching && cachedSceneCanvas) {
	                    context.save();
	                    layer._applyTransform(this, context, top);
	                    this._drawCachedSceneCanvas(context);
	                    context.restore();
	                }
	                else {
	                    this._drawChildren(canvas, 'drawScene', top, false, caching);
	                }
	            }
	            return this;
	        },
	        drawHit: function(can, top, caching) {
	            var layer = this.getLayer(),
	                canvas = can || (layer && layer.hitCanvas),
	                context = canvas && canvas.getContext(),
	                cachedCanvas = this._cache.canvas,
	                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
	
	            if (this.shouldDrawHit(canvas)) {
	                if (layer) {
	                    layer.clearHitCache();
	                }
	                if (!caching && cachedHitCanvas) {
	                    context.save();
	                    layer._applyTransform(this, context, top);
	                    this._drawCachedHitCanvas(context);
	                    context.restore();
	                }
	                else {
	                    this._drawChildren(canvas, 'drawHit', top);
	                }
	            }
	            return this;
	        },
	        _drawChildren: function(canvas, drawMethod, top, caching, skipBuffer) {
	            var layer = this.getLayer(),
	                context = canvas && canvas.getContext(),
	                clipWidth = this.getClipWidth(),
	                clipHeight = this.getClipHeight(),
	                clipFunc = this.getClipFunc(),
	                hasClip = clipWidth && clipHeight || clipFunc,
	                clipX, clipY;
	
	            if (hasClip && layer) {
	                context.save();
	                layer._applyTransform(this, context);
	                context.beginPath();
	                if (clipFunc) {
	                  clipFunc.call(this, context, this);
	                } else {
	                  clipX = this.getClipX();
	                  clipY = this.getClipY();
	                  context.rect(clipX, clipY, clipWidth, clipHeight);
	                }
	                context.clip();
	                context.reset();
	            }
	
	            this.children.each(function(child) {
	                child[drawMethod](canvas, top, caching, skipBuffer);
	            });
	
	            if (hasClip) {
	                context.restore();
	            }
	        },
	        shouldDrawHit: function(canvas) {
	            var layer = this.getLayer();
	            var dd = Konva.DD;
	            var layerUnderDrag = dd && Konva.isDragging() && (Konva.DD.anim.getLayers().indexOf(layer) !== -1);
	            return (canvas && canvas.isCache) || (layer && layer.hitGraphEnabled())
	                && this.isVisible() && !layerUnderDrag;
	        },
	        getClientRect: function(skipTransform) {
	            var minX, minY, maxX, maxY;
	            var selfRect = {
	                x: 0,
	                y: 0,
	                width: 0,
	                height: 0
	            };
	            this.children.each(function(child) {
	                var rect = child.getClientRect();
	
	                // skip invisible children (like empty groups)
	                // or don't skip... hmmm...
	                // if (rect.width === 0 && rect.height === 0) {
	                //     return;
	                // }
	
	                if (minX === undefined) { // initial value for first child
	                    minX = rect.x;
	                    minY = rect.y;
	                    maxX = rect.x + rect.width;
	                    maxY = rect.y + rect.height;
	                } else {
	                    minX = Math.min(minX, rect.x);
	                    minY = Math.min(minY, rect.y);
	                    maxX = Math.max(maxX, rect.x + rect.width);
	                    maxY = Math.max(maxY, rect.y + rect.height);
	                }
	
	            });
	
	            if (this.children.length !== 0) {
	                selfRect = {
	                    x: minX,
	                    y: minY,
	                    width: maxX - minX,
	                    height: maxY - minY
	                };
	            }
	
	            if (!skipTransform) {
	                return this._transformedRect(selfRect);
	            }
	            return selfRect;
	        }
	    });
	
	    Konva.Util.extend(Konva.Container, Konva.Node);
	    // deprecated methods
	    Konva.Container.prototype.get = Konva.Container.prototype.find;
	
	    // add getters setters
	    Konva.Factory.addComponentsGetterSetter(Konva.Container, 'clip', ['x', 'y', 'width', 'height']);
	    /**
	     * get/set clip
	     * @method
	     * @name clip
	     * @memberof Konva.Container.prototype
	     * @param {Object} clip
	     * @param {Number} clip.x
	     * @param {Number} clip.y
	     * @param {Number} clip.width
	     * @param {Number} clip.height
	     * @returns {Object}
	     * @example
	     * // get clip
	     * var clip = container.clip();
	     *
	     * // set clip
	     * container.setClip({
	     *   x: 20,
	     *   y: 20,
	     *   width: 20,
	     *   height: 20
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Container, 'clipX');
	    /**
	     * get/set clip x
	     * @name clipX
	     * @method
	     * @memberof Konva.Container.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get clip x
	     * var clipX = container.clipX();
	     *
	     * // set clip x
	     * container.clipX(10);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Container, 'clipY');
	    /**
	     * get/set clip y
	     * @name clipY
	     * @method
	     * @memberof Konva.Container.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get clip y
	     * var clipY = container.clipY();
	     *
	     * // set clip y
	     * container.clipY(10);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Container, 'clipWidth');
	    /**
	     * get/set clip width
	     * @name clipWidth
	     * @method
	     * @memberof Konva.Container.prototype
	     * @param {Number} width
	     * @returns {Number}
	     * @example
	     * // get clip width
	     * var clipWidth = container.clipWidth();
	     *
	     * // set clip width
	     * container.clipWidth(100);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Container, 'clipHeight');
	    /**
	     * get/set clip height
	     * @name clipHeight
	     * @method
	     * @memberof Konva.Container.prototype
	     * @param {Number} height
	     * @returns {Number}
	     * @example
	     * // get clip height
	     * var clipHeight = container.clipHeight();
	     *
	     * // set clip height
	     * container.clipHeight(100);
	     */
	
	     Konva.Factory.addGetterSetter(Konva.Container, 'clipFunc');
	     /**
	      * get/set clip function
	      * @name clipFunc
	      * @method
	      * @memberof Konva.Container.prototype
	      * @param {Function} function
	      * @returns {Function}
	      * @example
	      * // get clip function
	      * var clipFunction = container.clipFunc();
	      *
	      * // set clip height
	      * container.clipFunc(function(ctx) {
	      *   ctx.rect(0, 0, 100, 100);
	      * });
	      */
	
	    Konva.Collection.mapMethods(Konva.Container);
	})();
	
	(function(Konva) {
	    'use strict';
	    var HAS_SHADOW = 'hasShadow';
	    var SHADOW_RGBA = 'shadowRGBA';
	
	    function _fillFunc(context) {
	        context.fill();
	    }
	    function _strokeFunc(context) {
	        context.stroke();
	    }
	    function _fillFuncHit(context) {
	        context.fill();
	    }
	    function _strokeFuncHit(context) {
	        context.stroke();
	    }
	
	    function _clearHasShadowCache() {
	        this._clearCache(HAS_SHADOW);
	    }
	
	    function _clearGetShadowRGBACache() {
	        this._clearCache(SHADOW_RGBA);
	    }
	
	    /**
	     * Shape constructor.  Shapes are primitive objects such as rectangles,
	     *  circles, text, lines, etc.
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Node
	     * @param {Object} config
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var customShape = new Konva.Shape({
	         *   x: 5,
	         *   y: 10,
	         *   fill: 'red',
	         *   // a Konva.Canvas renderer is passed into the drawFunc function
	         *   drawFunc: function(context) {
	         *     context.beginPath();
	         *     context.moveTo(200, 50);
	         *     context.lineTo(420, 80);
	         *     context.quadraticCurveTo(300, 100, 260, 170);
	         *     context.closePath();
	         *     context.fillStrokeShape(this);
	         *   }
	         *});
	     */
	    Konva.Shape = function(config) {
	        this.__init(config);
	    };
	
	    Konva.Util.addMethods(Konva.Shape, {
	        __init: function(config) {
	            this.nodeType = 'Shape';
	            this._fillFunc = _fillFunc;
	            this._strokeFunc = _strokeFunc;
	            this._fillFuncHit = _fillFuncHit;
	            this._strokeFuncHit = _strokeFuncHit;
	
	            // set colorKey
	            var shapes = Konva.shapes;
	            var key;
	
	            while(true) {
	                key = Konva.Util.getRandomColor();
	                if(key && !( key in shapes)) {
	                    break;
	                }
	            }
	
	            this.colorKey = key;
	            shapes[key] = this;
	
	            // call super constructor
	            Konva.Node.call(this, config);
	
	            this.on('shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);
	
	            this.on('shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);
	        },
	        hasChildren: function() {
	            return false;
	        },
	        getChildren: function() {
	            return [];
	        },
	        /**
	         * get canvas context tied to the layer
	         * @method
	         * @memberof Konva.Shape.prototype
	         * @returns {Konva.Context}
	         */
	        getContext: function() {
	            return this.getLayer().getContext();
	        },
	        /**
	         * get canvas renderer tied to the layer.  Note that this returns a canvas renderer, not a canvas element
	         * @method
	         * @memberof Konva.Shape.prototype
	         * @returns {Konva.Canvas}
	         */
	        getCanvas: function() {
	            return this.getLayer().getCanvas();
	        },
	        /**
	         * returns whether or not a shadow will be rendered
	         * @method
	         * @memberof Konva.Shape.prototype
	         * @returns {Boolean}
	         */
	        hasShadow: function() {
	            return this._getCache(HAS_SHADOW, this._hasShadow);
	        },
	        _hasShadow: function() {
	            return this.getShadowEnabled() && (this.getShadowOpacity() !== 0 && !!(this.getShadowColor() || this.getShadowBlur() || this.getShadowOffsetX() || this.getShadowOffsetY()));
	        },
	        getShadowRGBA: function() {
	            return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
	        },
	        _getShadowRGBA: function() {
	            if (this.hasShadow()) {
	                var rgba = Konva.Util.colorToRGBA(this.shadowColor());
	                return 'rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + (rgba.a * (this.getShadowOpacity() || 1)) + ')';
	            }
	        },
	        /**
	         * returns whether or not the shape will be filled
	         * @method
	         * @memberof Konva.Shape.prototype
	         * @returns {Boolean}
	         */
	        hasFill: function() {
	            return !!(this.getFill() || this.getFillPatternImage() || this.getFillLinearGradientColorStops() || this.getFillRadialGradientColorStops());
	        },
	        /**
	         * returns whether or not the shape will be stroked
	         * @method
	         * @memberof Konva.Shape.prototype
	         * @returns {Boolean}
	         */
	        hasStroke: function() {
	            return this.strokeEnabled() && !!(this.stroke());
	        },
	        /**
	         * determines if point is in the shape, regardless if other shapes are on top of it.  Note: because
	         *  this method clears a temporary canvas and then redraws the shape, it performs very poorly if executed many times
	         *  consecutively.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
	         *  because it performs much better
	         * @method
	         * @memberof Konva.Shape.prototype
	         * @param {Object} point
	         * @param {Number} point.x
	         * @param {Number} point.y
	         * @returns {Boolean}
	         */
	        intersects: function(point) {
	            var stage = this.getStage(),
	                bufferHitCanvas = stage.bufferHitCanvas,
	                p;
	
	            bufferHitCanvas.getContext().clear();
	            this.drawScene(bufferHitCanvas);
	            p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;
	            return p[3] > 0;
	        },
	        // extends Node.prototype.destroy
	        destroy: function() {
	            Konva.Node.prototype.destroy.call(this);
	            delete Konva.shapes[this.colorKey];
	            return this;
	        },
	        _useBufferCanvas: function(caching) {
	            return !caching && (this.perfectDrawEnabled() && (this.getAbsoluteOpacity() !== 1) && this.hasFill() && this.hasStroke() && this.getStage()) ||
	                   (this.perfectDrawEnabled() && this.hasShadow() && (this.getAbsoluteOpacity() !== 1) && this.hasFill() && this.hasStroke() && this.getStage());
	        },
	        /**
	         * return self rectangle (x, y, width, height) of shape.
	         * This method are not taken into account transformation and styles.
	         * @method
	         * @memberof Konva.Shape.prototype
	         * @returns {Object} rect with {x, y, width, height} properties
	         * @example
	         *
	         * rect.getSelfRect();  // return {x:0, y:0, width:rect.width(), height:rect.height()}
	         * circle.getSelfRect();  // return {x: - circle.width() / 2, y: - circle.height() / 2, width:circle.width(), height:circle.height()}
	         *
	         */
	        getSelfRect: function() {
	            var size = this.getSize();
	            return {
	                x: this._centroid ? Math.round(-size.width / 2) : 0,
	                y: this._centroid ? Math.round(-size.height / 2) : 0,
	                width: size.width,
	                height: size.height
	            };
	        },
	        getClientRect: function(skipTransform) {
	            var fillRect = this.getSelfRect();
	
	            var strokeWidth = (this.hasStroke() && this.strokeWidth()) || 0;
	            var fillAndStrokeWidth = fillRect.width + strokeWidth;
	            var fillAndStrokeHeight = fillRect.height + strokeWidth;
	
	            var shadowOffsetX = this.hasShadow() ? this.shadowOffsetX() : 0;
	            var shadowOffsetY = this.hasShadow() ? this.shadowOffsetY() : 0;
	
	            var preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
	            var preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);
	
	            var blurRadius = (this.hasShadow() && this.shadowBlur() || 0);
	
	            var width = preWidth + blurRadius * 2;
	            var height = preHeight + blurRadius * 2;
	
	            // if stroke, for example = 3
	            // we need to set x to 1.5, but after Math.round it will be 2
	            // as we have additional offset we need to increase width and height by 1 pixel
	            var roundingOffset = 0;
	            if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {
	                roundingOffset = 1;
	            }
	            var rect = {
	                width: width + roundingOffset,
	                height: height + roundingOffset,
	                x: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,
	                y: -Math.round(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y
	            };
	            if (!skipTransform) {
	                return this._transformedRect(rect);
	            }
	            return rect;
	        },
	        drawScene: function(can, top, caching, skipBuffer) {
	            var layer = this.getLayer(),
	                canvas = can || layer.getCanvas(),
	                context = canvas.getContext(),
	                cachedCanvas = this._cache.canvas,
	                drawFunc = this.sceneFunc(),
	                hasShadow = this.hasShadow(),
	                hasStroke = this.hasStroke(),
	                stage, bufferCanvas, bufferContext;
	
	            if(!this.isVisible()) {
	                return this;
	            }
	            if (cachedCanvas) {
	                context.save();
	                layer._applyTransform(this, context, top);
	                this._drawCachedSceneCanvas(context);
	                context.restore();
	                return this;
	            }
	            if (!drawFunc) {
	                return this;
	            }
	            context.save();
	            // if buffer canvas is needed
	            if (this._useBufferCanvas(caching) && !skipBuffer) {
	                stage = this.getStage();
	                bufferCanvas = stage.bufferCanvas;
	                bufferContext = bufferCanvas.getContext();
	                bufferContext.clear();
	                bufferContext.save();
	                bufferContext._applyLineJoin(this);
	                // layer might be undefined if we are using cache before adding to layer
	                if (!caching) {
	                    if (layer) {
	                        layer._applyTransform(this, bufferContext, top);
	                    } else {
	                        var m = this.getAbsoluteTransform(top).getMatrix();
	                        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	                    }
	                }
	
	                drawFunc.call(this, bufferContext);
	                bufferContext.restore();
	
	                var ratio = bufferCanvas.pixelRatio;
	                if (hasShadow && !canvas.hitCanvas) {
	                        context.save();
	                        context._applyShadow(this);
	                        context._applyOpacity(this);
	                        context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);
	                        context.restore();
	                } else {
	                    context._applyOpacity(this);
	                    context.drawImage(bufferCanvas._canvas, 0, 0, bufferCanvas.width / ratio, bufferCanvas.height / ratio);
	                }
	            }
	            // if buffer canvas is not needed
	            else {
	                context._applyLineJoin(this);
	                // layer might be undefined if we are using cache before adding to layer
	                if (!caching) {
	                    if (layer) {
	                        layer._applyTransform(this, context, top);
	                    } else {
	                        var o = this.getAbsoluteTransform(top).getMatrix();
	                        context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
	                    }
	                }
	
	                if (hasShadow && hasStroke && !canvas.hitCanvas) {
	                    context.save();
	                    // apply shadow
	                    if (!caching) {
	                        context._applyOpacity(this);
	                    }
	                    context._applyShadow(this);
	                    drawFunc.call(this, context);
	                    context.restore();
	                    // if shape has stroke we need to redraw shape
	                    // otherwise we will see a shadow under stroke (and over fill)
	                    // but I think this is unexpected behavior
	                    if (this.hasFill() && this.getShadowForStrokeEnabled()) {
	                        drawFunc.call(this, context);
	                    }
	                } else if (hasShadow && !canvas.hitCanvas) {
	                    context.save();
	                    if (!caching) {
	                        context._applyOpacity(this);
	                    }
	                    context._applyShadow(this);
	                    drawFunc.call(this, context);
	                    context.restore();
	                } else {
	                    if (!caching) {
	                        context._applyOpacity(this);
	                    }
	                    drawFunc.call(this, context);
	                }
	            }
	            context.restore();
	            return this;
	        },
	        drawHit: function(can, top, caching) {
	            var layer = this.getLayer(),
	                canvas = can || layer.hitCanvas,
	                context = canvas.getContext(),
	                drawFunc = this.hitFunc() || this.sceneFunc(),
	                cachedCanvas = this._cache.canvas,
	                cachedHitCanvas = cachedCanvas && cachedCanvas.hit;
	
	            if(!this.shouldDrawHit(canvas)) {
	                return this;
	            }
	            if (layer) {
	                layer.clearHitCache();
	            }
	            if (cachedHitCanvas) {
	                context.save();
	                layer._applyTransform(this, context, top);
	                this._drawCachedHitCanvas(context);
	                context.restore();
	                return this;
	            }
	            if (!drawFunc) {
	                return this;
	            }
	            context.save();
	            context._applyLineJoin(this);
	            if (!caching) {
	                if (layer) {
	                    layer._applyTransform(this, context, top);
	                } else {
	                    var o = this.getAbsoluteTransform(top).getMatrix();
	                    context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
	                }
	            }
	            drawFunc.call(this, context);
	            context.restore();
	            return this;
	        },
	        /**
	        * draw hit graph using the cached scene canvas
	        * @method
	        * @memberof Konva.Shape.prototype
	        * @param {Integer} alphaThreshold alpha channel threshold that determines whether or not
	        *  a pixel should be drawn onto the hit graph.  Must be a value between 0 and 255.
	        *  The default is 0
	        * @returns {Konva.Shape}
	        * @example
	        * shape.cache();
	        * shape.drawHitFromCache();
	        */
	        drawHitFromCache: function(alphaThreshold) {
	            var threshold = alphaThreshold || 0,
	                cachedCanvas = this._cache.canvas,
	                sceneCanvas = this._getCachedSceneCanvas(),
	                hitCanvas = cachedCanvas.hit,
	                hitContext = hitCanvas.getContext(),
	                hitWidth = hitCanvas.getWidth(),
	                hitHeight = hitCanvas.getHeight(),
	                hitImageData, hitData, len, rgbColorKey, i, alpha;
	
	            hitContext.clear();
	            hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);
	
	            try {
	                hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
	                hitData = hitImageData.data;
	                len = hitData.length;
	                rgbColorKey = Konva.Util._hexToRgb(this.colorKey);
	
	                // replace non transparent pixels with color key
	                for(i = 0; i < len; i += 4) {
	                    alpha = hitData[i + 3];
	                    if (alpha > threshold) {
	                        hitData[i] = rgbColorKey.r;
	                        hitData[i + 1] = rgbColorKey.g;
	                        hitData[i + 2] = rgbColorKey.b;
	                        hitData[i + 3] = 255;
	                    }
	                    else {
	                        hitData[i + 3] = 0;
	                    }
	                }
	                hitContext.putImageData(hitImageData, 0, 0);
	            }
	            catch(e) {
	                Konva.Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);
	            }
	
	            return this;
	        }
	    });
	    Konva.Util.extend(Konva.Shape, Konva.Node);
	
	    // add getters and setters
	    Konva.Factory.addGetterSetter(Konva.Shape, 'stroke');
	
	    /**
	     * get/set stroke color
	     * @name stroke
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {String} color
	     * @returns {String}
	     * @example
	     * // get stroke color
	     * var stroke = shape.stroke();
	     *
	     * // set stroke color with color string
	     * shape.stroke('green');
	     *
	     * // set stroke color with hex
	     * shape.stroke('#00ff00');
	     *
	     * // set stroke color with rgb
	     * shape.stroke('rgb(0,255,0)');
	     *
	     * // set stroke color with rgba and make it 50% opaque
	     * shape.stroke('rgba(0,255,0,0.5');
	     */
	
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeRed', 0, Konva.Validators.RGBComponent);
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeGreen', 0, Konva.Validators.RGBComponent);
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeBlue', 0, Konva.Validators.RGBComponent);
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'strokeAlpha', 1, Konva.Validators.alphaComponent);
	
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeWidth', 2);
	
	    /**
	     * get/set stroke width
	     * @name strokeWidth
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} strokeWidth
	     * @returns {Number}
	     * @example
	     * // get stroke width
	     * var strokeWidth = shape.strokeWidth();
	     *
	     * // set stroke width
	     * shape.strokeWidth();
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeHitEnabled', true);
	
	    /**
	     * get/set strokeHitEnabled property. Useful for performance optimization.
	     * You may set `shape.strokeHitEnabled(false)`. In this case stroke will be no draw on hit canvas, so hit area
	     * of shape will be decreased (by lineWidth / 2). Remember that non closed line with `strokeHitEnabled = false`
	     * will be not drawn on hit canvas, that is mean line will no trigger pointer events (like mouseover)
	     * Default value is true
	     * @name strokeHitEnabled
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Boolean} strokeHitEnabled
	     * @returns {Boolean}
	     * @example
	     * // get strokeHitEnabled
	     * var strokeHitEnabled = shape.strokeHitEnabled();
	     *
	     * // set strokeHitEnabled
	     * shape.strokeHitEnabled();
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'perfectDrawEnabled', true);
	
	    /**
	     * get/set perfectDrawEnabled. If a shape has fill, stroke and opacity you may set `perfectDrawEnabled` to improve performance.
	     * See http://konvajs.github.io/docs/performance/Disable_Perfect_Draw.html for more information.
	     * Default value is true
	     * @name perfectDrawEnabled
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Boolean} perfectDrawEnabled
	     * @returns {Boolean}
	     * @example
	     * // get perfectDrawEnabled
	     * var perfectDrawEnabled = shape.perfectDrawEnabled();
	     *
	     * // set perfectDrawEnabled
	     * shape.perfectDrawEnabled();
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowForStrokeEnabled', true);
	
	    /**
	     * get/set shadowForStrokeEnabled. Useful for performance optimization.
	     * You may set `shape.shadowForStrokeEnabled(false)`. In this case stroke will be no draw shadow for stroke.
	     * Remember if you set `shadowForStrokeEnabled = false` for non closed line - that line with have no shadow!.
	     * Default value is true
	     * @name shadowForStrokeEnabled
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Boolean} shadowForStrokeEnabled
	     * @returns {Boolean}
	     * @example
	     * // get shadowForStrokeEnabled
	     * var shadowForStrokeEnabled = shape.shadowForStrokeEnabled();
	     *
	     * // set shadowForStrokeEnabled
	     * shape.shadowForStrokeEnabled();
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'lineJoin');
	
	    /**
	     * get/set line join.  Can be miter, round, or bevel.  The
	     *  default is miter
	     * @name lineJoin
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {String} lineJoin
	     * @returns {String}
	     * @example
	     * // get line join
	     * var lineJoin = shape.lineJoin();
	     *
	     * // set line join
	     * shape.lineJoin('round');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'lineCap');
	
	    /**
	     * get/set line cap.  Can be butt, round, or square
	     * @name lineCap
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {String} lineCap
	     * @returns {String}
	     * @example
	     * // get line cap
	     * var lineCap = shape.lineCap();
	     *
	     * // set line cap
	     * shape.lineCap('round');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'sceneFunc');
	
	    /**
	     * get/set scene draw function
	     * @name sceneFunc
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Function} drawFunc drawing function
	     * @returns {Function}
	     * @example
	     * // get scene draw function
	     * var sceneFunc = shape.sceneFunc();
	     *
	     * // set scene draw function
	     * shape.sceneFunc(function(context) {
	     *   context.beginPath();
	     *   context.rect(0, 0, this.width(), this.height());
	     *   context.closePath();
	     *   context.fillStrokeShape(this);
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'hitFunc');
	
	    /**
	     * get/set hit draw function
	     * @name hitFunc
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Function} drawFunc drawing function
	     * @returns {Function}
	     * @example
	     * // get hit draw function
	     * var hitFunc = shape.hitFunc();
	     *
	     * // set hit draw function
	     * shape.hitFunc(function(context) {
	     *   context.beginPath();
	     *   context.rect(0, 0, this.width(), this.height());
	     *   context.closePath();
	     *   context.fillStrokeShape(this);
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'dash');
	
	    /**
	     * get/set dash array for stroke.
	     * @name dash
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Array} dash
	     * @returns {Array}
	     * @example
	     *  // apply dashed stroke that is 10px long and 5 pixels apart
	     *  line.dash([10, 5]);
	     *  // apply dashed stroke that is made up of alternating dashed
	     *  // lines that are 10px long and 20px apart, and dots that have
	     *  // a radius of 5px and are 20px apart
	     *  line.dash([10, 20, 0.001, 20]);
	     */
	
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowColor');
	
	    /**
	     * get/set shadow color
	     * @name shadowColor
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {String} color
	     * @returns {String}
	     * @example
	     * // get shadow color
	     * var shadow = shape.shadowColor();
	     *
	     * // set shadow color with color string
	     * shape.shadowColor('green');
	     *
	     * // set shadow color with hex
	     * shape.shadowColor('#00ff00');
	     *
	     * // set shadow color with rgb
	     * shape.shadowColor('rgb(0,255,0)');
	     *
	     * // set shadow color with rgba and make it 50% opaque
	     * shape.shadowColor('rgba(0,255,0,0.5');
	     */
	
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowRed', 0, Konva.Validators.RGBComponent);
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowGreen', 0, Konva.Validators.RGBComponent);
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowBlue', 0, Konva.Validators.RGBComponent);
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'shadowAlpha', 1, Konva.Validators.alphaComponent);
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowBlur');
	
	    /**
	     * get/set shadow blur
	     * @name shadowBlur
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} blur
	     * @returns {Number}
	     * @example
	     * // get shadow blur
	     * var shadowBlur = shape.shadowBlur();
	     *
	     * // set shadow blur
	     * shape.shadowBlur(10);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOpacity');
	
	    /**
	     * get/set shadow opacity.  must be a value between 0 and 1
	     * @name shadowOpacity
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} opacity
	     * @returns {Number}
	     * @example
	     * // get shadow opacity
	     * var shadowOpacity = shape.shadowOpacity();
	     *
	     * // set shadow opacity
	     * shape.shadowOpacity(0.5);
	     */
	
	    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'shadowOffset', ['x', 'y']);
	
	    /**
	     * get/set shadow offset
	     * @name shadowOffset
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Object} offset
	     * @param {Number} offset.x
	     * @param {Number} offset.y
	     * @returns {Object}
	     * @example
	     * // get shadow offset
	     * var shadowOffset = shape.shadowOffset();
	     *
	     * // set shadow offset
	     * shape.shadowOffset({
	     *   x: 20
	     *   y: 10
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetX', 0);
	
	     /**
	     * get/set shadow offset x
	     * @name shadowOffsetX
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get shadow offset x
	     * var shadowOffsetX = shape.shadowOffsetX();
	     *
	     * // set shadow offset x
	     * shape.shadowOffsetX(5);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetY', 0);
	
	     /**
	     * get/set shadow offset y
	     * @name shadowOffsetY
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get shadow offset y
	     * var shadowOffsetY = shape.shadowOffsetY();
	     *
	     * // set shadow offset y
	     * shape.shadowOffsetY(5);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternImage');
	
	    /**
	     * get/set fill pattern image
	     * @name fillPatternImage
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Image} image object
	     * @returns {Image}
	     * @example
	     * // get fill pattern image
	     * var fillPatternImage = shape.fillPatternImage();
	     *
	     * // set fill pattern image
	     * var imageObj = new Image();
	     * imageObj.onload = function() {
	     *   shape.fillPatternImage(imageObj);
	     * };
	     * imageObj.src = 'path/to/image/jpg';
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fill');
	
	    /**
	     * get/set fill color
	     * @name fill
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {String} color
	     * @returns {String}
	     * @example
	     * // get fill color
	     * var fill = shape.fill();
	     *
	     * // set fill color with color string
	     * shape.fill('green');
	     *
	     * // set fill color with hex
	     * shape.fill('#00ff00');
	     *
	     * // set fill color with rgb
	     * shape.fill('rgb(0,255,0)');
	     *
	     * // set fill color with rgba and make it 50% opaque
	     * shape.fill('rgba(0,255,0,0.5');
	     *
	     * // shape without fill
	     * shape.fill(null);
	     */
	
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillRed', 0, Konva.Validators.RGBComponent);
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillGreen', 0, Konva.Validators.RGBComponent);
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillBlue', 0, Konva.Validators.RGBComponent);
	    Konva.Factory.addDeprecatedGetterSetter(Konva.Shape, 'fillAlpha', 1, Konva.Validators.alphaComponent);
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternX', 0);
	
	    /**
	     * get/set fill pattern x
	     * @name fillPatternX
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill pattern x
	     * var fillPatternX = shape.fillPatternX();
	     * // set fill pattern x
	     * shape.fillPatternX(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternY', 0);
	
	    /**
	     * get/set fill pattern y
	     * @name fillPatternY
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill pattern y
	     * var fillPatternY = shape.fillPatternY();
	     * // set fill pattern y
	     * shape.fillPatternY(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientColorStops');
	
	    /**
	     * get/set fill linear gradient color stops
	     * @name fillLinearGradientColorStops
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Array} colorStops
	     * @returns {Array} colorStops
	     * @example
	     * // get fill linear gradient color stops
	     * var colorStops = shape.fillLinearGradientColorStops();
	     *
	     * // create a linear gradient that starts with red, changes to blue
	     * // halfway through, and then changes to green
	     * shape.fillLinearGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartRadius', 0);
	
	    /**
	     * get/set fill radial gradient start radius
	     * @name fillRadialGradientStartRadius
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} radius
	     * @returns {Number}
	     * @example
	     * // get radial gradient start radius
	     * var startRadius = shape.fillRadialGradientStartRadius();
	     *
	     * // set radial gradient start radius
	     * shape.fillRadialGradientStartRadius(0);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndRadius', 0);
	
	    /**
	     * get/set fill radial gradient end radius
	     * @name fillRadialGradientEndRadius
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} radius
	     * @returns {Number}
	     * @example
	     * // get radial gradient end radius
	     * var endRadius = shape.fillRadialGradientEndRadius();
	     *
	     * // set radial gradient end radius
	     * shape.fillRadialGradientEndRadius(100);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientColorStops');
	
	    /**
	     * get/set fill radial gradient color stops
	     * @name fillRadialGradientColorStops
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} colorStops
	     * @returns {Array}
	     * @example
	     * // get fill radial gradient color stops
	     * var colorStops = shape.fillRadialGradientColorStops();
	     *
	     * // create a radial gradient that starts with red, changes to blue
	     * // halfway through, and then changes to green
	     * shape.fillRadialGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRepeat', 'repeat');
	
	    /**
	     * get/set fill pattern repeat.  Can be 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'.  The default is 'repeat'
	     * @name fillPatternRepeat
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {String} repeat
	     * @returns {String}
	     * @example
	     * // get fill pattern repeat
	     * var repeat = shape.fillPatternRepeat();
	     *
	     * // repeat pattern in x direction only
	     * shape.fillPatternRepeat('repeat-x');
	     *
	     * // do not repeat the pattern
	     * shape.fillPatternRepeat('no repeat');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillEnabled', true);
	
	    /**
	     * get/set fill enabled flag
	     * @name fillEnabled
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get fill enabled flag
	     * var fillEnabled = shape.fillEnabled();
	     *
	     * // disable fill
	     * shape.fillEnabled(false);
	     *
	     * // enable fill
	     * shape.fillEnabled(true);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeEnabled', true);
	
	    /**
	     * get/set stroke enabled flag
	     * @name strokeEnabled
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get stroke enabled flag
	     * var strokeEnabled = shape.strokeEnabled();
	     *
	     * // disable stroke
	     * shape.strokeEnabled(false);
	     *
	     * // enable stroke
	     * shape.strokeEnabled(true);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'shadowEnabled', true);
	
	    /**
	     * get/set shadow enabled flag
	     * @name shadowEnabled
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get shadow enabled flag
	     * var shadowEnabled = shape.shadowEnabled();
	     *
	     * // disable shadow
	     * shape.shadowEnabled(false);
	     *
	     * // enable shadow
	     * shape.shadowEnabled(true);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'dashEnabled', true);
	
	    /**
	     * get/set dash enabled flag
	     * @name dashEnabled
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get dash enabled flag
	     * var dashEnabled = shape.dashEnabled();
	     *
	     * // disable dash
	     * shape.dashEnabled(false);
	     *
	     * // enable dash
	     * shape.dashEnabled(true);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'strokeScaleEnabled', true);
	
	    /**
	     * get/set strokeScale enabled flag
	     * @name strokeScaleEnabled
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get stroke scale enabled flag
	     * var strokeScaleEnabled = shape.strokeScaleEnabled();
	     *
	     * // disable stroke scale
	     * shape.strokeScaleEnabled(false);
	     *
	     * // enable stroke scale
	     * shape.strokeScaleEnabled(true);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPriority', 'color');
	
	    /**
	     * get/set fill priority.  can be color, pattern, linear-gradient, or radial-gradient.  The default is color.
	     *   This is handy if you want to toggle between different fill types.
	     * @name fillPriority
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {String} priority
	     * @returns {String}
	     * @example
	     * // get fill priority
	     * var fillPriority = shape.fillPriority();
	     *
	     * // set fill priority
	     * shape.fillPriority('linear-gradient');
	     */
	
	    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternOffset', ['x', 'y']);
	
	    /**
	     * get/set fill pattern offset
	     * @name fillPatternOffset
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Object} offset
	     * @param {Number} offset.x
	     * @param {Number} offset.y
	     * @returns {Object}
	     * @example
	     * // get fill pattern offset
	     * var patternOffset = shape.fillPatternOffset();
	     *
	     * // set fill pattern offset
	     * shape.fillPatternOffset({
	     *   x: 20
	     *   y: 10
	     * });
	     */
	
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetX', 0);
	    /**
	     * get/set fill pattern offset x
	     * @name fillPatternOffsetX
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill pattern offset x
	     * var patternOffsetX = shape.fillPatternOffsetX();
	     *
	     * // set fill pattern offset x
	     * shape.fillPatternOffsetX(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetY', 0);
	    /**
	     * get/set fill pattern offset y
	     * @name fillPatternOffsetY
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill pattern offset y
	     * var patternOffsetY = shape.fillPatternOffsetY();
	     *
	     * // set fill pattern offset y
	     * shape.fillPatternOffsetY(10);
	     */
	
	    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternScale', ['x', 'y']);
	
	    /**
	     * get/set fill pattern scale
	     * @name fillPatternScale
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Object} scale
	     * @param {Number} scale.x
	     * @param {Number} scale.y
	     * @returns {Object}
	     * @example
	     * // get fill pattern scale
	     * var patternScale = shape.fillPatternScale();
	     *
	     * // set fill pattern scale
	     * shape.fillPatternScale({
	     *   x: 2
	     *   y: 2
	     * });
	     */
	
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleX', 1);
	    /**
	     * get/set fill pattern scale x
	     * @name fillPatternScaleX
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill pattern scale x
	     * var patternScaleX = shape.fillPatternScaleX();
	     *
	     * // set fill pattern scale x
	     * shape.fillPatternScaleX(2);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleY', 1);
	    /**
	     * get/set fill pattern scale y
	     * @name fillPatternScaleY
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill pattern scale y
	     * var patternScaleY = shape.fillPatternScaleY();
	     *
	     * // set fill pattern scale y
	     * shape.fillPatternScaleY(2);
	     */
	
	    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillLinearGradientStartPoint', ['x', 'y']);
	
	    /**
	     * get/set fill linear gradient start point
	     * @name fillLinearGradientStartPoint
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Object} startPoint
	     * @param {Number} startPoint.x
	     * @param {Number} startPoint.y
	     * @returns {Object}
	     * @example
	     * // get fill linear gradient start point
	     * var startPoint = shape.fillLinearGradientStartPoint();
	     *
	     * // set fill linear gradient start point
	     * shape.fillLinearGradientStartPoint({
	     *   x: 20
	     *   y: 10
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientStartPointX', 0);
	    /**
	     * get/set fill linear gradient start point x
	     * @name fillLinearGradientStartPointX
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill linear gradient start point x
	     * var startPointX = shape.fillLinearGradientStartPointX();
	     *
	     * // set fill linear gradient start point x
	     * shape.fillLinearGradientStartPointX(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientStartPointY', 0);
	    /**
	     * get/set fill linear gradient start point y
	     * @name fillLinearGradientStartPointY
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill linear gradient start point y
	     * var startPointY = shape.fillLinearGradientStartPointY();
	     *
	     * // set fill linear gradient start point y
	     * shape.fillLinearGradientStartPointY(20);
	     */
	
	    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillLinearGradientEndPoint', ['x', 'y']);
	
	    /**
	     * get/set fill linear gradient end point
	     * @name fillLinearGradientEndPoint
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Object} endPoint
	     * @param {Number} endPoint.x
	     * @param {Number} endPoint.y
	     * @returns {Object}
	     * @example
	     * // get fill linear gradient end point
	     * var endPoint = shape.fillLinearGradientEndPoint();
	     *
	     * // set fill linear gradient end point
	     * shape.fillLinearGradientEndPoint({
	     *   x: 20
	     *   y: 10
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointX', 0);
	    /**
	     * get/set fill linear gradient end point x
	     * @name fillLinearGradientEndPointX
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill linear gradient end point x
	     * var endPointX = shape.fillLinearGradientEndPointX();
	     *
	     * // set fill linear gradient end point x
	     * shape.fillLinearGradientEndPointX(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointY', 0);
	    /**
	     * get/set fill linear gradient end point y
	     * @name fillLinearGradientEndPointY
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill linear gradient end point y
	     * var endPointY = shape.fillLinearGradientEndPointY();
	     *
	     * // set fill linear gradient end point y
	     * shape.fillLinearGradientEndPointY(20);
	     */
	
	    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillRadialGradientStartPoint', ['x', 'y']);
	
	    /**
	     * get/set fill radial gradient start point
	     * @name fillRadialGradientStartPoint
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Object} startPoint
	     * @param {Number} startPoint.x
	     * @param {Number} startPoint.y
	     * @returns {Object}
	     * @example
	     * // get fill radial gradient start point
	     * var startPoint = shape.fillRadialGradientStartPoint();
	     *
	     * // set fill radial gradient start point
	     * shape.fillRadialGradientStartPoint({
	     *   x: 20
	     *   y: 10
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartPointX', 0);
	    /**
	     * get/set fill radial gradient start point x
	     * @name fillRadialGradientStartPointX
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill radial gradient start point x
	     * var startPointX = shape.fillRadialGradientStartPointX();
	     *
	     * // set fill radial gradient start point x
	     * shape.fillRadialGradientStartPointX(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientStartPointY', 0);
	    /**
	     * get/set fill radial gradient start point y
	     * @name fillRadialGradientStartPointY
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill radial gradient start point y
	     * var startPointY = shape.fillRadialGradientStartPointY();
	     *
	     * // set fill radial gradient start point y
	     * shape.fillRadialGradientStartPointY(20);
	     */
	
	    Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillRadialGradientEndPoint', ['x', 'y']);
	
	    /**
	     * get/set fill radial gradient end point
	     * @name fillRadialGradientEndPoint
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Object} endPoint
	     * @param {Number} endPoint.x
	     * @param {Number} endPoint.y
	     * @returns {Object}
	     * @example
	     * // get fill radial gradient end point
	     * var endPoint = shape.fillRadialGradientEndPoint();
	     *
	     * // set fill radial gradient end point
	     * shape.fillRadialGradientEndPoint({
	     *   x: 20
	     *   y: 10
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointX', 0);
	    /**
	     * get/set fill radial gradient end point x
	     * @name fillRadialGradientEndPointX
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get fill radial gradient end point x
	     * var endPointX = shape.fillRadialGradientEndPointX();
	     *
	     * // set fill radial gradient end point x
	     * shape.fillRadialGradientEndPointX(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointY', 0);
	    /**
	     * get/set fill radial gradient end point y
	     * @name fillRadialGradientEndPointY
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get fill radial gradient end point y
	     * var endPointY = shape.fillRadialGradientEndPointY();
	     *
	     * // set fill radial gradient end point y
	     * shape.fillRadialGradientEndPointY(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRotation', 0);
	
	    /**
	     * get/set fill pattern rotation in degrees
	     * @name fillPatternRotation
	     * @method
	     * @memberof Konva.Shape.prototype
	     * @param {Number} rotation
	     * @returns {Konva.Shape}
	     * @example
	     * // get fill pattern rotation
	     * var patternRotation = shape.fillPatternRotation();
	     *
	     * // set fill pattern rotation
	     * shape.fillPatternRotation(20);
	     */
	
	
	    Konva.Factory.backCompat(Konva.Shape, {
	        dashArray: 'dash',
	        getDashArray: 'getDash',
	        setDashArray: 'getDash',
	
	        drawFunc: 'sceneFunc',
	        getDrawFunc: 'getSceneFunc',
	        setDrawFunc: 'setSceneFunc',
	
	        drawHitFunc: 'hitFunc',
	        getDrawHitFunc: 'getHitFunc',
	        setDrawHitFunc: 'setHitFunc'
	    });
	
	    Konva.Collection.mapMethods(Konva.Shape);
	})(Konva);
	
	(function() {
	    'use strict';
	    // CONSTANTS
	    var STAGE = 'Stage',
	        STRING = 'string',
	        PX = 'px',
	
	        MOUSEOUT = 'mouseout',
	        MOUSELEAVE = 'mouseleave',
	        MOUSEOVER = 'mouseover',
	        MOUSEENTER = 'mouseenter',
	        MOUSEMOVE = 'mousemove',
	        MOUSEDOWN = 'mousedown',
	        MOUSEUP = 'mouseup',
	        CLICK = 'click',
	        DBL_CLICK = 'dblclick',
	        TOUCHSTART = 'touchstart',
	        TOUCHEND = 'touchend',
	        TAP = 'tap',
	        DBL_TAP = 'dbltap',
	        TOUCHMOVE = 'touchmove',
	        DOMMOUSESCROLL = 'DOMMouseScroll',
	        MOUSEWHEEL = 'mousewheel',
	        WHEEL = 'wheel',
	
	        CONTENT_MOUSEOUT = 'contentMouseout',
	        CONTENT_MOUSEOVER = 'contentMouseover',
	        CONTENT_MOUSEMOVE = 'contentMousemove',
	        CONTENT_MOUSEDOWN = 'contentMousedown',
	        CONTENT_MOUSEUP = 'contentMouseup',
	        CONTENT_CLICK = 'contentClick',
	        CONTENT_DBL_CLICK = 'contentDblclick',
	        CONTENT_TOUCHSTART = 'contentTouchstart',
	        CONTENT_TOUCHEND = 'contentTouchend',
	        CONTENT_DBL_TAP = 'contentDbltap',
	        CONTENT_TAP = 'contentTap',
	        CONTENT_TOUCHMOVE = 'contentTouchmove',
	        CONTENT_WHEEL = 'contentWheel',
	
	        DIV = 'div',
	        RELATIVE = 'relative',
	        KONVA_CONTENT = 'konvajs-content',
	        SPACE = ' ',
	        UNDERSCORE = '_',
	        CONTAINER = 'container',
	        EMPTY_STRING = '',
	        EVENTS = [MOUSEDOWN, MOUSEMOVE, MOUSEUP, MOUSEOUT, TOUCHSTART, TOUCHMOVE, TOUCHEND, MOUSEOVER, DOMMOUSESCROLL, MOUSEWHEEL, WHEEL],
	
	        // cached variables
	        eventsLength = EVENTS.length;
	
	    function addEvent(ctx, eventName) {
	        ctx.content.addEventListener(eventName, function(evt) {
	            ctx[UNDERSCORE + eventName](evt);
	        }, false);
	    }
	
	    /**
	     * Stage constructor.  A stage is used to contain multiple layers
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Container
	     * @param {Object} config
	     * @param {String|Element} config.container Container selector or DOM element
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var stage = new Konva.Stage({
	         *   width: 500,
	         *   height: 800,
	         *   container: 'containerId' // or "#containerId" or ".containerClass"
	         * });
	     */
	    Konva.Stage = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Util.addMethods(Konva.Stage, {
	        ___init: function(config) {
	            this.nodeType = STAGE;
	            // call super constructor
	            Konva.Container.call(this, config);
	            this._id = Konva.idCounter++;
	            this._buildDOM();
	            this._bindContentEvents();
	            this._enableNestedTransforms = false;
	            Konva.stages.push(this);
	        },
	        _validateAdd: function(child) {
	            if (child.getType() !== 'Layer') {
	                Konva.Util.throw('You may only add layers to the stage.');
	            }
	        },
	        /**
	         * set container dom element which contains the stage wrapper div element
	         * @method
	         * @memberof Konva.Stage.prototype
	         * @param {DomElement} container can pass in a dom element or id string
	         */
	        setContainer: function (container) {
	            if (typeof container === STRING) {
	                if (container.charAt(0) === '.') {
	                    var className = container.slice(1);
	                    container = Konva.document.getElementsByClassName(className)[0];
	                } else {
	                    var id;
	                    if (container.charAt(0) !== '#') {
	                        id = container;
	                    } else {
	                        id = container.slice(1);
	                    }
	                    container = Konva.document.getElementById(id);
	                }
	                if (!container) {
	                    throw 'Can not find container in document with id ' + id;
	                }
	            }
	            this._setAttr(CONTAINER, container);
	            return this;
	        },
	        shouldDrawHit: function() {
	            return true;
	        },
	        draw: function() {
	            Konva.Node.prototype.draw.call(this);
	            return this;
	        },
	        /**
	         * draw layer scene graphs
	         * @name draw
	         * @method
	         * @memberof Konva.Stage.prototype
	         */
	
	        /**
	         * draw layer hit graphs
	         * @name drawHit
	         * @method
	         * @memberof Konva.Stage.prototype
	         */
	
	        /**
	         * set height
	         * @method
	         * @memberof Konva.Stage.prototype
	         * @param {Number} height
	         */
	        setHeight: function(height) {
	            Konva.Node.prototype.setHeight.call(this, height);
	            this._resizeDOM();
	            return this;
	        },
	        /**
	         * set width
	         * @method
	         * @memberof Konva.Stage.prototype
	         * @param {Number} width
	         */
	        setWidth: function(width) {
	            Konva.Node.prototype.setWidth.call(this, width);
	            this._resizeDOM();
	            return this;
	        },
	        /**
	         * clear all layers
	         * @method
	         * @memberof Konva.Stage.prototype
	         */
	        clear: function() {
	            var layers = this.children,
	                len = layers.length,
	                n;
	
	            for(n = 0; n < len; n++) {
	                layers[n].clear();
	            }
	            return this;
	        },
	        clone: function(obj) {
	            if (!obj) {
	                obj = {};
	            }
	            obj.container = Konva.document.createElement(DIV);
	            return Konva.Container.prototype.clone.call(this, obj);
	        },
	        /**
	         * destroy stage
	         * @method
	         * @memberof Konva.Stage.prototype
	         */
	        destroy: function() {
	            var content = this.content;
	            Konva.Container.prototype.destroy.call(this);
	
	            if(content && Konva.Util._isInDocument(content)) {
	                this.getContainer().removeChild(content);
	            }
	            var index = Konva.stages.indexOf(this);
	            if (index > -1) {
	                Konva.stages.splice(index, 1);
	            }
	            return this;
	        },
	        /**
	         * get pointer position which can be a touch position or mouse position
	         * @method
	         * @memberof Konva.Stage.prototype
	         * @returns {Object}
	         */
	        getPointerPosition: function() {
	            return this.pointerPos;
	        },
	        getStage: function() {
	            return this;
	        },
	        /**
	         * get stage content div element which has the
	         *  the class name "konvajs-content"
	         * @method
	         * @memberof Konva.Stage.prototype
	         */
	        getContent: function() {
	            return this.content;
	        },
	        /**
	         * Creates a composite data URL
	         * @method
	         * @memberof Konva.Stage.prototype
	         * @param {Object} config
	         * @param {Function} [config.callback] function executed when the composite has completed. Deprecated as method is sync now.
	         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
	         *  "image/png" is the default
	         * @param {Number} [config.x] x position of canvas section
	         * @param {Number} [config.y] y position of canvas section
	         * @param {Number} [config.width] width of canvas section
	         * @param {Number} [config.height] height of canvas section
	         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
	         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
	         *  is very high quality
	         */
	        toDataURL: function(config) {
	            config = config || {};
	
	            var mimeType = config.mimeType || null,
	                quality = config.quality || null,
	                x = config.x || 0,
	                y = config.y || 0,
	                canvas = new Konva.SceneCanvas({
	                    width: config.width || this.getWidth(),
	                    height: config.height || this.getHeight(),
	                    pixelRatio: config.pixelRatio
	                }),
	                _context = canvas.getContext()._context,
	                layers = this.children;
	
	            if(x || y) {
	                _context.translate(-1 * x, -1 * y);
	            }
	
	
	            layers.each(function(layer) {
	                var width = layer.getCanvas().getWidth();
	                var height = layer.getCanvas().getHeight();
	                var ratio = layer.getCanvas().getPixelRatio();
	                _context.drawImage(layer.getCanvas()._canvas, 0, 0, width / ratio, height / ratio);
	            });
	            var src = canvas.toDataURL(mimeType, quality);
	
	            if (config.callback) {
	                config.callback(src);
	            }
	
	            return src;
	        },
	        /**
	         * converts stage into an image.
	         * @method
	         * @memberof Konva.Stage.prototype
	         * @param {Object} config
	         * @param {Function} config.callback function executed when the composite has completed
	         * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
	         *  "image/png" is the default
	         * @param {Number} [config.x] x position of canvas section
	         * @param {Number} [config.y] y position of canvas section
	         * @param {Number} [config.width] width of canvas section
	         * @param {Number} [config.height] height of canvas section
	         * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
	         *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
	         *  is very high quality
	         */
	        toImage: function(config) {
	            var cb = config.callback;
	
	            config.callback = function(dataUrl) {
	                Konva.Util._getImage(dataUrl, function(img) {
	                    cb(img);
	                });
	            };
	            this.toDataURL(config);
	        },
	        /**
	         * get visible intersection shape. This is the preferred
	         *  method for determining if a point intersects a shape or not
	         * @method
	         * @memberof Konva.Stage.prototype
	         * @param {Object} pos
	         * @param {Number} pos.x
	         * @param {Number} pos.y
	         * @param {String} [selector]
	         * @returns {Konva.Node}
	         * @example
	         * var shape = stage.getIntersection({x: 50, y: 50});
	         * // or if you interested in shape parent:
	         * var group = stage.getIntersection({x: 50, y: 50}, 'Group');
	         */
	        getIntersection: function(pos, selector) {
	            var layers = this.getChildren(),
	                len = layers.length,
	                end = len - 1,
	                n, shape;
	
	            for(n = end; n >= 0; n--) {
	                shape = layers[n].getIntersection(pos, selector);
	                if (shape) {
	                    return shape;
	                }
	            }
	
	            return null;
	        },
	        _resizeDOM: function() {
	            if(this.content) {
	                var width = this.getWidth(),
	                    height = this.getHeight(),
	                    layers = this.getChildren(),
	                    len = layers.length,
	                    n, layer;
	
	                // set content dimensions
	                this.content.style.width = width + PX;
	                this.content.style.height = height + PX;
	
	                this.bufferCanvas.setSize(width, height);
	                this.bufferHitCanvas.setSize(width, height);
	
	                // set layer dimensions
	                for(n = 0; n < len; n++) {
	                    layer = layers[n];
	                    layer.setSize(width, height);
	                    layer.draw();
	                }
	            }
	        },
	        /**
	         * add layer or layers to stage
	         * @method
	         * @memberof Konva.Stage.prototype
	         * @param {...Konva.Layer} layer
	         * @example
	         * stage.add(layer1, layer2, layer3);
	         */
	        add: function(layer) {
	            if (arguments.length > 1) {
	                for (var i = 0; i < arguments.length; i++) {
	                    this.add(arguments[i]);
	                }
	                return this;
	            }
	            Konva.Container.prototype.add.call(this, layer);
	            layer._setCanvasSize(this.width(), this.height());
	
	            // draw layer and append canvas to container
	            layer.draw();
	            this.content.appendChild(layer.canvas._canvas);
	
	            // chainable
	            return this;
	        },
	        getParent: function() {
	            return null;
	        },
	        getLayer: function() {
	            return null;
	        },
	        /**
	         * returns a {@link Konva.Collection} of layers
	         * @method
	         * @memberof Konva.Stage.prototype
	         */
	        getLayers: function() {
	            return this.getChildren();
	        },
	        _bindContentEvents: function() {
	            for (var n = 0; n < eventsLength; n++) {
	                addEvent(this, EVENTS[n]);
	            }
	        },
	        _mouseover: function(evt) {
	            if (!Konva.UA.mobile) {
	                this._setPointerPosition(evt);
	                this._fire(CONTENT_MOUSEOVER, {evt: evt});
	            }
	        },
	        _mouseout: function(evt) {
	            if (!Konva.UA.mobile) {
	                this._setPointerPosition(evt);
	                var targetShape = this.targetShape;
	
	                if(targetShape && !Konva.isDragging()) {
	                    targetShape._fireAndBubble(MOUSEOUT, {evt: evt});
	                    targetShape._fireAndBubble(MOUSELEAVE, {evt: evt});
	                    this.targetShape = null;
	                }
	                this.pointerPos = undefined;
	
	                this._fire(CONTENT_MOUSEOUT, {evt: evt});
	            }
	        },
	        _mousemove: function(evt) {
	            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
	            if (Konva.UA.ieMobile) {
	                return this._touchmove(evt);
	            }
	            // workaround fake mousemove event in chrome browser https://code.google.com/p/chromium/issues/detail?id=161464
	            if ((typeof evt.movementX !== 'undefined' || typeof evt.movementY !== 'undefined') && evt.movementY === 0 && evt.movementX === 0) {
	                return null;
	            }
	            if (Konva.UA.mobile) {
	                return null;
	            }
	            this._setPointerPosition(evt);
	            var shape;
	
	            if (!Konva.isDragging()) {
	                shape = this.getIntersection(this.getPointerPosition());
	                if(shape && shape.isListening()) {
	                    if(!Konva.isDragging() && (!this.targetShape || this.targetShape._id !== shape._id)) {
	                        if(this.targetShape) {
	                            this.targetShape._fireAndBubble(MOUSEOUT, {evt: evt}, shape);
	                            this.targetShape._fireAndBubble(MOUSELEAVE, {evt: evt}, shape);
	                        }
	                        shape._fireAndBubble(MOUSEOVER, {evt: evt}, this.targetShape);
	                        shape._fireAndBubble(MOUSEENTER, {evt: evt}, this.targetShape);
	                        this.targetShape = shape;
	                    }
	                    else {
	                        shape._fireAndBubble(MOUSEMOVE, {evt: evt});
	                    }
	                }
	                /*
	                 * if no shape was detected, clear target shape and try
	                 * to run mouseout from previous target shape
	                 */
	                else {
	                    if(this.targetShape && !Konva.isDragging()) {
	                        this.targetShape._fireAndBubble(MOUSEOUT, {evt: evt});
	                        this.targetShape._fireAndBubble(MOUSELEAVE, {evt: evt});
	                        this.targetShape = null;
	                    }
	
	                }
	
	                // content event
	                this._fire(CONTENT_MOUSEMOVE, {evt: evt});
	            }
	
	            // always call preventDefault for desktop events because some browsers
	            // try to drag and drop the canvas element
	            if (evt.preventDefault) {
	                evt.preventDefault();
	            }
	        },
	        _mousedown: function(evt) {
	            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
	            if (Konva.UA.ieMobile) {
	                return this._touchstart(evt);
	            }
	            if (!Konva.UA.mobile) {
	                this._setPointerPosition(evt);
	                var shape = this.getIntersection(this.getPointerPosition());
	
	                Konva.listenClickTap = true;
	
	                if (shape && shape.isListening()) {
	                    this.clickStartShape = shape;
	                    shape._fireAndBubble(MOUSEDOWN, {evt: evt});
	                }
	
	                // content event
	                this._fire(CONTENT_MOUSEDOWN, {evt: evt});
	            }
	
	            // always call preventDefault for desktop events because some browsers
	            // try to drag and drop the canvas element
	            if (evt.preventDefault) {
	                evt.preventDefault();
	            }
	        },
	        _mouseup: function(evt) {
	
	            // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
	            if (Konva.UA.ieMobile) {
	                return this._touchend(evt);
	            }
	            if (!Konva.UA.mobile) {
	                this._setPointerPosition(evt);
	                var shape = this.getIntersection(this.getPointerPosition()),
	                    clickStartShape = this.clickStartShape,
	                    fireDblClick = false,
	                    dd = Konva.DD;
	
	                if(Konva.inDblClickWindow) {
	                    fireDblClick = true;
	                    Konva.inDblClickWindow = false;
	                }
	                // don't set inDblClickWindow after dragging
	                else if (!dd || !dd.justDragged) {
	                    Konva.inDblClickWindow = true;
	                } else if (dd) {
	                    dd.justDragged = false;
	                }
	
	                setTimeout(function() {
	                    Konva.inDblClickWindow = false;
	                }, Konva.dblClickWindow);
	
	                if (shape && shape.isListening()) {
	                    shape._fireAndBubble(MOUSEUP, {evt: evt});
	
	                    // detect if click or double click occurred
	                    if(Konva.listenClickTap && clickStartShape && clickStartShape._id === shape._id) {
	                        shape._fireAndBubble(CLICK, {evt: evt});
	
	                        if(fireDblClick) {
	                            shape._fireAndBubble(DBL_CLICK, {evt: evt});
	                        }
	                    }
	                }
	                // content events
	                this._fire(CONTENT_MOUSEUP, {evt: evt});
	                if (Konva.listenClickTap) {
	                    this._fire(CONTENT_CLICK, {evt: evt});
	                    if(fireDblClick) {
	                        this._fire(CONTENT_DBL_CLICK, {evt: evt});
	                    }
	                }
	
	                Konva.listenClickTap = false;
	            }
	
	            // always call preventDefault for desktop events because some browsers
	            // try to drag and drop the canvas element
	            if (evt.preventDefault) {
	                evt.preventDefault();
	            }
	        },
	        _touchstart: function(evt) {
	            this._setPointerPosition(evt);
	            var shape = this.getIntersection(this.getPointerPosition());
	
	            Konva.listenClickTap = true;
	
	            if (shape && shape.isListening()) {
	                this.tapStartShape = shape;
	                shape._fireAndBubble(TOUCHSTART, {evt: evt});
	
	                // only call preventDefault if the shape is listening for events
	                if (shape.isListening() && shape.preventDefault() && evt.preventDefault) {
	                    evt.preventDefault();
	                }
	            }
	            // content event
	            this._fire(CONTENT_TOUCHSTART, {evt: evt});
	        },
	        _touchend: function(evt) {
	            this._setPointerPosition(evt);
	            var shape = this.getIntersection(this.getPointerPosition()),
	                fireDblClick = false;
	
	            if(Konva.inDblClickWindow) {
	                fireDblClick = true;
	                Konva.inDblClickWindow = false;
	            }
	            else {
	                Konva.inDblClickWindow = true;
	            }
	
	            setTimeout(function() {
	                Konva.inDblClickWindow = false;
	            }, Konva.dblClickWindow);
	
	            if (shape && shape.isListening()) {
	                shape._fireAndBubble(TOUCHEND, {evt: evt});
	
	                // detect if tap or double tap occurred
	                if(Konva.listenClickTap && this.tapStartShape && shape._id === this.tapStartShape._id) {
	                    shape._fireAndBubble(TAP, {evt: evt});
	
	                    if(fireDblClick) {
	                        shape._fireAndBubble(DBL_TAP, {evt: evt});
	                    }
	                }
	                // only call preventDefault if the shape is listening for events
	                if (shape.isListening() && shape.preventDefault() && evt.preventDefault) {
	                    evt.preventDefault();
	                }
	            }
	            // content events
	            this._fire(CONTENT_TOUCHEND, {evt: evt});
	            if (Konva.listenClickTap) {
	                this._fire(CONTENT_TAP, {evt: evt});
	                if(fireDblClick) {
	                    this._fire(CONTENT_DBL_TAP, {evt: evt});
	                }
	            }
	
	            Konva.listenClickTap = false;
	        },
	        _touchmove: function(evt) {
	            this._setPointerPosition(evt);
	            var dd = Konva.DD,
	                shape;
	            if (!Konva.isDragging()) {
	                shape = this.getIntersection(this.getPointerPosition());
	                if (shape && shape.isListening()) {
	                    shape._fireAndBubble(TOUCHMOVE, {evt: evt});
	                    // only call preventDefault if the shape is listening for events
	                    if (shape.isListening() && shape.preventDefault() && evt.preventDefault) {
	                        evt.preventDefault();
	                    }
	                }
	                this._fire(CONTENT_TOUCHMOVE, {evt: evt});
	            }
	            if(dd) {
	                if (Konva.isDragging() && Konva.DD.node.preventDefault()) {
	                    evt.preventDefault();
	                }
	            }
	        },
	        _DOMMouseScroll: function(evt) {
	            this._mousewheel(evt);
	        },
	        _mousewheel: function(evt) {
	            this._setPointerPosition(evt);
	            var shape = this.getIntersection(this.getPointerPosition());
	
	            if (shape && shape.isListening()) {
	                shape._fireAndBubble(WHEEL, {evt: evt});
	            }
	            this._fire(CONTENT_WHEEL, {evt: evt});
	        },
	        _wheel: function(evt) {
	            this._mousewheel(evt);
	        },
	        _setPointerPosition: function(evt) {
	            var contentPosition = this._getContentPosition(),
	                x = null,
	                y = null;
	            evt = evt ? evt : window.event;
	
	            // touch events
	            if(evt.touches !== undefined) {
	                // currently, only handle one finger
	                if (evt.touches.length > 0) {
	
	                    var touch = evt.touches[0];
	                    // get the information for finger #1
	                    x = touch.clientX - contentPosition.left;
	                    y = touch.clientY - contentPosition.top;
	                }
	            }
	            // mouse events
	            else {
	                x = evt.clientX - contentPosition.left;
	                y = evt.clientY - contentPosition.top;
	            }
	            if (x !== null && y !== null) {
	                this.pointerPos = {
	                    x: x,
	                    y: y
	                };
	            }
	        },
	        _getContentPosition: function() {
	            var rect = this.content.getBoundingClientRect ? this.content.getBoundingClientRect() : { top: 0, left: 0 };
	            return {
	                top: rect.top,
	                left: rect.left
	            };
	        },
	        _buildDOM: function() {
	            var container = this.getContainer();
	            if (!container) {
	                if (Konva.Util.isBrowser()) {
	                    throw 'Stage has no container. A container is required.';
	                } else {
	                    // automatically create element for jsdom in nodejs env
	                    container = Konva.document.createElement(DIV);
	                }
	            }
	            // clear content inside container
	            container.innerHTML = EMPTY_STRING;
	
	            // content
	            this.content = Konva.document.createElement(DIV);
	            this.content.style.position = RELATIVE;
	            this.content.className = KONVA_CONTENT;
	            this.content.setAttribute('role', 'presentation');
	            container.appendChild(this.content);
	
	            // the buffer canvas pixel ratio must be 1 because it is used as an
	            // intermediate canvas before copying the result onto a scene canvas.
	            // not setting it to 1 will result in an over compensation
	            this.bufferCanvas = new Konva.SceneCanvas();
	            this.bufferHitCanvas = new Konva.HitCanvas({pixelRatio: 1});
	
	            this._resizeDOM();
	        },
	        _onContent: function(typesStr, handler) {
	            var types = typesStr.split(SPACE),
	                len = types.length,
	                n, baseEvent;
	
	            for(n = 0; n < len; n++) {
	                baseEvent = types[n];
	                this.content.addEventListener(baseEvent, handler, false);
	            }
	        },
	        // currently cache function is now working for stage, because stage has no its own canvas element
	        // TODO: may be it is better to cache all children layers?
	        cache: function() {
	            Konva.Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');
	        },
	        clearCache: function() {
	        }
	    });
	    Konva.Util.extend(Konva.Stage, Konva.Container);
	
	    // add getters and setters
	    Konva.Factory.addGetter(Konva.Stage, 'container');
	    Konva.Factory.addOverloadedGetterSetter(Konva.Stage, 'container');
	
	    /**
	     * get container DOM element
	     * @name container
	     * @method
	     * @memberof Konva.Stage.prototype
	     * @returns {DomElement} container
	     * @example
	     * // get container
	     * var container = stage.container();
	     * // set container
	     * var container = document.createElement('div');
	     * body.appendChild(container);
	     * stage.container(container);
	     */
	
	})();
	
	(function() {
	    'use strict';
	    /**
	     * BaseLayer constructor.
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Container
	     * @param {Object} config
	     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
	     * to clear the canvas before each layer draw.  The default value is true.
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * * @param {Object} [config.clip] set clip
	     * @param {Number} [config.clipX] set clip x
	     * @param {Number} [config.clipY] set clip y
	     * @param {Number} [config.clipWidth] set clip width
	     * @param {Number} [config.clipHeight] set clip height
	     * @param {Function} [config.clipFunc] set clip func
	
	     * @example
	     * var layer = new Konva.Layer();
	     */
	    Konva.BaseLayer = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Util.addMethods(Konva.BaseLayer, {
	        ___init: function(config) {
	            this.nodeType = 'Layer';
	            Konva.Container.call(this, config);
	        },
	        createPNGStream: function() {
	            return this.canvas._canvas.createPNGStream();
	        },
	        /**
	         * get layer canvas
	         * @method
	         * @memberof Konva.BaseLayer.prototype
	         */
	        getCanvas: function() {
	            return this.canvas;
	        },
	        /**
	         * get layer hit canvas
	         * @method
	         * @memberof Konva.BaseLayer.prototype
	         */
	        getHitCanvas: function() {
	            return this.hitCanvas;
	        },
	        /**
	         * get layer canvas context
	         * @method
	         * @memberof Konva.BaseLayer.prototype
	         */
	        getContext: function() {
	            return this.getCanvas().getContext();
	        },
	        /**
	         * clear scene and hit canvas contexts tied to the layer
	         * @method
	         * @memberof Konva.BaseLayer.prototype
	         * @param {Object} [bounds]
	         * @param {Number} [bounds.x]
	         * @param {Number} [bounds.y]
	         * @param {Number} [bounds.width]
	         * @param {Number} [bounds.height]
	         * @example
	         * layer.clear();
	         * layer.clear({
	         *   x : 0,
	         *   y : 0,
	         *   width : 100,
	         *   height : 100
	         * });
	         */
	        clear: function(bounds) {
	            this.getContext().clear(bounds);
	            return this;
	        },
	        clearHitCache: function() {
	            this._hitImageData = undefined;
	        },
	        // extend Node.prototype.setZIndex
	        setZIndex: function(index) {
	            Konva.Node.prototype.setZIndex.call(this, index);
	            var stage = this.getStage();
	            if(stage) {
	                stage.content.removeChild(this.getCanvas()._canvas);
	
	                if(index < stage.getChildren().length - 1) {
	                    stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[index + 1].getCanvas()._canvas);
	                }
	                else {
	                    stage.content.appendChild(this.getCanvas()._canvas);
	                }
	            }
	            return this;
	        },
	        // extend Node.prototype.moveToTop
	        moveToTop: function() {
	            Konva.Node.prototype.moveToTop.call(this);
	            var stage = this.getStage();
	            if(stage) {
	                stage.content.removeChild(this.getCanvas()._canvas);
	                stage.content.appendChild(this.getCanvas()._canvas);
	            }
	            return this;
	        },
	        // extend Node.prototype.moveUp
	        moveUp: function() {
	            var moved = Konva.Node.prototype.moveUp.call(this);
	            if (!moved){
	                return this;
	            }
	            var stage = this.getStage();
	            if(!stage) {
	                return this;
	            }
	            stage.content.removeChild(this.getCanvas()._canvas);
	
	            if(this.index < stage.getChildren().length - 1) {
	                stage.content.insertBefore(this.getCanvas()._canvas, stage.getChildren()[this.index + 1].getCanvas()._canvas);
	            } else {
	                stage.content.appendChild(this.getCanvas()._canvas);
	            }
	            return this;
	        },
	        // extend Node.prototype.moveDown
	        moveDown: function() {
	            if(Konva.Node.prototype.moveDown.call(this)) {
	                var stage = this.getStage();
	                if(stage) {
	                    var children = stage.getChildren();
	                    stage.content.removeChild(this.getCanvas()._canvas);
	                    stage.content.insertBefore(this.getCanvas()._canvas, children[this.index + 1].getCanvas()._canvas);
	                }
	            }
	            return this;
	        },
	        // extend Node.prototype.moveToBottom
	        moveToBottom: function() {
	            if(Konva.Node.prototype.moveToBottom.call(this)) {
	                var stage = this.getStage();
	                if(stage) {
	                    var children = stage.getChildren();
	                    stage.content.removeChild(this.getCanvas()._canvas);
	                    stage.content.insertBefore(this.getCanvas()._canvas, children[1].getCanvas()._canvas);
	                }
	            }
	            return this;
	        },
	        getLayer: function() {
	            return this;
	        },
	        remove: function() {
	            var _canvas = this.getCanvas()._canvas;
	
	            Konva.Node.prototype.remove.call(this);
	
	            if(_canvas && _canvas.parentNode && Konva.Util._isInDocument(_canvas)) {
	                _canvas.parentNode.removeChild(_canvas);
	            }
	            return this;
	        },
	        getStage: function() {
	            return this.parent;
	        },
	        setSize: function(width, height) {
	            this.canvas.setSize(width, height);
	            return this;
	        },
	        /**
	         * get/set width of layer.getter return width of stage. setter doing nothing.
	         * if you want change width use `stage.width(value);`
	         * @name width
	         * @method
	         * @memberof Konva.BaseLayer.prototype
	         * @returns {Number}
	         * @example
	         * var width = layer.width();
	         */
	        getWidth: function() {
	            if (this.parent) {
	                return this.parent.getWidth();
	            }
	        },
	        setWidth: function() {
	            Konva.Util.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
	        },
	        /**
	         * get/set height of layer.getter return height of stage. setter doing nothing.
	         * if you want change height use `stage.height(value);`
	         * @name height
	         * @method
	         * @memberof Konva.BaseLayer.prototype
	         * @returns {Number}
	         * @example
	         * var height = layer.height();
	         */
	        getHeight: function() {
	            if (this.parent) {
	                return this.parent.getHeight();
	            }
	        },
	        setHeight: function() {
	            Konva.Util.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
	        },
	        // the apply transform method is handled by the Layer and FastLayer class
	        // because it is up to the layer to decide if an absolute or relative transform
	        // should be used
	        _applyTransform: function(shape, context, top) {
	            var m = shape.getAbsoluteTransform(top).getMatrix();
	            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	        }
	    });
	    Konva.Util.extend(Konva.BaseLayer, Konva.Container);
	
	    // add getters and setters
	    Konva.Factory.addGetterSetter(Konva.BaseLayer, 'clearBeforeDraw', true);
	    /**
	     * get/set clearBeforeDraw flag which determines if the layer is cleared or not
	     *  before drawing
	     * @name clearBeforeDraw
	     * @method
	     * @memberof Konva.BaseLayer.prototype
	     * @param {Boolean} clearBeforeDraw
	     * @returns {Boolean}
	     * @example
	     * // get clearBeforeDraw flag
	     * var clearBeforeDraw = layer.clearBeforeDraw();
	     *
	     * // disable clear before draw
	     * layer.clearBeforeDraw(false);
	     *
	     * // enable clear before draw
	     * layer.clearBeforeDraw(true);
	     */
	
	    Konva.Collection.mapMethods(Konva.BaseLayer);
	})();
	
	(function() {
	    'use strict';
	    // constants
	    var HASH = '#',
	        BEFORE_DRAW = 'beforeDraw',
	        DRAW = 'draw',
	
	        /*
	         * 2 - 3 - 4
	         * |       |
	         * 1 - 0   5
	         *         |
	         * 8 - 7 - 6
	         */
	        INTERSECTION_OFFSETS = [
	            {x: 0, y: 0},  // 0
	            {x: -1, y: 0}, // 1
	            {x: -1, y: -1}, // 2
	            {x: 0, y: -1}, // 3
	            {x: 1, y: -1}, // 4
	            {x: 1, y: 0}, // 5
	            {x: 1, y: 1}, // 6
	            {x: 0, y: 1}, // 7
	            {x: -1, y: 1}  // 8
	        ],
	        INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;
	
	    /**
	     * Layer constructor.  Layers are tied to their own canvas element and are used
	     * to contain groups or shapes.
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.BaseLayer
	     * @param {Object} config
	     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
	     * to clear the canvas before each layer draw.  The default value is true.
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * * @param {Object} [config.clip] set clip
	     * @param {Number} [config.clipX] set clip x
	     * @param {Number} [config.clipY] set clip y
	     * @param {Number} [config.clipWidth] set clip width
	     * @param {Number} [config.clipHeight] set clip height
	     * @param {Function} [config.clipFunc] set clip func
	
	     * @example
	     * var layer = new Konva.Layer();
	     */
	    Konva.Layer = function(config) {
	        this.____init(config);
	    };
	
	    Konva.Util.addMethods(Konva.Layer, {
	        ____init: function(config) {
	            this.nodeType = 'Layer';
	            this.canvas = new Konva.SceneCanvas();
	            this.hitCanvas = new Konva.HitCanvas({
	                pixelRatio: 1
	            });
	            // call super constructor
	            Konva.BaseLayer.call(this, config);
	        },
	        _setCanvasSize: function(width, height) {
	            this.canvas.setSize(width, height);
	            this.hitCanvas.setSize(width, height);
	        },
	        _validateAdd: function(child) {
	            var type = child.getType();
	            if (type !== 'Group' && type !== 'Shape') {
	                Konva.Util.throw('You may only add groups and shapes to a layer.');
	            }
	        },
	        /**
	         * get visible intersection shape. This is the preferred
	         * method for determining if a point intersects a shape or not
	         * also you may pass optional selector parametr to return ancestor of intersected shape
	         * @method
	         * @memberof Konva.Layer.prototype
	         * @param {Object} pos
	         * @param {Number} pos.x
	         * @param {Number} pos.y
	         * @param {String} [selector]
	         * @returns {Konva.Node}
	         * @example
	         * var shape = layer.getIntersection({x: 50, y: 50});
	         * // or if you interested in shape parent:
	         * var group = layer.getIntersection({x: 50, y: 50}, 'Group');
	         */
	        getIntersection: function(pos, selector) {
	            var obj, i, intersectionOffset, shape;
	
	            if(!this.hitGraphEnabled() || !this.isVisible()) {
	                return null;
	            }
	            // in some cases antialiased area may be bigger than 1px
	            // it is possible if we will cache node, then scale it a lot
	            // TODO: check { 0; 0 } point before loop, and remove it from INTERSECTION_OFFSETS.
	            var spiralSearchDistance = 1;
	            var continueSearch = false;
	            while (true) {
	                for (i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
	                    intersectionOffset = INTERSECTION_OFFSETS[i];
	                    obj = this._getIntersection({
	                        x: pos.x + intersectionOffset.x * spiralSearchDistance,
	                        y: pos.y + intersectionOffset.y * spiralSearchDistance
	                    });
	                    shape = obj.shape;
	                    if (shape && selector) {
	                        return shape.findAncestor(selector, true);
	                    } else if (shape) {
	                        return shape;
	                    }
	                    // we should continue search if we found antialiased pixel
	                    // that means our node somewhere very close
	                    continueSearch = !!obj.antialiased;
	                    // stop search if found empty pixel
	                    if (!obj.antialiased) {
	                        break;
	                    }
	                }
	                // if no shape, and no antialiased pixel, we should end searching
	                if (continueSearch) {
	                    spiralSearchDistance += 1;
	                } else {
	                    return null;
	                }
	            }
	        },
	        _getImageData: function(x, y) {
	            var width = this.hitCanvas.width || 1,
	                height = this.hitCanvas.height || 1,
	                index = (Math.round(y) * width ) + Math.round(x);
	
	            if (!this._hitImageData) {
	                this._hitImageData = this.hitCanvas.context.getImageData(0, 0, width, height);
	            }
	
	            return [
	                this._hitImageData.data[4 * index + 0], // Red
	                this._hitImageData.data[4 * index + 1], // Green
	                this._hitImageData.data[4 * index + 2], // Blue
	                this._hitImageData.data[4 * index + 3] // Alpha
	            ];
	        },
	        _getIntersection: function(pos) {
	            var ratio = this.hitCanvas.pixelRatio;
	            var p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data,
	                p3 = p[3],
	                colorKey, shape;
	            // fully opaque pixel
	            if(p3 === 255) {
	                colorKey = Konva.Util._rgbToHex(p[0], p[1], p[2]);
	                shape = Konva.shapes[HASH + colorKey];
	                if (shape) {
	                    return {
	                        shape: shape
	                    };
	                }
	                return {
	                    antialiased: true
	                };
	            }
	            // antialiased pixel
	            else if(p3 > 0) {
	                return {
	                    antialiased: true
	                };
	            }
	            // empty pixel
	            return {};
	        },
	        drawScene: function(can, top) {
	            var layer = this.getLayer(),
	                canvas = can || (layer && layer.getCanvas());
	
	            this._fire(BEFORE_DRAW, {
	                node: this
	            });
	
	            if(this.getClearBeforeDraw()) {
	                canvas.getContext().clear();
	            }
	
	            Konva.Container.prototype.drawScene.call(this, canvas, top);
	
	            this._fire(DRAW, {
	                node: this
	            });
	
	            return this;
	        },
	        drawHit: function(can, top) {
	            var layer = this.getLayer(),
	                canvas = can || (layer && layer.hitCanvas);
	
	            if(layer && layer.getClearBeforeDraw()) {
	                layer.getHitCanvas().getContext().clear();
	            }
	
	            Konva.Container.prototype.drawHit.call(this, canvas, top);
	            this.imageData = null; // Clear imageData cache
	            return this;
	        },
	        clear: function(bounds) {
	            Konva.BaseLayer.prototype.clear.call(this, bounds);
	            this.getHitCanvas().getContext().clear(bounds);
	            this.imageData = null; // Clear getImageData cache
	            return this;
	        },
	        // extend Node.prototype.setVisible
	        setVisible: function(visible) {
	            Konva.Node.prototype.setVisible.call(this, visible);
	            if(visible) {
	                this.getCanvas()._canvas.style.display = 'block';
	                this.hitCanvas._canvas.style.display = 'block';
	            }
	            else {
	                this.getCanvas()._canvas.style.display = 'none';
	                this.hitCanvas._canvas.style.display = 'none';
	            }
	            return this;
	        },
	        /**
	         * enable hit graph
	         * @name enableHitGraph
	         * @method
	         * @memberof Konva.Layer.prototype
	         * @returns {Layer}
	         */
	        enableHitGraph: function() {
	            this.setHitGraphEnabled(true);
	            return this;
	        },
	        /**
	         * disable hit graph
	         * @name disableHitGraph
	         * @method
	         * @memberof Konva.Layer.prototype
	         * @returns {Layer}
	         */
	        disableHitGraph: function() {
	            this.setHitGraphEnabled(false);
	            return this;
	        },
	        setSize: function(width, height) {
	            Konva.BaseLayer.prototype.setSize.call(this, width, height);
	            this.hitCanvas.setSize(width, height);
	            return this;
	        }
	    });
	    Konva.Util.extend(Konva.Layer, Konva.BaseLayer);
	
	    Konva.Factory.addGetterSetter(Konva.Layer, 'hitGraphEnabled', true);
	    /**
	     * get/set hitGraphEnabled flag.  Disabling the hit graph will greatly increase
	     *  draw performance because the hit graph will not be redrawn each time the layer is
	     *  drawn.  This, however, also disables mouse/touch event detection
	     * @name hitGraphEnabled
	     * @method
	     * @memberof Konva.Layer.prototype
	     * @param {Boolean} enabled
	     * @returns {Boolean}
	     * @example
	     * // get hitGraphEnabled flag
	     * var hitGraphEnabled = layer.hitGraphEnabled();
	     *
	     * // disable hit graph
	     * layer.hitGraphEnabled(false);
	     *
	     * // enable hit graph
	     * layer.hitGraphEnabled(true);
	     */
	    Konva.Collection.mapMethods(Konva.Layer);
	})();
	
	(function() {
	    'use strict';
	    /**
	     * FastLayer constructor. Layers are tied to their own canvas element and are used
	     * to contain shapes only.  If you don't need node nesting, mouse and touch interactions,
	     * or event pub/sub, you should use FastLayer instead of Layer to create your layers.
	     * It renders about 2x faster than normal layers.
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.BaseLayer
	     * @param {Object} config
	     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
	     * to clear the canvas before each layer draw.  The default value is true.
	     * @param {Boolean} [config.visible]
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * * @param {Object} [config.clip] set clip
	     * @param {Number} [config.clipX] set clip x
	     * @param {Number} [config.clipY] set clip y
	     * @param {Number} [config.clipWidth] set clip width
	     * @param {Number} [config.clipHeight] set clip height
	     * @param {Function} [config.clipFunc] set clip func
	
	     * @example
	     * var layer = new Konva.FastLayer();
	     */
	    Konva.FastLayer = function(config) {
	        this.____init(config);
	    };
	
	    Konva.Util.addMethods(Konva.FastLayer, {
	        ____init: function(config) {
	            this.nodeType = 'Layer';
	            this.canvas = new Konva.SceneCanvas();
	            // call super constructor
	            Konva.BaseLayer.call(this, config);
	        },
	        _validateAdd: function(child) {
	            var type = child.getType();
	            if (type !== 'Shape') {
	                Konva.Util.throw('You may only add shapes to a fast layer.');
	            }
	        },
	        _setCanvasSize: function(width, height) {
	            this.canvas.setSize(width, height);
	        },
	        hitGraphEnabled: function() {
	            return false;
	        },
	        getIntersection: function() {
	            return null;
	        },
	        drawScene: function(can) {
	            var layer = this.getLayer(),
	                canvas = can || (layer && layer.getCanvas());
	
	            if(this.getClearBeforeDraw()) {
	                canvas.getContext().clear();
	            }
	
	            Konva.Container.prototype.drawScene.call(this, canvas);
	
	            return this;
	        },
	        draw: function() {
	            this.drawScene();
	            return this;
	        },
	        // extend Node.prototype.setVisible
	        setVisible: function(visible) {
	            Konva.Node.prototype.setVisible.call(this, visible);
	            if(visible) {
	                this.getCanvas()._canvas.style.display = 'block';
	            }
	            else {
	                this.getCanvas()._canvas.style.display = 'none';
	            }
	            return this;
	        }
	    });
	    Konva.Util.extend(Konva.FastLayer, Konva.BaseLayer);
	
	    Konva.Collection.mapMethods(Konva.FastLayer);
	})();
	
	(function() {
	    'use strict';
	    /**
	     * Group constructor.  Groups are used to contain shapes or other groups.
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Container
	     * @param {Object} config
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * * @param {Object} [config.clip] set clip
	     * @param {Number} [config.clipX] set clip x
	     * @param {Number} [config.clipY] set clip y
	     * @param {Number} [config.clipWidth] set clip width
	     * @param {Number} [config.clipHeight] set clip height
	     * @param {Function} [config.clipFunc] set clip func
	
	     * @example
	     * var group = new Konva.Group();
	     */
	    Konva.Group = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Util.addMethods(Konva.Group, {
	        ___init: function(config) {
	            this.nodeType = 'Group';
	            // call super constructor
	            Konva.Container.call(this, config);
	        },
	        _validateAdd: function(child) {
	            var type = child.getType();
	            if (type !== 'Group' && type !== 'Shape') {
	                Konva.Util.throw('You may only add groups and shapes to groups.');
	            }
	        }
	    });
	    Konva.Util.extend(Konva.Group, Konva.Container);
	
	    Konva.Collection.mapMethods(Konva.Group);
	})();
	
	(function(Konva) {
	    'use strict';
	
	    var now = (function() {
	        if (Konva.global.performance && Konva.global.performance.now) {
	            return function() {
	                return Konva.global.performance.now();
	            };
	        }
	
	        return function() {
	            return new Date().getTime();
	        };
	    })();
	
	    function FRAF(callback) {
	        setTimeout(callback, 1000 / 60);
	    }
	
	    var RAF = (function(){
	        return Konva.global.requestAnimationFrame
	            || Konva.global.webkitRequestAnimationFrame
	            || Konva.global.mozRequestAnimationFrame
	            || Konva.global.oRequestAnimationFrame
	            || Konva.global.msRequestAnimationFrame
	            || FRAF;
	    })();
	
	
	
	    function requestAnimFrame() {
	        return RAF.apply(Konva.global, arguments);
	    }
	
	    /**
	     * Animation constructor.  A stage is used to contain multiple layers and handle
	     * @constructor
	     * @memberof Konva
	     * @param {Function} func function executed on each animation frame.  The function is passed a frame object, which contains
	     *  timeDiff, lastTime, time, and frameRate properties.  The timeDiff property is the number of milliseconds that have passed
	     *  since the last animation frame.  The lastTime property is time in milliseconds that elapsed from the moment the animation started
	     *  to the last animation frame.  The time property is the time in milliseconds that ellapsed from the moment the animation started
	     *  to the current animation frame.  The frameRate property is the current frame rate in frames / second. Return false from function,
	     *  if you don't need to redraw layer/layers on some frames.
	     * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn on each animation frame. Can be a layer, an array of layers, or null.
	     *  Not specifying a node will result in no redraw.
	     * @example
	     * // move a node to the right at 50 pixels / second
	     * var velocity = 50;
	     *
	     * var anim = new Konva.Animation(function(frame) {
	     *   var dist = velocity * (frame.timeDiff / 1000);
	     *   node.move(dist, 0);
	     * }, layer);
	     *
	     * anim.start();
	     */
	    Konva.Animation = function(func, layers) {
	        var Anim = Konva.Animation;
	        this.func = func;
	        this.setLayers(layers);
	        this.id = Anim.animIdCounter++;
	        this.frame = {
	            time: 0,
	            timeDiff: 0,
	            lastTime: now()
	        };
	    };
	    /*
	     * Animation methods
	     */
	    Konva.Animation.prototype = {
	        /**
	         * set layers to be redrawn on each animation frame
	         * @method
	         * @memberof Konva.Animation.prototype
	         * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn.&nbsp; Can be a layer, an array of layers, or null.  Not specifying a node will result in no redraw.
	         * @return {Konva.Animation} this
	         */
	        setLayers: function(layers) {
	            var lays = [];
	            // if passing in no layers
	            if (!layers) {
	                lays = [];
	            }
	            // if passing in an array of Layers
	            // NOTE: layers could be an array or Konva.Collection.  for simplicity, I'm just inspecting
	            // the length property to check for both cases
	            else if (layers.length > 0) {
	                lays = layers;
	            }
	            // if passing in a Layer
	            else {
	                lays = [layers];
	            }
	
	            this.layers = lays;
	            return this;
	        },
	        /**
	         * get layers
	         * @method
	         * @memberof Konva.Animation.prototype
	         * @return {Array} Array of Konva.Layer
	         */
	        getLayers: function() {
	            return this.layers;
	        },
	        /**
	         * add layer.  Returns true if the layer was added, and false if it was not
	         * @method
	         * @memberof Konva.Animation.prototype
	         * @param {Konva.Layer} layer to add
	         * @return {Bool} true if layer is added to animation, otherwise false
	         */
	        addLayer: function(layer) {
	            var layers = this.layers,
	                len = layers.length, n;
	
	            // don't add the layer if it already exists
	            for (n = 0; n < len; n++) {
	                if (layers[n]._id === layer._id){
	                    return false;
	                }
	            }
	
	            this.layers.push(layer);
	            return true;
	        },
	        /**
	         * determine if animation is running or not.  returns true or false
	         * @method
	         * @memberof Konva.Animation.prototype
	         * @return {Bool} is animation running?
	         */
	        isRunning: function() {
	            var a = Konva.Animation,
	                animations = a.animations,
	                len = animations.length,
	                n;
	
	            for (n = 0; n < len; n++) {
	                if (animations[n].id === this.id) {
	                    return true;
	                }
	            }
	            return false;
	        },
	        /**
	         * start animation
	         * @method
	         * @memberof Konva.Animation.prototype
	         * @return {Konva.Animation} this
	         */
	        start: function() {
	            var Anim = Konva.Animation;
	            this.stop();
	            this.frame.timeDiff = 0;
	            this.frame.lastTime = now();
	            Anim._addAnimation(this);
	            return this;
	        },
	        /**
	         * stop animation
	         * @method
	         * @memberof Konva.Animation.prototype
	         * @return {Konva.Animation} this
	         */
	        stop: function() {
	            Konva.Animation._removeAnimation(this);
	            return this;
	        },
	        _updateFrameObject: function(time) {
	            this.frame.timeDiff = time - this.frame.lastTime;
	            this.frame.lastTime = time;
	            this.frame.time += this.frame.timeDiff;
	            this.frame.frameRate = 1000 / this.frame.timeDiff;
	        }
	    };
	    Konva.Animation.animations = [];
	    Konva.Animation.animIdCounter = 0;
	    Konva.Animation.animRunning = false;
	
	    Konva.Animation._addAnimation = function(anim) {
	        this.animations.push(anim);
	        this._handleAnimation();
	    };
	    Konva.Animation._removeAnimation = function(anim) {
	        var id = anim.id,
	            animations = this.animations,
	            len = animations.length,
	            n;
	
	        for(n = 0; n < len; n++) {
	            if(animations[n].id === id) {
	                this.animations.splice(n, 1);
	                break;
	            }
	        }
	    };
	
	    Konva.Animation._runFrames = function() {
	        var layerHash = {},
	            animations = this.animations,
	            anim, layers, func, n, i, layersLen, layer, key, needRedraw;
	        /*
	         * loop through all animations and execute animation
	         *  function.  if the animation object has specified node,
	         *  we can add the node to the nodes hash to eliminate
	         *  drawing the same node multiple times.  The node property
	         *  can be the stage itself or a layer
	         */
	        /*
	         * WARNING: don't cache animations.length because it could change while
	         * the for loop is running, causing a JS error
	         */
	
	        for(n = 0; n < animations.length; n++) {
	            anim = animations[n];
	            layers = anim.layers;
	            func = anim.func;
	
	
	            anim._updateFrameObject(now());
	            layersLen = layers.length;
	
	            // if animation object has a function, execute it
	            if (func) {
	                // allow anim bypassing drawing
	                needRedraw = (func.call(anim, anim.frame) !== false);
	            } else {
	                needRedraw = true;
	            }
	            if (!needRedraw) {
	                continue;
	            }
	            for (i = 0; i < layersLen; i++) {
	                layer = layers[i];
	
	                if (layer._id !== undefined) {
	                    layerHash[layer._id] = layer;
	                }
	            }
	        }
	
	        for (key in layerHash) {
	            if (!layerHash.hasOwnProperty(key)) {
	                continue;
	            }
	            layerHash[key].draw();
	        }
	    };
	    Konva.Animation._animationLoop = function() {
	        var Anim = Konva.Animation;
	        if(Anim.animations.length) {
	            Anim._runFrames();
	            requestAnimFrame(Anim._animationLoop);
	        }
	        else {
	            Anim.animRunning = false;
	        }
	    };
	    Konva.Animation._handleAnimation = function() {
	        if(!this.animRunning) {
	            this.animRunning = true;
	            requestAnimFrame(this._animationLoop);
	        }
	    };
	
	    /**
	     * batch draw. this function will not do immediate draw
	     * but it will schedule drawing to next tick (requestAnimFrame)
	     * @method
	     * @return {Konva.Layer} this
	     * @memberof Konva.Base.prototype
	     */
	    Konva.BaseLayer.prototype.batchDraw = function() {
	        var that = this,
	            Anim = Konva.Animation;
	
	        if (!this.batchAnim) {
	            this.batchAnim = new Anim(function() {
	                // stop animation after first tick
	                that.batchAnim.stop();
	            }, this);
	        }
	
	        this.lastBatchDrawTime = now();
	
	        if (!this.batchAnim.isRunning()) {
	            this.batchAnim.start();
	        }
	        return this;
	    };
	
	    /**
	     * batch draw
	     * @method
	     * @return {Konva.Stage} this
	     * @memberof Konva.Stage.prototype
	     */
	    Konva.Stage.prototype.batchDraw = function() {
	        this.getChildren().each(function(layer) {
	            layer.batchDraw();
	        });
	        return this;
	    };
	})(Konva);
	
	(function() {
	    'use strict';
	    var blacklist = {
	        node: 1,
	        duration: 1,
	        easing: 1,
	        onFinish: 1,
	        yoyo: 1
	    },
	
	    PAUSED = 1,
	    PLAYING = 2,
	    REVERSING = 3,
	
	    idCounter = 0,
	    colorAttrs = ['fill', 'stroke', 'shadowColor'];
	
	    var Tween = function(prop, propFunc, func, begin, finish, duration, yoyo) {
	        this.prop = prop;
	        this.propFunc = propFunc;
	        this.begin = begin;
	        this._pos = begin;
	        this.duration = duration;
	        this._change = 0;
	        this.prevPos = 0;
	        this.yoyo = yoyo;
	        this._time = 0;
	        this._position = 0;
	        this._startTime = 0;
	        this._finish = 0;
	        this.func = func;
	        this._change = finish - this.begin;
	        this.pause();
	    };
	    /*
	     * Tween methods
	     */
	    Tween.prototype = {
	        fire: function(str) {
	            var handler = this[str];
	            if (handler) {
	                handler();
	            }
	        },
	        setTime: function(t) {
	            if(t > this.duration) {
	                if(this.yoyo) {
	                    this._time = this.duration;
	                    this.reverse();
	                }
	                else {
	                    this.finish();
	                }
	            }
	            else if(t < 0) {
	                if(this.yoyo) {
	                    this._time = 0;
	                    this.play();
	                }
	                else {
	                    this.reset();
	                }
	            }
	            else {
	                this._time = t;
	                this.update();
	            }
	        },
	        getTime: function() {
	            return this._time;
	        },
	        setPosition: function(p) {
	            this.prevPos = this._pos;
	            this.propFunc(p);
	            this._pos = p;
	        },
	        getPosition: function(t) {
	            if(t === undefined) {
	                t = this._time;
	            }
	            return this.func(t, this.begin, this._change, this.duration);
	        },
	        play: function() {
	            this.state = PLAYING;
	            this._startTime = this.getTimer() - this._time;
	            this.onEnterFrame();
	            this.fire('onPlay');
	        },
	        reverse: function() {
	            this.state = REVERSING;
	            this._time = this.duration - this._time;
	            this._startTime = this.getTimer() - this._time;
	            this.onEnterFrame();
	            this.fire('onReverse');
	        },
	        seek: function(t) {
	            this.pause();
	            this._time = t;
	            this.update();
	            this.fire('onSeek');
	        },
	        reset: function() {
	            this.pause();
	            this._time = 0;
	            this.update();
	            this.fire('onReset');
	        },
	        finish: function() {
	            this.pause();
	            this._time = this.duration;
	            this.update();
	            this.fire('onFinish');
	        },
	        update: function() {
	            this.setPosition(this.getPosition(this._time));
	        },
	        onEnterFrame: function() {
	            var t = this.getTimer() - this._startTime;
	            if(this.state === PLAYING) {
	                this.setTime(t);
	            }
	            else if (this.state === REVERSING) {
	                this.setTime(this.duration - t);
	            }
	        },
	        pause: function() {
	            this.state = PAUSED;
	            this.fire('onPause');
	        },
	        getTimer: function() {
	            return new Date().getTime();
	        }
	    };
	
	    /**
	     * Tween constructor.  Tweens enable you to animate a node between the current state and a new state.
	     *  You can play, pause, reverse, seek, reset, and finish tweens.  By default, tweens are animated using
	     *  a linear easing.  For more tweening options, check out {@link Konva.Easings}
	     * @constructor
	     * @memberof Konva
	     * @example
	     * // instantiate new tween which fully rotates a node in 1 second
	     * var tween = new Konva.Tween({
	     *   node: node,
	     *   rotationDeg: 360,
	     *   duration: 1,
	     *   easing: Konva.Easings.EaseInOut
	     * });
	     *
	     * // play tween
	     * tween.play();
	     *
	     * // pause tween
	     * tween.pause();
	     */
	    Konva.Tween = function(config) {
	        var that = this,
	            node = config.node,
	            nodeId = node._id,
	            duration,
	            easing = config.easing || Konva.Easings.Linear,
	            yoyo = !!config.yoyo,
	            key;
	
	        if (typeof config.duration === 'undefined') {
	            duration = 1;
	        } else if (config.duration === 0) {  // zero is bad value for duration
	            duration = 0.001;
	        } else {
	            duration = config.duration;
	        }
	        this.node = node;
	        this._id = idCounter++;
	
	        var layers = node.getLayer() || ((node instanceof Konva.Stage) ? node.getLayers() : null);
	        if (!layers) {
	            Konva.Util.error(
	                'Tween constructor have `node` that is not in a layer. Please add node into layer first.'
	            );
	        }
	        this.anim = new Konva.Animation(function() {
	            that.tween.onEnterFrame();
	        }, layers);
	
	        this.tween = new Tween(key, function(i) {
	            that._tweenFunc(i);
	        }, easing, 0, 1, duration * 1000, yoyo);
	
	        this._addListeners();
	
	        // init attrs map
	        if (!Konva.Tween.attrs[nodeId]) {
	            Konva.Tween.attrs[nodeId] = {};
	        }
	        if (!Konva.Tween.attrs[nodeId][this._id]) {
	            Konva.Tween.attrs[nodeId][this._id] = {};
	        }
	        // init tweens map
	        if (!Konva.Tween.tweens[nodeId]) {
	            Konva.Tween.tweens[nodeId] = {};
	        }
	
	        for (key in config) {
	            if (blacklist[key] === undefined) {
	                this._addAttr(key, config[key]);
	            }
	        }
	
	        this.reset();
	
	        // callbacks
	        this.onFinish = config.onFinish;
	        this.onReset = config.onReset;
	    };
	
	    // start/diff object = attrs.nodeId.tweenId.attr
	    Konva.Tween.attrs = {};
	    // tweenId = tweens.nodeId.attr
	    Konva.Tween.tweens = {};
	
	    Konva.Tween.prototype = {
	        _addAttr: function(key, end) {
	            var node = this.node,
	                nodeId = node._id,
	                start, diff, tweenId, n, len, trueEnd, trueStart;
	
	            // remove conflict from tween map if it exists
	            tweenId = Konva.Tween.tweens[nodeId][key];
	
	            if (tweenId) {
	                delete Konva.Tween.attrs[nodeId][tweenId][key];
	            }
	
	            // add to tween map
	            start = node.getAttr(key);
	
	            if (Konva.Util._isArray(end)) {
	                diff = [];
	                len = Math.max(end.length, start.length);
	
	                if (key === 'points' && end.length !== start.length) {
	                    // before tweening points we need to make sure that start.length === end.length
	                    // Konva.Util._prepareArrayForTween thinking that end.length > start.length
	
	                    if (end.length > start.length) {
	                        // so in this case we will increase number of starting points
	                        trueStart = start;
	                        start = Konva.Util._prepareArrayForTween(start, end, node.closed());
	                    } else {
	                        // in this case we will increase number of eding points
	                        trueEnd = end;
	                        end = Konva.Util._prepareArrayForTween(end, start, node.closed());
	                    }
	                }
	
	                for (n = 0; n < len; n++) {
	                    diff.push((end[n]) - (start[n]));
	                }
	
	            } else if (colorAttrs.indexOf(key) !== -1) {
	                start = Konva.Util.colorToRGBA(start);
	                var endRGBA = Konva.Util.colorToRGBA(end);
	                diff = {
	                    r: endRGBA.r - start.r,
	                    g: endRGBA.g - start.g,
	                    b: endRGBA.b - start.b,
	                    a: endRGBA.a - start.a
	                };
	            } else {
	                diff = end - start;
	            }
	
	            Konva.Tween.attrs[nodeId][this._id][key] = {
	                start: start,
	                diff: diff,
	                end: end,
	                trueEnd: trueEnd,
	                trueStart: trueStart
	            };
	            Konva.Tween.tweens[nodeId][key] = this._id;
	        },
	        _tweenFunc: function(i) {
	            var node = this.node,
	                attrs = Konva.Tween.attrs[node._id][this._id],
	                key, attr, start, diff, newVal, n, len, end;
	
	            for (key in attrs) {
	                attr = attrs[key];
	                start = attr.start;
	                diff = attr.diff;
	                end = attr.end;
	
	                if (Konva.Util._isArray(start)) {
	                    newVal = [];
	                    len = Math.max(start.length, end.length);
	                    for (n = 0; n < len; n++) {
	                        newVal.push((start[n] || 0) + (diff[n] * i));
	                    }
	                } else if (colorAttrs.indexOf(key) !== -1) {
	                    newVal = 'rgba(' +
	                            Math.round(start.r + diff.r * i) + ',' +
	                            Math.round(start.g + diff.g * i) + ',' +
	                            Math.round(start.b + diff.b * i) + ',' +
	                            (start.a + diff.a * i) + ')';
	                } else {
	                    newVal = start + (diff * i);
	                }
	
	                node.setAttr(key, newVal);
	            }
	        },
	        _addListeners: function() {
	            var that = this;
	
	            // start listeners
	            this.tween.onPlay = function() {
	                that.anim.start();
	            };
	            this.tween.onReverse = function() {
	                that.anim.start();
	            };
	
	            // stop listeners
	            this.tween.onPause = function() {
	                that.anim.stop();
	            };
	            this.tween.onFinish = function() {
	                var node = that.node;
	
	                // after tweening  points of line we need to set original end
	                var attrs = Konva.Tween.attrs[node._id][that._id];
	                if (attrs.points && attrs.points.trueEnd) {
	                    node.points(attrs.points.trueEnd);
	                }
	
	                if (that.onFinish) {
	                    that.onFinish.call(that);
	                }
	            };
	            this.tween.onReset = function() {
	                var node = that.node;
	                // after tweening  points of line we need to set original start
	                var attrs = Konva.Tween.attrs[node._id][that._id];
	                if (attrs.points && attrs.points.trueStart) {
	                    node.points(attrs.points.trueStart);
	                }
	
	                if (that.onReset) {
	                    that.onReset();
	                }
	            };
	        },
	        /**
	         * play
	         * @method
	         * @memberof Konva.Tween.prototype
	         * @returns {Tween}
	         */
	        play: function() {
	            this.tween.play();
	            return this;
	        },
	        /**
	         * reverse
	         * @method
	         * @memberof Konva.Tween.prototype
	         * @returns {Tween}
	         */
	        reverse: function() {
	            this.tween.reverse();
	            return this;
	        },
	        /**
	         * reset
	         * @method
	         * @memberof Konva.Tween.prototype
	         * @returns {Tween}
	         */
	        reset: function() {
	            this.tween.reset();
	            return this;
	        },
	        /**
	         * seek
	         * @method
	         * @memberof Konva.Tween.prototype
	         * @param {Integer} t time in seconds between 0 and the duration
	         * @returns {Tween}
	         */
	        seek: function(t) {
	            this.tween.seek(t * 1000);
	            return this;
	        },
	        /**
	         * pause
	         * @method
	         * @memberof Konva.Tween.prototype
	         * @returns {Tween}
	         */
	        pause: function() {
	            this.tween.pause();
	            return this;
	        },
	        /**
	         * finish
	         * @method
	         * @memberof Konva.Tween.prototype
	         * @returns {Tween}
	         */
	        finish: function() {
	            this.tween.finish();
	            return this;
	        },
	        /**
	         * destroy
	         * @method
	         * @memberof Konva.Tween.prototype
	         */
	        destroy: function() {
	            var nodeId = this.node._id,
	                thisId = this._id,
	                attrs = Konva.Tween.tweens[nodeId],
	                key;
	
	            this.pause();
	
	            for (key in attrs) {
	                delete Konva.Tween.tweens[nodeId][key];
	            }
	
	            delete Konva.Tween.attrs[nodeId][thisId];
	        }
	    };
	
	    /**
	     * Tween node properties. Shorter usage of {@link Konva.Tween} object.
	     *
	     * @method Konva.Node#to
	     * @memberof Konva.Node
	     * @param {Object} [params] tween params
	     * @example
	     *
	     * circle.to({
	     *  x : 50,
	     *  duration : 0.5
	     * });
	     */
	    Konva.Node.prototype.to = function(params) {
	        var onFinish = params.onFinish;
	        params.node = this;
	        params.onFinish = function() {
	            this.destroy();
	            if (onFinish) {
	                onFinish();
	            }
	        };
	        var tween = new Konva.Tween(params);
	        tween.play();
	    };
	
	    /*
	    * These eases were ported from an Adobe Flash tweening library to JavaScript
	    * by Xaric
	    */
	
	    /**
	     * @namespace Easings
	     * @memberof Konva
	     */
	    Konva.Easings = {
	        /**
	        * back ease in
	        * @function
	        * @memberof Konva.Easings
	        */
	        'BackEaseIn': function(t, b, c, d) {
	            var s = 1.70158;
	            return c * (t /= d) * t * ((s + 1) * t - s) + b;
	        },
	        /**
	        * back ease out
	        * @function
	        * @memberof Konva.Easings
	        */
	        'BackEaseOut': function(t, b, c, d) {
	            var s = 1.70158;
	            return c * (( t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	        },
	        /**
	        * back ease in out
	        * @function
	        * @memberof Konva.Easings
	        */
	        'BackEaseInOut': function(t, b, c, d) {
	            var s = 1.70158;
	            if((t /= d / 2) < 1) {
	                return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
	            }
	            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
	        },
	        /**
	        * elastic ease in
	        * @function
	        * @memberof Konva.Easings
	        */
	        'ElasticEaseIn': function(t, b, c, d, a, p) {
	            // added s = 0
	            var s = 0;
	            if(t === 0) {
	                return b;
	            }
	            if((t /= d) === 1) {
	                return b + c;
	            }
	            if(!p) {
	                p = d * 0.3;
	            }
	            if(!a || a < Math.abs(c)) {
	                a = c;
	                s = p / 4;
	            }
	            else {
	                s = p / (2 * Math.PI) * Math.asin(c / a);
	            }
	            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	        },
	        /**
	        * elastic ease out
	        * @function
	        * @memberof Konva.Easings
	        */
	        'ElasticEaseOut': function(t, b, c, d, a, p) {
	            // added s = 0
	            var s = 0;
	            if(t === 0) {
	                return b;
	            }
	            if((t /= d) === 1) {
	                return b + c;
	            }
	            if(!p) {
	                p = d * 0.3;
	            }
	            if(!a || a < Math.abs(c)) {
	                a = c;
	                s = p / 4;
	            }
	            else {
	                s = p / (2 * Math.PI) * Math.asin(c / a);
	            }
	            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
	        },
	        /**
	        * elastic ease in out
	        * @function
	        * @memberof Konva.Easings
	        */
	        'ElasticEaseInOut': function(t, b, c, d, a, p) {
	            // added s = 0
	            var s = 0;
	            if(t === 0) {
	                return b;
	            }
	            if((t /= d / 2) === 2) {
	                return b + c;
	            }
	            if(!p) {
	                p = d * (0.3 * 1.5);
	            }
	            if(!a || a < Math.abs(c)) {
	                a = c;
	                s = p / 4;
	            }
	            else {
	                s = p / (2 * Math.PI) * Math.asin(c / a);
	            }
	            if(t < 1) {
	                return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	            }
	            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
	        },
	        /**
	        * bounce ease out
	        * @function
	        * @memberof Konva.Easings
	        */
	        'BounceEaseOut': function(t, b, c, d) {
	            if((t /= d) < (1 / 2.75)) {
	                return c * (7.5625 * t * t) + b;
	            }
	            else if(t < (2 / 2.75)) {
	                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
	            }
	            else if(t < (2.5 / 2.75)) {
	                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
	            }
	            else {
	                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
	            }
	        },
	        /**
	        * bounce ease in
	        * @function
	        * @memberof Konva.Easings
	        */
	        'BounceEaseIn': function(t, b, c, d) {
	            return c - Konva.Easings.BounceEaseOut(d - t, 0, c, d) + b;
	        },
	        /**
	        * bounce ease in out
	        * @function
	        * @memberof Konva.Easings
	        */
	        'BounceEaseInOut': function(t, b, c, d) {
	            if(t < d / 2) {
	                return Konva.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
	            }
	            else {
	                return Konva.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
	            }
	        },
	        /**
	        * ease in
	        * @function
	        * @memberof Konva.Easings
	        */
	        'EaseIn': function(t, b, c, d) {
	            return c * (t /= d) * t + b;
	        },
	        /**
	        * ease out
	        * @function
	        * @memberof Konva.Easings
	        */
	        'EaseOut': function(t, b, c, d) {
	            return -c * (t /= d) * (t - 2) + b;
	        },
	        /**
	        * ease in out
	        * @function
	        * @memberof Konva.Easings
	        */
	        'EaseInOut': function(t, b, c, d) {
	            if((t /= d / 2) < 1) {
	                return c / 2 * t * t + b;
	            }
	            return -c / 2 * ((--t) * (t - 2) - 1) + b;
	        },
	        /**
	        * strong ease in
	        * @function
	        * @memberof Konva.Easings
	        */
	        'StrongEaseIn': function(t, b, c, d) {
	            return c * (t /= d) * t * t * t * t + b;
	        },
	        /**
	        * strong ease out
	        * @function
	        * @memberof Konva.Easings
	        */
	        'StrongEaseOut': function(t, b, c, d) {
	            return c * (( t = t / d - 1) * t * t * t * t + 1) + b;
	        },
	        /**
	        * strong ease in out
	        * @function
	        * @memberof Konva.Easings
	        */
	        'StrongEaseInOut': function(t, b, c, d) {
	            if((t /= d / 2) < 1) {
	                return c / 2 * t * t * t * t * t + b;
	            }
	            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	        },
	        /**
	        * linear
	        * @function
	        * @memberof Konva.Easings
	        */
	        'Linear': function(t, b, c, d) {
	            return c * t / d + b;
	        }
	    };
	})();
	
	(function() {
	    'use strict';
	    Konva.DD = {
	        // properties
	        anim: new Konva.Animation(function() {
	            var b = this.dirty;
	            this.dirty = false;
	            return b;
	        }),
	        isDragging: false,
	        justDragged: false,
	        offset: {
	            x: 0,
	            y: 0
	        },
	        node: null,
	
	        // methods
	        _drag: function(evt) {
	            var dd = Konva.DD,
	                node = dd.node;
	
	            if(node) {
	               if(!dd.isDragging) {
	                    var pos = node.getStage().getPointerPosition();
	                    var dragDistance = node.dragDistance();
	                    var distance = Math.max(
	                        Math.abs(pos.x - dd.startPointerPos.x),
	                        Math.abs(pos.y - dd.startPointerPos.y)
	                    );
	                    if (distance < dragDistance) {
	                        return;
	                    }
	                }
	
	
	                node.getStage()._setPointerPosition(evt);
	                node._setDragPosition(evt);
	                if(!dd.isDragging) {
	                    dd.isDragging = true;
	                    node.fire('dragstart', {
	                        type: 'dragstart',
	                        target: node,
	                        evt: evt
	                    }, true);
	                }
	
	                // execute ondragmove if defined
	                node.fire('dragmove', {
	                    type: 'dragmove',
	                    target: node,
	                    evt: evt
	                }, true);
	            }
	        },
	        _endDragBefore: function(evt) {
	            var dd = Konva.DD,
	                node = dd.node,
	                layer;
	
	            if(node) {
	                layer = node.getLayer();
	                dd.anim.stop();
	
	                // only fire dragend event if the drag and drop
	                // operation actually started.
	                if(dd.isDragging) {
	                    dd.isDragging = false;
	                    dd.justDragged = true;
	                    Konva.listenClickTap = false;
	
	                    if (evt) {
	                        evt.dragEndNode = node;
	                    }
	                }
	
	                delete dd.node;
	
	                if (node.getLayer() || layer || (node instanceof Konva.Stage)) {
	                  (layer || node).draw();
	                }
	
	            }
	        },
	        _endDragAfter: function(evt) {
	            evt = evt || {};
	            var dragEndNode = evt.dragEndNode;
	
	            if (evt && dragEndNode) {
	                dragEndNode.fire('dragend', {
	                    type: 'dragend',
	                    target: dragEndNode,
	                    evt: evt
	                }, true);
	            }
	        }
	    };
	
	    // Node extenders
	
	    /**
	     * initiate drag and drop
	     * @method
	     * @memberof Konva.Node.prototype
	     */
	    Konva.Node.prototype.startDrag = function() {
	        var dd = Konva.DD,
	            stage = this.getStage(),
	            layer = this.getLayer(),
	            pos = stage.getPointerPosition(),
	            ap = this.getAbsolutePosition();
	
	        if(pos) {
	            if (dd.node) {
	                dd.node.stopDrag();
	            }
	
	            dd.node = this;
	            dd.startPointerPos = pos;
	            dd.offset.x = pos.x - ap.x;
	            dd.offset.y = pos.y - ap.y;
	            dd.anim.setLayers(layer || this.getLayers());
	            dd.anim.start();
	
	            this._setDragPosition();
	        }
	    };
	
	    Konva.Node.prototype._setDragPosition = function(evt) {
	        var dd = Konva.DD,
	            pos = this.getStage().getPointerPosition(),
	            dbf = this.getDragBoundFunc();
	        if (!pos) {
	            return;
	        }
	        var newNodePos = {
	            x: pos.x - dd.offset.x,
	            y: pos.y - dd.offset.y
	        };
	
	        if(dbf !== undefined) {
	            newNodePos = dbf.call(this, newNodePos, evt);
	        }
	        this.setAbsolutePosition(newNodePos);
	
	        if (!this._lastPos || this._lastPos.x !== newNodePos.x ||
	            this._lastPos.y !== newNodePos.y) {
	            dd.anim.dirty = true;
	        }
	
	        this._lastPos = newNodePos;
	    };
	
	    /**
	     * stop drag and drop
	     * @method
	     * @memberof Konva.Node.prototype
	     */
	    Konva.Node.prototype.stopDrag = function() {
	        var dd = Konva.DD,
	            evt = {};
	        dd._endDragBefore(evt);
	        dd._endDragAfter(evt);
	    };
	
	    Konva.Node.prototype.setDraggable = function(draggable) {
	        this._setAttr('draggable', draggable);
	        this._dragChange();
	    };
	
	    var origDestroy = Konva.Node.prototype.destroy;
	
	    Konva.Node.prototype.destroy = function() {
	        var dd = Konva.DD;
	
	        // stop DD
	        if(dd.node && dd.node._id === this._id) {
	
	            this.stopDrag();
	        }
	
	        origDestroy.call(this);
	    };
	
	    /**
	     * determine if node is currently in drag and drop mode
	     * @method
	     * @memberof Konva.Node.prototype
	     */
	    Konva.Node.prototype.isDragging = function() {
	        var dd = Konva.DD;
	        return !!(dd.node && dd.node._id === this._id && dd.isDragging);
	    };
	
	    Konva.Node.prototype._listenDrag = function() {
	        var that = this;
	
	        this._dragCleanup();
	
	        if (this.getClassName() === 'Stage') {
	            this.on('contentMousedown.konva contentTouchstart.konva', function(evt) {
	                if(!Konva.DD.node) {
	                    that.startDrag(evt);
	                }
	            });
	        }
	        else {
	            this.on('mousedown.konva touchstart.konva', function(evt) {
	                // ignore right and middle buttons
	                if (evt.evt.button === 1 || evt.evt.button === 2) {
	                    return;
	                }
	                if(!Konva.DD.node) {
	                    that.startDrag(evt);
	                }
	            });
	        }
	
	        // listening is required for drag and drop
	        /*
	        this._listeningEnabled = true;
	        this._clearSelfAndAncestorCache('listeningEnabled');
	        */
	    };
	
	    Konva.Node.prototype._dragChange = function() {
	        if(this.attrs.draggable) {
	            this._listenDrag();
	        }
	        else {
	            // remove event listeners
	            this._dragCleanup();
	
	            /*
	             * force drag and drop to end
	             * if this node is currently in
	             * drag and drop mode
	             */
	            var stage = this.getStage();
	            var dd = Konva.DD;
	            if(stage && dd.node && dd.node._id === this._id) {
	                dd.node.stopDrag();
	            }
	        }
	    };
	
	    Konva.Node.prototype._dragCleanup = function() {
	        if (this.getClassName() === 'Stage') {
	            this.off('contentMousedown.konva');
	            this.off('contentTouchstart.konva');
	        } else {
	            this.off('mousedown.konva');
	            this.off('touchstart.konva');
	        }
	    };
	
	    Konva.Factory.addGetterSetter(Konva.Node, 'dragBoundFunc');
	
	    /**
	     * get/set drag bound function.  This is used to override the default
	     *  drag and drop position
	     * @name dragBoundFunc
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Function} dragBoundFunc
	     * @returns {Function}
	     * @example
	     * // get drag bound function
	     * var dragBoundFunc = node.dragBoundFunc();
	     *
	     * // create vertical drag and drop
	     * node.dragBoundFunc(function(pos){
	     *   return {
	     *     x: this.getAbsolutePosition().x,
	     *     y: pos.y
	     *   };
	     * });
	     */
	
	    Konva.Factory.addGetter(Konva.Node, 'draggable', false);
	    Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'draggable');
	
	     /**
	     * get/set draggable flag
	     * @name draggable
	     * @method
	     * @memberof Konva.Node.prototype
	     * @param {Boolean} draggable
	     * @returns {Boolean}
	     * @example
	     * // get draggable flag
	     * var draggable = node.draggable();
	     *
	     * // enable drag and drop
	     * node.draggable(true);
	     *
	     * // disable drag and drop
	     * node.draggable(false);
	     */
	
	    var html = Konva.document.documentElement;
	    html.addEventListener('mouseup', Konva.DD._endDragBefore, true);
	    html.addEventListener('touchend', Konva.DD._endDragBefore, true);
	
	    html.addEventListener('mousemove', Konva.DD._drag);
	    html.addEventListener('touchmove', Konva.DD._drag);
	
	    html.addEventListener('mouseup', Konva.DD._endDragAfter, false);
	    html.addEventListener('touchend', Konva.DD._endDragAfter, false);
	
	})();
	
	(function() {
	    'use strict';
	    /**
	     * Rect constructor
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {Number} [config.cornerRadius]
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var rect = new Konva.Rect({
	     *   width: 100,
	     *   height: 50,
	     *   fill: 'red',
	     *   stroke: 'black',
	     *   strokeWidth: 5
	     * });
	     */
	    Konva.Rect = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Rect.prototype = {
	        ___init: function(config) {
	            Konva.Shape.call(this, config);
	            this.className = 'Rect';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var cornerRadius = this.getCornerRadius(),
	                width = this.getWidth(),
	                height = this.getHeight();
	
	            context.beginPath();
	
	            if(!cornerRadius) {
	                // simple rect - don't bother doing all that complicated maths stuff.
	                context.rect(0, 0, width, height);
	            } else {
	                // arcTo would be nicer, but browser support is patchy (Opera)
	                cornerRadius = Math.min(cornerRadius, width / 2, height / 2);
	                context.moveTo(cornerRadius, 0);
	                context.lineTo(width - cornerRadius, 0);
	                context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
	                context.lineTo(width, height - cornerRadius);
	                context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
	                context.lineTo(cornerRadius, height);
	                context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
	                context.lineTo(0, cornerRadius);
	                context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
	            }
	            context.closePath();
	            context.fillStrokeShape(this);
	        }
	    };
	
	    Konva.Util.extend(Konva.Rect, Konva.Shape);
	
	    Konva.Factory.addGetterSetter(Konva.Rect, 'cornerRadius', 0);
	    /**
	     * get/set corner radius
	     * @name cornerRadius
	     * @method
	     * @memberof Konva.Rect.prototype
	     * @param {Number} cornerRadius
	     * @returns {Number}
	     * @example
	     * // get corner radius
	     * var cornerRadius = rect.cornerRadius();
	     *
	     * // set corner radius
	     * rect.cornerRadius(10);
	     */
	
	    Konva.Collection.mapMethods(Konva.Rect);
	})();
	
	(function() {
	    'use strict';
	    // the 0.0001 offset fixes a bug in Chrome 27
	    var PIx2 = (Math.PI * 2) - 0.0001,
	        CIRCLE = 'Circle';
	
	    /**
	     * Circle constructor
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {Number} config.radius
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * // create circle
	     * var circle = new Konva.Circle({
	     *   radius: 40,
	     *   fill: 'red',
	     *   stroke: 'black'
	     *   strokeWidth: 5
	     * });
	     */
	    Konva.Circle = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Circle.prototype = {
	        _centroid: true,
	        ___init: function(config) {
	            // call super constructor
	            Konva.Shape.call(this, config);
	            this.className = CIRCLE;
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            context.beginPath();
	            context.arc(0, 0, this.getRadius(), 0, PIx2, false);
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        // implements Shape.prototype.getWidth()
	        getWidth: function() {
	            return this.getRadius() * 2;
	        },
	        // implements Shape.prototype.getHeight()
	        getHeight: function() {
	            return this.getRadius() * 2;
	        },
	        // implements Shape.prototype.setWidth()
	        setWidth: function(width) {
	            Konva.Node.prototype.setWidth.call(this, width);
	            if (this.radius() !== width / 2) {
	                this.setRadius(width / 2);
	            }
	        },
	        // implements Shape.prototype.setHeight()
	        setHeight: function(height) {
	            Konva.Node.prototype.setHeight.call(this, height);
	            if (this.radius() !== height / 2) {
	                this.setRadius(height / 2);
	            }
	        }
	    };
	    Konva.Util.extend(Konva.Circle, Konva.Shape);
	
	    // add getters setters
	    Konva.Factory.addGetterSetter(Konva.Circle, 'radius', 0);
	    Konva.Factory.addOverloadedGetterSetter(Konva.Circle, 'radius');
	
	    /**
	     * get/set radius
	     * @name radius
	     * @method
	     * @memberof Konva.Circle.prototype
	     * @param {Number} radius
	     * @returns {Number}
	     * @example
	     * // get radius
	     * var radius = circle.radius();
	     *
	     * // set radius
	     * circle.radius(10);
	     */
	
	    Konva.Collection.mapMethods(Konva.Circle);
	})();
	
	(function() {
	    'use strict';
	    // the 0.0001 offset fixes a bug in Chrome 27
	    var PIx2 = (Math.PI * 2) - 0.0001,
	        ELLIPSE = 'Ellipse';
	
	    /**
	     * Ellipse constructor
	     * @constructor
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {Object} config.radius defines x and y radius
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var ellipse = new Konva.Ellipse({
	     *   radius : {
	     *     x : 50,
	     *     y : 50
	     *   },
	     *   fill: 'red'
	     * });
	     */
	    Konva.Ellipse = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Ellipse.prototype = {
	        _centroid: true,
	        ___init: function(config) {
	            // call super constructor
	            Konva.Shape.call(this, config);
	            this.className = ELLIPSE;
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var rx = this.getRadiusX(),
	                ry = this.getRadiusY();
	
	            context.beginPath();
	            context.save();
	            if(rx !== ry) {
	                context.scale(1, ry / rx);
	            }
	            context.arc(0, 0, rx, 0, PIx2, false);
	            context.restore();
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        // implements Shape.prototype.getWidth()
	        getWidth: function() {
	            return this.getRadiusX() * 2;
	        },
	        // implements Shape.prototype.getHeight()
	        getHeight: function() {
	            return this.getRadiusY() * 2;
	        },
	        // implements Shape.prototype.setWidth()
	        setWidth: function(width) {
	            Konva.Node.prototype.setWidth.call(this, width);
	            this.setRadius({
	                x: width / 2
	            });
	        },
	        // implements Shape.prototype.setHeight()
	        setHeight: function(height) {
	            Konva.Node.prototype.setHeight.call(this, height);
	            this.setRadius({
	                y: height / 2
	            });
	        }
	    };
	    Konva.Util.extend(Konva.Ellipse, Konva.Shape);
	
	    // add getters setters
	    Konva.Factory.addComponentsGetterSetter(Konva.Ellipse, 'radius', ['x', 'y']);
	
	    /**
	     * get/set radius
	     * @name radius
	     * @method
	     * @memberof Konva.Ellipse.prototype
	     * @param {Object} radius
	     * @param {Number} radius.x
	     * @param {Number} radius.y
	     * @returns {Object}
	     * @example
	     * // get radius
	     * var radius = ellipse.radius();
	     *
	     * // set radius
	     * ellipse.radius({
	     *   x: 200,
	     *   y: 100
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusX', 0);
	    /**
	     * get/set radius x
	     * @name radiusX
	     * @method
	     * @memberof Konva.Ellipse.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get radius x
	     * var radiusX = ellipse.radiusX();
	     *
	     * // set radius x
	     * ellipse.radiusX(200);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusY', 0);
	    /**
	     * get/set radius y
	     * @name radiusY
	     * @method
	     * @memberof Konva.Ellipse.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get radius y
	     * var radiusY = ellipse.radiusY();
	     *
	     * // set radius y
	     * ellipse.radiusY(200);
	     */
	
	    Konva.Collection.mapMethods(Konva.Ellipse);
	
	})();
	
	(function() {
	    'use strict';
	    // the 0.0001 offset fixes a bug in Chrome 27
	    var PIx2 = (Math.PI * 2) - 0.0001;
	    /**
	     * Ring constructor
	     * @constructor
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {Number} config.innerRadius
	     * @param {Number} config.outerRadius
	     * @param {Boolean} [config.clockwise]
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var ring = new Konva.Ring({
	     *   innerRadius: 40,
	     *   outerRadius: 80,
	     *   fill: 'red',
	     *   stroke: 'black',
	     *   strokeWidth: 5
	     * });
	     */
	    Konva.Ring = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Ring.prototype = {
	        _centroid: true,
	        ___init: function(config) {
	            // call super constructor
	            Konva.Shape.call(this, config);
	            this.className = 'Ring';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            context.beginPath();
	            context.arc(0, 0, this.getInnerRadius(), 0, PIx2, false);
	            context.moveTo(this.getOuterRadius(), 0);
	            context.arc(0, 0, this.getOuterRadius(), PIx2, 0, true);
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        // implements Shape.prototype.getWidth()
	        getWidth: function() {
	            return this.getOuterRadius() * 2;
	        },
	        // implements Shape.prototype.getHeight()
	        getHeight: function() {
	            return this.getOuterRadius() * 2;
	        },
	        // implements Shape.prototype.setWidth()
	        setWidth: function(width) {
	            Konva.Node.prototype.setWidth.call(this, width);
	            if (this.outerRadius() !== width / 2) {
	                this.setOuterRadius(width / 2);
	            }
	        },
	        // implements Shape.prototype.setHeight()
	        setHeight: function(height) {
	            Konva.Node.prototype.setHeight.call(this, height);
	            if (this.outerRadius() !== height / 2) {
	                this.setOuterRadius(height / 2);
	            }
	        },
	        setOuterRadius: function(val) {
	            this._setAttr('outerRadius', val);
	            this.setWidth(val * 2);
	            this.setHeight(val * 2);
	        }
	    };
	    Konva.Util.extend(Konva.Ring, Konva.Shape);
	
	    // add getters setters
	    Konva.Factory.addGetterSetter(Konva.Ring, 'innerRadius', 0);
	
	    /**
	     * get/set innerRadius
	     * @name innerRadius
	     * @method
	     * @memberof Konva.Ring.prototype
	     * @param {Number} innerRadius
	     * @returns {Number}
	     * @example
	     * // get inner radius
	     * var innerRadius = ring.innerRadius();
	     *
	     * // set inner radius
	     * ring.innerRadius(20);
	     */
	    Konva.Factory.addGetter(Konva.Ring, 'outerRadius', 0);
	    Konva.Factory.addOverloadedGetterSetter(Konva.Ring, 'outerRadius');
	
	    /**
	     * get/set outerRadius
	     * @name outerRadius
	     * @method
	     * @memberof Konva.Ring.prototype
	     * @param {Number} outerRadius
	     * @returns {Number}
	     * @example
	     * // get outer radius
	     * var outerRadius = ring.outerRadius();
	     *
	     * // set outer radius
	     * ring.outerRadius(20);
	     */
	
	    Konva.Collection.mapMethods(Konva.Ring);
	})();
	
	(function() {
	    'use strict';
	    /**
	     * Wedge constructor
	     * @constructor
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {Number} config.angle in degrees
	     * @param {Number} config.radius
	     * @param {Boolean} [config.clockwise]
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * // draw a wedge that's pointing downwards
	     * var wedge = new Konva.Wedge({
	     *   radius: 40,
	     *   fill: 'red',
	     *   stroke: 'black'
	     *   strokeWidth: 5,
	     *   angleDeg: 60,
	     *   rotationDeg: -120
	     * });
	     */
	    Konva.Wedge = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Wedge.prototype = {
	        _centroid: true,
	        ___init: function(config) {
	            // call super constructor
	            Konva.Shape.call(this, config);
	            this.className = 'Wedge';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            context.beginPath();
	            context.arc(0, 0, this.getRadius(), 0, Konva.getAngle(this.getAngle()), this.getClockwise());
	            context.lineTo(0, 0);
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        // implements Shape.prototype.getWidth()
	        getWidth: function() {
	            return this.getRadius() * 2;
	        },
	        // implements Shape.prototype.getHeight()
	        getHeight: function() {
	            return this.getRadius() * 2;
	        },
	        // implements Shape.prototype.setWidth()
	        setWidth: function(width) {
	            Konva.Node.prototype.setWidth.call(this, width);
	            if (this.radius() !== width / 2) {
	                this.setRadius(width / 2);
	            }
	        },
	        // implements Shape.prototype.setHeight()
	        setHeight: function(height) {
	            Konva.Node.prototype.setHeight.call(this, height);
	            if (this.radius() !== height / 2) {
	                this.setRadius(height / 2);
	            }
	        }
	    };
	    Konva.Util.extend(Konva.Wedge, Konva.Shape);
	
	    // add getters setters
	    Konva.Factory.addGetterSetter(Konva.Wedge, 'radius', 0);
	
	    /**
	     * get/set radius
	     * @name radius
	     * @method
	     * @memberof Konva.Wedge.prototype
	     * @param {Number} radius
	     * @returns {Number}
	     * @example
	     * // get radius
	     * var radius = wedge.radius();
	     *
	     * // set radius
	     * wedge.radius(10);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Wedge, 'angle', 0);
	
	    /**
	     * get/set angle in degrees
	     * @name angle
	     * @method
	     * @memberof Konva.Wedge.prototype
	     * @param {Number} angle
	     * @returns {Number}
	     * @example
	     * // get angle
	     * var angle = wedge.angle();
	     *
	     * // set angle
	     * wedge.angle(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Wedge, 'clockwise', false);
	
	    /**
	     * get/set clockwise flag
	     * @name clockwise
	     * @method
	     * @memberof Konva.Wedge.prototype
	     * @param {Number} clockwise
	     * @returns {Number}
	     * @example
	     * // get clockwise flag
	     * var clockwise = wedge.clockwise();
	     *
	     * // draw wedge counter-clockwise
	     * wedge.clockwise(false);
	     *
	     * // draw wedge clockwise
	     * wedge.clockwise(true);
	     */
	
	    Konva.Factory.backCompat(Konva.Wedge, {
	        angleDeg: 'angle',
	        getAngleDeg: 'getAngle',
	        setAngleDeg: 'setAngle'
	    });
	
	    Konva.Collection.mapMethods(Konva.Wedge);
	})();
	
	(function() {
	    'use strict';
	    /**
	     * Arc constructor
	     * @constructor
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {Number} config.angle in degrees
	     * @param {Number} config.innerRadius
	     * @param {Number} config.outerRadius
	     * @param {Boolean} [config.clockwise]
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * // draw a Arc that's pointing downwards
	     * var arc = new Konva.Arc({
	     *   innerRadius: 40,
	     *   outerRadius: 80,
	     *   fill: 'red',
	     *   stroke: 'black'
	     *   strokeWidth: 5,
	     *   angle: 60,
	     *   rotationDeg: -120
	     * });
	     */
	    Konva.Arc = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Arc.prototype = {
	        _centroid: true,
	        ___init: function(config) {
	            // call super constructor
	            Konva.Shape.call(this, config);
	            this.className = 'Arc';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var angle = Konva.getAngle(this.angle()),
	                clockwise = this.clockwise();
	
	            context.beginPath();
	            context.arc(0, 0, this.getOuterRadius(), 0, angle, clockwise);
	            context.arc(0, 0, this.getInnerRadius(), angle, 0, !clockwise);
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        // implements Shape.prototype.getWidth()
	        getWidth: function() {
	            return this.getOuterRadius() * 2;
	        },
	        // implements Shape.prototype.getHeight()
	        getHeight: function() {
	            return this.getOuterRadius() * 2;
	        },
	        // implements Shape.prototype.setWidth()
	        setWidth: function(width) {
	            Konva.Node.prototype.setWidth.call(this, width);
	            if (this.getOuterRadius() !== width / 2) {
	                this.setOuterRadius(width / 2);
	            }
	        },
	        // implements Shape.prototype.setHeight()
	        setHeight: function(height) {
	            Konva.Node.prototype.setHeight.call(this, height);
	            if (this.getOuterRadius() !== height / 2) {
	                this.setOuterRadius(height / 2);
	            }
	        }
	    };
	    Konva.Util.extend(Konva.Arc, Konva.Shape);
	
	    // add getters setters
	    Konva.Factory.addGetterSetter(Konva.Arc, 'innerRadius', 0);
	
	    /**
	     * get/set innerRadius
	     * @name innerRadius
	     * @method
	     * @memberof Konva.Arc.prototype
	     * @param {Number} innerRadius
	     * @returns {Number}
	     * @example
	     * // get inner radius
	     * var innerRadius = arc.innerRadius();
	     *
	     * // set inner radius
	     * arc.innerRadius(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Arc, 'outerRadius', 0);
	
	    /**
	     * get/set outerRadius
	     * @name outerRadius
	     * @method
	     * @memberof Konva.Arc.prototype
	     * @param {Number} outerRadius
	     * @returns {Number}
	     * @example
	     * // get outer radius
	     * var outerRadius = arc.outerRadius();
	     *
	     * // set outer radius
	     * arc.outerRadius(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Arc, 'angle', 0);
	
	    /**
	     * get/set angle in degrees
	     * @name angle
	     * @method
	     * @memberof Konva.Arc.prototype
	     * @param {Number} angle
	     * @returns {Number}
	     * @example
	     * // get angle
	     * var angle = arc.angle();
	     *
	     * // set angle
	     * arc.angle(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Arc, 'clockwise', false);
	
	    /**
	     * get/set clockwise flag
	     * @name clockwise
	     * @method
	     * @memberof Konva.Arc.prototype
	     * @param {Boolean} clockwise
	     * @returns {Boolean}
	     * @example
	     * // get clockwise flag
	     * var clockwise = arc.clockwise();
	     *
	     * // draw arc counter-clockwise
	     * arc.clockwise(false);
	     *
	     * // draw arc clockwise
	     * arc.clockwise(true);
	     */
	
	    Konva.Collection.mapMethods(Konva.Arc);
	})();
	
	(function() {
	    'use strict';
	    // CONSTANTS
	    var IMAGE = 'Image';
	
	    /**
	     * Image constructor
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {Image} config.image
	     * @param {Object} [config.crop]
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var imageObj = new Image();
	     * imageObj.onload = function() {
	     *   var image = new Konva.Image({
	     *     x: 200,
	     *     y: 50,
	     *     image: imageObj,
	     *     width: 100,
	     *     height: 100
	     *   });
	     * };
	     * imageObj.src = '/path/to/image.jpg'
	     */
	    Konva.Image = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Image.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Konva.Shape.call(this, config);
	            this.className = IMAGE;
	            this.sceneFunc(this._sceneFunc);
	            this.hitFunc(this._hitFunc);
	        },
	        _useBufferCanvas: function() {
	            return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke() && this.getStage();
	        },
	        _sceneFunc: function(context) {
	            var width = this.getWidth(),
	                height = this.getHeight(),
	                image = this.getImage(),
	                cropWidth, cropHeight, params;
	
	            if (image) {
	                cropWidth = this.getCropWidth();
	                cropHeight = this.getCropHeight();
	                if (cropWidth && cropHeight) {
	                    params = [image, this.getCropX(), this.getCropY(), cropWidth, cropHeight, 0, 0, width, height];
	                } else {
	                    params = [image, 0, 0, width, height];
	                }
	            }
	
	            if (this.hasFill() || this.hasStroke()) {
	                context.beginPath();
	                context.rect(0, 0, width, height);
	                context.closePath();
	                context.fillStrokeShape(this);
	            }
	
	            if (image) {
	                context.drawImage.apply(context, params);
	            }
	        },
	        _hitFunc: function(context) {
	            var width = this.getWidth(),
	                height = this.getHeight();
	
	            context.beginPath();
	            context.rect(0, 0, width, height);
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        getWidth: function() {
	            var image = this.getImage();
	            return this.attrs.width || (image ? image.width : 0);
	        },
	        getHeight: function() {
	            var image = this.getImage();
	            return this.attrs.height || (image ? image.height : 0);
	        }
	    };
	    Konva.Util.extend(Konva.Image, Konva.Shape);
	
	    // add getters setters
	    Konva.Factory.addGetterSetter(Konva.Image, 'image');
	
	    /**
	     * set image
	     * @name setImage
	     * @method
	     * @memberof Konva.Image.prototype
	     * @param {Image} image
	     */
	
	    /**
	     * get image
	     * @name getImage
	     * @method
	     * @memberof Konva.Image.prototype
	     * @returns {Image}
	     */
	
	    Konva.Factory.addComponentsGetterSetter(Konva.Image, 'crop', ['x', 'y', 'width', 'height']);
	    /**
	     * get/set crop
	     * @method
	     * @name crop
	     * @memberof Konva.Image.prototype
	     * @param {Object} crop
	     * @param {Number} crop.x
	     * @param {Number} crop.y
	     * @param {Number} crop.width
	     * @param {Number} crop.height
	     * @returns {Object}
	     * @example
	     * // get crop
	     * var crop = image.crop();
	     *
	     * // set crop
	     * image.crop({
	     *   x: 20,
	     *   y: 20,
	     *   width: 20,
	     *   height: 20
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Image, 'cropX', 0);
	    /**
	     * get/set crop x
	     * @method
	     * @name cropX
	     * @memberof Konva.Image.prototype
	     * @param {Number} x
	     * @returns {Number}
	     * @example
	     * // get crop x
	     * var cropX = image.cropX();
	     *
	     * // set crop x
	     * image.cropX(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Image, 'cropY', 0);
	    /**
	     * get/set crop y
	     * @name cropY
	     * @method
	     * @memberof Konva.Image.prototype
	     * @param {Number} y
	     * @returns {Number}
	     * @example
	     * // get crop y
	     * var cropY = image.cropY();
	     *
	     * // set crop y
	     * image.cropY(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Image, 'cropWidth', 0);
	    /**
	     * get/set crop width
	     * @name cropWidth
	     * @method
	     * @memberof Konva.Image.prototype
	     * @param {Number} width
	     * @returns {Number}
	     * @example
	     * // get crop width
	     * var cropWidth = image.cropWidth();
	     *
	     * // set crop width
	     * image.cropWidth(20);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Image, 'cropHeight', 0);
	    /**
	     * get/set crop height
	     * @name cropHeight
	     * @method
	     * @memberof Konva.Image.prototype
	     * @param {Number} height
	     * @returns {Number}
	     * @example
	     * // get crop height
	     * var cropHeight = image.cropHeight();
	     *
	     * // set crop height
	     * image.cropHeight(20);
	     */
	
	    Konva.Collection.mapMethods(Konva.Image);
	
	    /**
	     * load image from given url and create `Konva.Image` instance
	     * @method
	     * @memberof Konva.Image
	     * @param {String} url image source
	     * @param {Function} callback with Konva.Image instance as first argument
	     * @example
	     *  Konva.Image.fromURL(imageURL, function(image){
	     *    // image is Konva.Image instance
	     *    layer.add(image);
	     *    layer.draw();
	     *  });
	     */
	    Konva.Image.fromURL = function(url, callback) {
	        var img = new Image();
	        img.onload = function() {
	          var image = new Konva.Image({
	            image: img
	          });
	          callback(image);
	        };
	        img.src = url;
	    };
	})();
	
	/*eslint-disable max-depth */
	(function() {
	    'use strict';
	    // constants
	    var AUTO = 'auto',
	        //CANVAS = 'canvas',
	        CENTER = 'center',
	        CHANGE_KONVA = 'Change.konva',
	        CONTEXT_2D = '2d',
	        DASH = '-',
	        EMPTY_STRING = '',
	        LEFT = 'left',
	        TEXT = 'text',
	        TEXT_UPPER = 'Text',
	        MIDDLE = 'middle',
	        NORMAL = 'normal',
	        PX_SPACE = 'px ',
	        SPACE = ' ',
	        RIGHT = 'right',
	        WORD = 'word',
	        CHAR = 'char',
	        NONE = 'none',
	        ATTR_CHANGE_LIST = ['fontFamily', 'fontSize', 'fontStyle', 'fontVariant', 'padding', 'align', 'lineHeight', 'text', 'width', 'height', 'wrap'],
	
	        // cached variables
	        attrChangeListLen = ATTR_CHANGE_LIST.length,
	        dummyContext = Konva.Util.createCanvasElement().getContext(CONTEXT_2D);
	
	    /**
	     * Text constructor
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {String} [config.fontFamily] default is Arial
	     * @param {Number} [config.fontSize] in pixels.  Default is 12
	     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
	     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
	     * @param {String} config.text
	     * @param {String} [config.align] can be left, center, or right
	     * @param {Number} [config.padding]
	     * @param {Number} [config.lineHeight] default is 1
	     * @param {String} [config.wrap] can be word, char, or none. Default is word
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var text = new Konva.Text({
	     *   x: 10,
	     *   y: 15,
	     *   text: 'Simple Text',
	     *   fontSize: 30,
	     *   fontFamily: 'Calibri',
	     *   fill: 'green'
	     * });
	     */
	    Konva.Text = function(config) {
	        this.___init(config);
	    };
	    function _fillFunc(context) {
	        context.fillText(this.partialText, 0, 0);
	    }
	    function _strokeFunc(context) {
	        context.strokeText(this.partialText, 0, 0);
	    }
	
	    Konva.Text.prototype = {
	        ___init: function(config) {
	            config = config || {};
	
	            // set default color to black
	            if (!config.fillLinearGradientColorStops && !config.fillRadialGradientColorStops) {
	                config.fill = config.fill || 'black';
	            }
	            //
	            // if (config.width === undefined) {
	            //     config.width = AUTO;
	            // }
	            // if (config.height === undefined) {
	            //     config.height = AUTO;
	            // }
	
	            // call super constructor
	            Konva.Shape.call(this, config);
	
	            this._fillFunc = _fillFunc;
	            this._strokeFunc = _strokeFunc;
	            this.className = TEXT_UPPER;
	
	            // update text data for certain attr changes
	            for(var n = 0; n < attrChangeListLen; n++) {
	                this.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, this._setTextData);
	            }
	
	            this._setTextData();
	            this.sceneFunc(this._sceneFunc);
	            this.hitFunc(this._hitFunc);
	        },
	        _sceneFunc: function(context) {
	            var p = this.getPadding(),
	                textHeight = this.getTextHeight(),
	                lineHeightPx = this.getLineHeight() * textHeight,
	                textArr = this.textArr,
	                textArrLen = textArr.length,
	                totalWidth = this.getWidth(),
	                n;
	
	            context.setAttr('font', this._getContextFont());
	
	            context.setAttr('textBaseline', MIDDLE);
	            context.setAttr('textAlign', LEFT);
	            context.save();
	            if (p) {
	                context.translate(p, 0);
	                context.translate(0, p + textHeight / 2);
	            } else {
	                context.translate(0, textHeight / 2);
	            }
	
	
	            // draw text lines
	            for(n = 0; n < textArrLen; n++) {
	                var obj = textArr[n],
	                    text = obj.text,
	                    width = obj.width;
	
	                // horizontal alignment
	                context.save();
	                if(this.getAlign() === RIGHT) {
	                    context.translate(totalWidth - width - p * 2, 0);
	                }
	                else if(this.getAlign() === CENTER) {
	                    context.translate((totalWidth - width - p * 2) / 2, 0);
	                }
	
	                this.partialText = text;
	
	                context.fillStrokeShape(this);
	                context.restore();
	                context.translate(0, lineHeightPx);
	            }
	            context.restore();
	        },
	        _hitFunc: function(context) {
	            var width = this.getWidth(),
	                height = this.getHeight();
	
	            context.beginPath();
	            context.rect(0, 0, width, height);
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        setText: function(text) {
	            var str = Konva.Util._isString(text) ? text : (text || '').toString();
	            this._setAttr(TEXT, str);
	            return this;
	        },
	        /**
	         * get width of text area, which includes padding
	         * @method
	         * @memberof Konva.Text.prototype
	         * @returns {Number}
	         */
	        getWidth: function() {
	            var isAuto = (this.attrs.width === AUTO) || (this.attrs.width === undefined);
	            return isAuto ? this.getTextWidth() + this.getPadding() * 2 : this.attrs.width;
	        },
	        /**
	         * get the height of the text area, which takes into account multi-line text, line heights, and padding
	         * @method
	         * @memberof Konva.Text.prototype
	         * @returns {Number}
	         */
	        getHeight: function() {
	          var isAuto = (this.attrs.height === AUTO) || (this.attrs.height === undefined);
	          return isAuto ? (this.getTextHeight() * this.textArr.length * this.getLineHeight()) + this.getPadding() * 2 : this.attrs.height;
	        },
	        /**
	         * get text width
	         * @method
	         * @memberof Konva.Text.prototype
	         * @returns {Number}
	         */
	        getTextWidth: function() {
	            return this.textWidth;
	        },
	        /**
	         * get text height
	         * @method
	         * @memberof Konva.Text.prototype
	         * @returns {Number}
	         */
	        getTextHeight: function() {
	            return this.textHeight;
	        },
	        _getTextSize: function(text) {
	            var _context = dummyContext,
	                fontSize = this.getFontSize(),
	                metrics;
	
	            _context.save();
	            _context.font = this._getContextFont();
	
	            metrics = _context.measureText(text);
	            _context.restore();
	            return {
	                width: metrics.width,
	                height: parseInt(fontSize, 10)
	            };
	        },
	        _getContextFont: function() {
	            // IE don't want to work with usual font style
	            // bold was not working
	            // removing font variant will solve
	            // fix for: https://github.com/konvajs/konva/issues/94
	            if (Konva.UA.isIE) {
	                return this.getFontStyle() + SPACE + this.getFontSize() + PX_SPACE + this.getFontFamily();
	            }
	            return this.getFontStyle() + SPACE +
	                    this.getFontVariant() + SPACE +
	                    this.getFontSize() + PX_SPACE +
	                    this.getFontFamily();
	        },
	        _addTextLine: function (line, width) {
	            return this.textArr.push({text: line, width: width});
	        },
	        _getTextWidth: function (text) {
	            return dummyContext.measureText(text).width;
	        },
	        _setTextData: function () {
	            var lines = this.getText().split('\n'),
	                fontSize = +this.getFontSize(),
	                textWidth = 0,
	                lineHeightPx = this.getLineHeight() * fontSize,
	                width = this.attrs.width,
	                height = this.attrs.height,
	                fixedWidth = width !== AUTO,
	                fixedHeight = height !== AUTO,
	                padding = this.getPadding(),
	                maxWidth = width - padding * 2,
	                maxHeightPx = height - padding * 2,
	                currentHeightPx = 0,
	                wrap = this.getWrap(),
	                shouldWrap = wrap !== NONE,
	                wrapAtWord = wrap !== CHAR && shouldWrap;
	
	            this.textArr = [];
	            dummyContext.save();
	            dummyContext.font = this._getContextFont();
	            for (var i = 0, max = lines.length; i < max; ++i) {
	                var line = lines[i],
	                    lineWidth = this._getTextWidth(line);
	                if (fixedWidth && lineWidth > maxWidth) {
	                    /*
	                     * if width is fixed and line does not fit entirely
	                     * break the line into multiple fitting lines
	                     */
	                    while (line.length > 0) {
	                        /*
	                         * use binary search to find the longest substring that
	                         * that would fit in the specified width
	                         */
	                        var low = 0, high = line.length,
	                            match = '', matchWidth = 0;
	                        while (low < high) {
	                            var mid = (low + high) >>> 1,
	                                substr = line.slice(0, mid + 1),
	                                substrWidth = this._getTextWidth(substr);
	                            if (substrWidth <= maxWidth) {
	                                low = mid + 1;
	                                match = substr;
	                                matchWidth = substrWidth;
	                            } else {
	                                high = mid;
	                            }
	                        }
	                        /*
	                         * 'low' is now the index of the substring end
	                         * 'match' is the substring
	                         * 'matchWidth' is the substring width in px
	                         */
	                        if (match) {
	                            // a fitting substring was found
	                            if (wrapAtWord) {
	                                // try to find a space or dash where wrapping could be done
	                                var wrapIndex = Math.max(match.lastIndexOf(SPACE),
	                                                          match.lastIndexOf(DASH)) + 1;
	                                if (wrapIndex > 0) {
	                                    // re-cut the substring found at the space/dash position
	                                    low = wrapIndex;
	                                    match = match.slice(0, low);
	                                    matchWidth = this._getTextWidth(match);
	                                }
	                            }
	                            this._addTextLine(match, matchWidth);
	                            textWidth = Math.max(textWidth, matchWidth);
	                            currentHeightPx += lineHeightPx;
	                            if (!shouldWrap ||
	                                (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)) {
	                                /*
	                                 * stop wrapping if wrapping is disabled or if adding
	                                 * one more line would overflow the fixed height
	                                 */
	                                break;
	                            }
	                            line = line.slice(low);
	                            if (line.length > 0) {
	                                // Check if the remaining text would fit on one line
	                                lineWidth = this._getTextWidth(line);
	                                if (lineWidth <= maxWidth) {
	                                    // if it does, add the line and break out of the loop
	                                    this._addTextLine(line, lineWidth);
	                                    currentHeightPx += lineHeightPx;
	                                    textWidth = Math.max(textWidth, lineWidth);
	                                    break;
	                                }
	                            }
	                        } else {
	                            // not even one character could fit in the element, abort
	                            break;
	                        }
	                    }
	                } else {
	                    // element width is automatically adjusted to max line width
	                    this._addTextLine(line, lineWidth);
	                    currentHeightPx += lineHeightPx;
	                    textWidth = Math.max(textWidth, lineWidth);
	                }
	                // if element height is fixed, abort if adding one more line would overflow
	                if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
	                    break;
	                }
	            }
	            dummyContext.restore();
	            this.textHeight = fontSize;
	            this.textWidth = textWidth;
	        }
	    };
	    Konva.Util.extend(Konva.Text, Konva.Shape);
	
	    // add getters setters
	    Konva.Factory.addGetterSetter(Konva.Text, 'fontFamily', 'Arial');
	
	    /**
	     * get/set font family
	     * @name fontFamily
	     * @method
	     * @memberof Konva.Text.prototype
	     * @param {String} fontFamily
	     * @returns {String}
	     * @example
	     * // get font family
	     * var fontFamily = text.fontFamily();
	     *
	     * // set font family
	     * text.fontFamily('Arial');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Text, 'fontSize', 12);
	
	    /**
	     * get/set font size in pixels
	     * @name fontSize
	     * @method
	     * @memberof Konva.Text.prototype
	     * @param {Number} fontSize
	     * @returns {Number}
	     * @example
	     * // get font size
	     * var fontSize = text.fontSize();
	     *
	     * // set font size to 22px
	     * text.fontSize(22);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Text, 'fontStyle', NORMAL);
	
	    /**
	     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
	     * @name fontStyle
	     * @method
	     * @memberof Konva.Text.prototype
	     * @param {String} fontStyle
	     * @returns {String}
	     * @example
	     * // get font style
	     * var fontStyle = text.fontStyle();
	     *
	     * // set font style
	     * text.fontStyle('bold');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Text, 'fontVariant', NORMAL);
	
	    /**
	     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
	     * @name fontVariant
	     * @method
	     * @memberof Konva.Text.prototype
	     * @param {String} fontVariant
	     * @returns {String}
	     * @example
	     * // get font variant
	     * var fontVariant = text.fontVariant();
	     *
	     * // set font variant
	     * text.fontVariant('small-caps');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Text, 'padding', 0);
	
	    /**
	     * set padding
	     * @name padding
	     * @method
	     * @memberof Konva.Text.prototype
	     * @param {Number} padding
	     * @returns {Number}
	     * @example
	     * // get padding
	     * var padding = text.padding();
	     *
	     * // set padding to 10 pixels
	     * text.padding(10);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Text, 'align', LEFT);
	
	    /**
	     * get/set horizontal align of text.  Can be 'left', 'center', or 'right'
	     * @name align
	     * @method
	     * @memberof Konva.Text.prototype
	     * @param {String} align
	     * @returns {String}
	     * @example
	     * // get text align
	     * var align = text.align();
	     *
	     * // center text
	     * text.align('center');
	     *
	     * // align text to right
	     * text.align('right');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Text, 'lineHeight', 1);
	
	    /**
	     * get/set line height.  The default is 1.
	     * @name lineHeight
	     * @method
	     * @memberof Konva.Text.prototype
	     * @param {Number} lineHeight
	     * @returns {Number}
	     * @example
	     * // get line height
	     * var lineHeight = text.lineHeight();
	     *
	     * // set the line height
	     * text.lineHeight(2);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Text, 'wrap', WORD);
	
	    /**
	     * get/set wrap.  Can be word, char, or none. Default is word.
	     * @name wrap
	     * @method
	     * @memberof Konva.Text.prototype
	     * @param {String} wrap
	     * @returns {String}
	     * @example
	     * // get wrap
	     * var wrap = text.wrap();
	     *
	     * // set wrap
	     * text.wrap('word');
	     */
	
	    Konva.Factory.addGetter(Konva.Text, 'text', EMPTY_STRING);
	    Konva.Factory.addOverloadedGetterSetter(Konva.Text, 'text');
	
	    /**
	     * get/set text
	     * @name getText
	     * @method
	     * @memberof Konva.Text.prototype
	     * @param {String} text
	     * @returns {String}
	     * @example
	     * // get text
	     * var text = text.text();
	     *
	     * // set text
	     * text.text('Hello world!');
	     */
	
	    Konva.Collection.mapMethods(Konva.Text);
	})();
	
	(function () {
	    'use strict';
	    /**
	     * Line constructor.&nbsp; Lines are defined by an array of points and
	     *  a tension
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {Array} config.points
	     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
	     *   The default is 0
	     * @param {Boolean} [config.closed] defines whether or not the line shape is closed, creating a polygon or blob
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var line = new Konva.Line({
	     *   x: 100,
	     *   y: 50,
	     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
	     *   stroke: 'red',
	     *   tension: 1
	     * });
	     */
	    Konva.Line = function (config) {
	        this.___init(config);
	    };
	
	    Konva.Line.prototype = {
	        ___init: function (config) {
	            // call super constructor
	            Konva.Shape.call(this, config);
	            this.className = 'Line';
	
	            this.on('pointsChange.konva tensionChange.konva closedChange.konva', function () {
	                this._clearCache('tensionPoints');
	            });
	
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function (context) {
	            var points = this.getPoints(),
	                length = points.length,
	                tension = this.getTension(),
	                closed = this.getClosed(),
	                tp, len, n;
	
	            if (!length) {
	                return;
	            }
	
	            context.beginPath();
	            context.moveTo(points[0], points[1]);
	
	            // tension
	            if (tension !== 0 && length > 4) {
	                tp = this.getTensionPoints();
	                len = tp.length;
	                n = closed ? 0 : 4;
	
	                if (!closed) {
	                    context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
	                }
	
	                while (n < len - 2) {
	                    context.bezierCurveTo(tp[n++], tp[n++], tp[n++], tp[n++], tp[n++], tp[n++]);
	                }
	
	                if (!closed) {
	                    context.quadraticCurveTo(tp[len - 2], tp[len - 1], points[length - 2], points[length - 1]);
	                }
	            }
	            // no tension
	            else {
	                for (n = 2; n < length; n += 2) {
	                    context.lineTo(points[n], points[n + 1]);
	                }
	            }
	
	            // closed e.g. polygons and blobs
	            if (closed) {
	                context.closePath();
	                context.fillStrokeShape(this);
	            }
	            // open e.g. lines and splines
	            else {
	                context.strokeShape(this);
	            }
	        },
	        getTensionPoints: function () {
	            return this._getCache('tensionPoints', this._getTensionPoints);
	        },
	        _getTensionPoints: function () {
	            if (this.getClosed()) {
	                return this._getTensionPointsClosed();
	            } else {
	                return Konva.Util._expandPoints(this.getPoints(), this.getTension());
	            }
	        },
	        _getTensionPointsClosed: function () {
	            var p = this.getPoints(),
	                len = p.length,
	                tension = this.getTension(),
	                util = Konva.Util,
	                firstControlPoints = util._getControlPoints(
	                    p[len - 2],
	                    p[len - 1],
	                    p[0],
	                    p[1],
	                    p[2],
	                    p[3],
	                    tension
	                ),
	                lastControlPoints = util._getControlPoints(
	                    p[len - 4],
	                    p[len - 3],
	                    p[len - 2],
	                    p[len - 1],
	                    p[0],
	                    p[1],
	                    tension
	                ),
	                middle = Konva.Util._expandPoints(p, tension),
	                tp = [
	                    firstControlPoints[2],
	                    firstControlPoints[3]
	                ]
	                .concat(middle)
	                .concat([
	                    lastControlPoints[0],
	                    lastControlPoints[1],
	                    p[len - 2],
	                    p[len - 1],
	                    lastControlPoints[2],
	                    lastControlPoints[3],
	                    firstControlPoints[0],
	                    firstControlPoints[1],
	                    p[0],
	                    p[1]
	                ]);
	
	            return tp;
	        },
	        getWidth: function () {
	            return this.getSelfRect().width;
	        },
	        getHeight: function () {
	            return this.getSelfRect().height;
	        },
	        // overload size detection
	        getSelfRect: function () {
	            var points;
	            if (this.getTension() !== 0) {
	                points = this._getTensionPoints();
	            } else {
	                points = this.getPoints();
	            }
	            var minX = points[0];
	            var maxX = points[0];
	            var minY = points[1];
	            var maxY = points[1];
	            var x, y;
	            for (var i = 0; i < points.length / 2; i++) {
	                x = points[i * 2];
	                y = points[i * 2 + 1];
	                minX = Math.min(minX, x);
	                maxX = Math.max(maxX, x);
	                minY = Math.min(minY, y);
	                maxY = Math.max(maxY, y);
	            }
	            return {
	                x: Math.round(minX),
	                y: Math.round(minY),
	                width: Math.round(maxX - minX),
	                height: Math.round(maxY - minY)
	            };
	        }
	    };
	    Konva.Util.extend(Konva.Line, Konva.Shape);
	
	    // add getters setters
	    Konva.Factory.addGetterSetter(Konva.Line, 'closed', false);
	
	    /**
	     * get/set closed flag.  The default is false
	     * @name closed
	     * @method
	     * @memberof Konva.Line.prototype
	     * @param {Boolean} closed
	     * @returns {Boolean}
	     * @example
	     * // get closed flag
	     * var closed = line.closed();
	     *
	     * // close the shape
	     * line.closed(true);
	     *
	     * // open the shape
	     * line.closed(false);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Line, 'tension', 0);
	
	    /**
	     * get/set tension
	     * @name tension
	     * @method
	     * @memberof Konva.Line.prototype
	     * @param {Number} Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
	     *   The default is 0
	     * @returns {Number}
	     * @example
	     * // get tension
	     * var tension = line.tension();
	     *
	     * // set tension
	     * line.tension(3);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Line, 'points', []);
	    /**
	     * get/set points array
	     * @name points
	     * @method
	     * @memberof Konva.Line.prototype
	     * @param {Array} points
	     * @returns {Array}
	     * @example
	     * // get points
	     * var points = line.points();
	     *
	     * // set points
	     * line.points([10, 20, 30, 40, 50, 60]);
	     *
	     * // push a new point
	     * line.points(line.points().concat([70, 80]));
	     */
	
	    Konva.Collection.mapMethods(Konva.Line);
	})();
	
	(function() {
	    'use strict';
	    /**
	     * Sprite constructor
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {String} config.animation animation key
	     * @param {Object} config.animations animation map
	     * @param {Integer} [config.frameIndex] animation frame index
	     * @param {Image} config.image image object
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var imageObj = new Image();
	     * imageObj.onload = function() {
	     *   var sprite = new Konva.Sprite({
	     *     x: 200,
	     *     y: 100,
	     *     image: imageObj,
	     *     animation: 'standing',
	     *     animations: {
	     *       standing: [
	     *         // x, y, width, height (6 frames)
	     *         0, 0, 49, 109,
	     *         52, 0, 49, 109,
	     *         105, 0, 49, 109,
	     *         158, 0, 49, 109,
	     *         210, 0, 49, 109,
	     *         262, 0, 49, 109
	     *       ],
	     *       kicking: [
	     *         // x, y, width, height (6 frames)
	     *         0, 109, 45, 98,
	     *         45, 109, 45, 98,
	     *         95, 109, 63, 98,
	     *         156, 109, 70, 98,
	     *         229, 109, 60, 98,
	     *         287, 109, 41, 98
	     *       ]
	     *     },
	     *     frameRate: 7,
	     *     frameIndex: 0
	     *   });
	     * };
	     * imageObj.src = '/path/to/image.jpg'
	     */
	    Konva.Sprite = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Sprite.prototype = {
	        ___init: function(config) {
	            // call super constructor
	            Konva.Shape.call(this, config);
	            this.className = 'Sprite';
	
	            this._updated = true;
	            var that = this;
	            this.anim = new Konva.Animation(function() {
	                // if we don't need to redraw layer we should return false
	                var updated = that._updated;
	                that._updated = false;
	                return updated;
	            });
	            this.on('animationChange.konva', function() {
	                // reset index when animation changes
	                this.frameIndex(0);
	            });
	            this.on('frameIndexChange.konva', function() {
	                this._updated = true;
	            });
	            // smooth change for frameRate
	            this.on('frameRateChange.konva', function() {
	                if (!this.anim.isRunning()) {
	                    return;
	                }
	                clearInterval(this.interval);
	                this._setInterval();
	            });
	
	            this.sceneFunc(this._sceneFunc);
	            this.hitFunc(this._hitFunc);
	        },
	        _sceneFunc: function(context) {
	            var anim = this.getAnimation(),
	                index = this.frameIndex(),
	                ix4 = index * 4,
	                set = this.getAnimations()[anim],
	                offsets = this.frameOffsets(),
	                x = set[ix4 + 0],
	                y = set[ix4 + 1],
	                width = set[ix4 + 2],
	                height = set[ix4 + 3],
	                image = this.getImage();
	
	            if (this.hasFill() || this.hasStroke()) {
	                context.beginPath();
	                context.rect(0, 0, width, height);
	                context.closePath();
	                context.fillStrokeShape(this);
	            }
	
	            if(image) {
	                if (offsets) {
	                    var offset = offsets[anim],
	                    ix2 = index * 2;
	                    context.drawImage(image, x, y, width, height, offset[ix2 + 0], offset[ix2 + 1], width, height);
	                } else {
	                    context.drawImage(image, x, y, width, height, 0, 0, width, height);
	                }
	            }
	        },
	        _hitFunc: function(context) {
	            var anim = this.getAnimation(),
	                index = this.frameIndex(),
	                ix4 = index * 4,
	                set = this.getAnimations()[anim],
	                offsets = this.frameOffsets(),
	                width = set[ix4 + 2],
	                height = set[ix4 + 3];
	
	            context.beginPath();
	            if (offsets) {
	                var offset = offsets[anim];
	                var ix2 = index * 2;
	                context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
	            } else {
	                context.rect(0, 0, width, height);
	            }
	            context.closePath();
	            context.fillShape(this);
	        },
	        _useBufferCanvas: function() {
	            return (this.hasShadow() || this.getAbsoluteOpacity() !== 1) && this.hasStroke();
	        },
	        _setInterval: function() {
	            var that = this;
	            this.interval = setInterval(function() {
	                that._updateIndex();
	            }, 1000 / this.getFrameRate());
	        },
	        /**
	         * start sprite animation
	         * @method
	         * @memberof Konva.Sprite.prototype
	         */
	        start: function() {
	            var layer = this.getLayer();
	
	            /*
	             * animation object has no executable function because
	             *  the updates are done with a fixed FPS with the setInterval
	             *  below.  The anim object only needs the layer reference for
	             *  redraw
	             */
	            this.anim.setLayers(layer);
	            this._setInterval();
	            this.anim.start();
	        },
	        /**
	         * stop sprite animation
	         * @method
	         * @memberof Konva.Sprite.prototype
	         */
	        stop: function() {
	            this.anim.stop();
	            clearInterval(this.interval);
	        },
	        /**
	         * determine if animation of sprite is running or not.  returns true or false
	         * @method
	         * @memberof Konva.Animation.prototype
	         * @returns {Boolean}
	         */
	        isRunning: function() {
	            return this.anim.isRunning();
	        },
	        _updateIndex: function() {
	            var index = this.frameIndex(),
	                animation = this.getAnimation(),
	                animations = this.getAnimations(),
	                anim = animations[animation],
	                len = anim.length / 4;
	
	            if(index < len - 1) {
	                this.frameIndex(index + 1);
	            }
	            else {
	                this.frameIndex(0);
	            }
	        }
	    };
	    Konva.Util.extend(Konva.Sprite, Konva.Shape);
	
	    // add getters setters
	    Konva.Factory.addGetterSetter(Konva.Sprite, 'animation');
	
	    /**
	     * get/set animation key
	     * @name animation
	     * @method
	     * @memberof Konva.Sprite.prototype
	     * @param {String} anim animation key
	     * @returns {String}
	     * @example
	     * // get animation key
	     * var animation = sprite.animation();
	     *
	     * // set animation key
	     * sprite.animation('kicking');
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Sprite, 'animations');
	
	    /**
	     * get/set animations map
	     * @name animations
	     * @method
	     * @memberof Konva.Sprite.prototype
	     * @param {Object} animations
	     * @returns {Object}
	     * @example
	     * // get animations map
	     * var animations = sprite.animations();
	     *
	     * // set animations map
	     * sprite.animations({
	     *   standing: [
	     *     // x, y, width, height (6 frames)
	     *     0, 0, 49, 109,
	     *     52, 0, 49, 109,
	     *     105, 0, 49, 109,
	     *     158, 0, 49, 109,
	     *     210, 0, 49, 109,
	     *     262, 0, 49, 109
	     *   ],
	     *   kicking: [
	     *     // x, y, width, height (6 frames)
	     *     0, 109, 45, 98,
	     *     45, 109, 45, 98,
	     *     95, 109, 63, 98,
	     *     156, 109, 70, 98,
	     *     229, 109, 60, 98,
	     *     287, 109, 41, 98
	     *   ]
	     * });
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameOffsets');
	
	    /**
	    * get/set offsets map
	    * @name offsets
	    * @method
	    * @memberof Konva.Sprite.prototype
	    * @param {Object} offsets
	    * @returns {Object}
	    * @example
	    * // get offsets map
	    * var offsets = sprite.offsets();
	    *
	    * // set offsets map
	    * sprite.offsets({
	    *   standing: [
	    *     // x, y (6 frames)
	    *     0, 0,
	    *     0, 0,
	    *     5, 0,
	    *     0, 0,
	    *     0, 3,
	    *     2, 0
	    *   ],
	    *   kicking: [
	    *     // x, y (6 frames)
	    *     0, 5,
	    *     5, 0,
	    *     10, 0,
	    *     0, 0,
	    *     2, 1,
	    *     0, 0
	    *   ]
	    * });
	    */
	
	    Konva.Factory.addGetterSetter(Konva.Sprite, 'image');
	
	    /**
	     * get/set image
	     * @name image
	     * @method
	     * @memberof Konva.Sprite.prototype
	     * @param {Image} image
	     * @returns {Image}
	     * @example
	     * // get image
	     * var image = sprite.image();
	     *
	     * // set image
	     * sprite.image(imageObj);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameIndex', 0);
	
	    /**
	     * set/set animation frame index
	     * @name frameIndex
	     * @method
	     * @memberof Konva.Sprite.prototype
	     * @param {Integer} frameIndex
	     * @returns {Integer}
	     * @example
	     * // get animation frame index
	     * var frameIndex = sprite.frameIndex();
	     *
	     * // set animation frame index
	     * sprite.frameIndex(3);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Sprite, 'frameRate', 17);
	
	    /**
	     * get/set frame rate in frames per second.  Increase this number to make the sprite
	     *  animation run faster, and decrease the number to make the sprite animation run slower
	     *  The default is 17 frames per second
	     * @name frameRate
	     * @method
	     * @memberof Konva.Sprite.prototype
	     * @param {Integer} frameRate
	     * @returns {Integer}
	     * @example
	     * // get frame rate
	     * var frameRate = sprite.frameRate();
	     *
	     * // set frame rate to 2 frames per second
	     * sprite.frameRate(2);
	     */
	
	    Konva.Factory.backCompat(Konva.Sprite, {
	        index: 'frameIndex',
	        getIndex: 'getFrameIndex',
	        setIndex: 'setFrameIndex'
	    });
	
	    Konva.Collection.mapMethods(Konva.Sprite);
	})();
	
	/*eslint-disable  no-shadow, max-len, max-depth */
	(function () {
	    'use strict';
	    /**
	     * Path constructor.
	     * @author Jason Follas
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {String} config.data SVG data string
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var path = new Konva.Path({
	     *   x: 240,
	     *   y: 40,
	     *   data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',
	     *   fill: 'green',
	     *   scale: 2
	     * });
	     */
	    Konva.Path = function (config) {
	        this.___init(config);
	    };
	
	    Konva.Path.prototype = {
	        ___init: function (config) {
	            this.dataArray = [];
	            var that = this;
	
	            // call super constructor
	            Konva.Shape.call(this, config);
	            this.className = 'Path';
	
	            this.dataArray = Konva.Path.parsePathData(this.getData());
	            this.on('dataChange.konva', function () {
	                that.dataArray = Konva.Path.parsePathData(this.getData());
	            });
	
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var ca = this.dataArray;
	
	            // context position
	            context.beginPath();
	            for (var n = 0; n < ca.length; n++) {
	                var c = ca[n].command;
	                var p = ca[n].points;
	                switch (c) {
	                    case 'L':
	                        context.lineTo(p[0], p[1]);
	                        break;
	                    case 'M':
	                        context.moveTo(p[0], p[1]);
	                        break;
	                    case 'C':
	                        context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
	                        break;
	                    case 'Q':
	                        context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
	                        break;
	                    case 'A':
	                        var cx = p[0], cy = p[1], rx = p[2], ry = p[3], theta = p[4], dTheta = p[5], psi = p[6], fs = p[7];
	
	                        var r = (rx > ry) ? rx : ry;
	                        var scaleX = (rx > ry) ? 1 : rx / ry;
	                        var scaleY = (rx > ry) ? ry / rx : 1;
	
	                        context.translate(cx, cy);
	                        context.rotate(psi);
	                        context.scale(scaleX, scaleY);
	                        context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
	                        context.scale(1 / scaleX, 1 / scaleY);
	                        context.rotate(-psi);
	                        context.translate(-cx, -cy);
	
	                        break;
	                    case 'z':
	                        context.closePath();
	                        break;
	                }
	            }
	
	            context.fillStrokeShape(this);
	        },
	        getSelfRect: function() {
	            var points = [];
	            this.dataArray.forEach(function(data) {
	                points = points.concat(data.points);
	            });
	            var minX = points[0];
	            var maxX = points[0];
	            var minY = points[1];
	            var maxY = points[1];
	            var x, y;
	            for (var i = 0; i < points.length / 2; i++) {
	                x = points[i * 2]; y = points[i * 2 + 1];
	                minX = Math.min(minX, x);
	                maxX = Math.max(maxX, x);
	                minY = Math.min(minY, y);
	                maxY = Math.max(maxY, y);
	            }
	            return {
	                x: Math.round(minX),
	                y: Math.round(minY),
	                width: Math.round(maxX - minX),
	                height: Math.round(maxY - minY)
	            };
	        }
	    };
	    Konva.Util.extend(Konva.Path, Konva.Shape);
	
	    Konva.Path.getLineLength = function(x1, y1, x2, y2) {
	        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	    };
	    Konva.Path.getPointOnLine = function(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
	        if(fromX === undefined) {
	            fromX = P1x;
	        }
	        if(fromY === undefined) {
	            fromY = P1y;
	        }
	
	        var m = (P2y - P1y) / ((P2x - P1x) + 0.00000001);
	        var run = Math.sqrt(dist * dist / (1 + m * m));
	        if(P2x < P1x) {
	            run *= -1;
	        }
	        var rise = m * run;
	        var pt;
	
	        if (P2x === P1x) { // vertical line
	            pt = {
	                x: fromX,
	                y: fromY + rise
	            };
	        } else if((fromY - P1y) / ((fromX - P1x) + 0.00000001) === m) {
	            pt = {
	                x: fromX + run,
	                y: fromY + rise
	            };
	        }
	        else {
	            var ix, iy;
	
	            var len = this.getLineLength(P1x, P1y, P2x, P2y);
	            if(len < 0.00000001) {
	                return undefined;
	            }
	            var u = (((fromX - P1x) * (P2x - P1x)) + ((fromY - P1y) * (P2y - P1y)));
	            u = u / (len * len);
	            ix = P1x + u * (P2x - P1x);
	            iy = P1y + u * (P2y - P1y);
	
	            var pRise = this.getLineLength(fromX, fromY, ix, iy);
	            var pRun = Math.sqrt(dist * dist - pRise * pRise);
	            run = Math.sqrt(pRun * pRun / (1 + m * m));
	            if(P2x < P1x) {
	                run *= -1;
	            }
	            rise = m * run;
	            pt = {
	                x: ix + run,
	                y: iy + rise
	            };
	        }
	
	        return pt;
	    };
	
	    Konva.Path.getPointOnCubicBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
	        function CB1(t) {
	            return t * t * t;
	        }
	        function CB2(t) {
	            return 3 * t * t * (1 - t);
	        }
	        function CB3(t) {
	            return 3 * t * (1 - t) * (1 - t);
	        }
	        function CB4(t) {
	            return (1 - t) * (1 - t) * (1 - t);
	        }
	        var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
	        var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);
	
	        return {
	            x: x,
	            y: y
	        };
	    };
	    Konva.Path.getPointOnQuadraticBezier = function(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
	        function QB1(t) {
	            return t * t;
	        }
	        function QB2(t) {
	            return 2 * t * (1 - t);
	        }
	        function QB3(t) {
	            return (1 - t) * (1 - t);
	        }
	        var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
	        var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);
	
	        return {
	            x: x,
	            y: y
	        };
	    };
	    Konva.Path.getPointOnEllipticalArc = function(cx, cy, rx, ry, theta, psi) {
	        var cosPsi = Math.cos(psi), sinPsi = Math.sin(psi);
	        var pt = {
	            x: rx * Math.cos(theta),
	            y: ry * Math.sin(theta)
	        };
	        return {
	            x: cx + (pt.x * cosPsi - pt.y * sinPsi),
	            y: cy + (pt.x * sinPsi + pt.y * cosPsi)
	        };
	    };
	    /*
	     * get parsed data array from the data
	     *  string.  V, v, H, h, and l data are converted to
	     *  L data for the purpose of high performance Path
	     *  rendering
	     */
	    Konva.Path.parsePathData = function(data) {
	        // Path Data Segment must begin with a moveTo
	        //m (x y)+  Relative moveTo (subsequent points are treated as lineTo)
	        //M (x y)+  Absolute moveTo (subsequent points are treated as lineTo)
	        //l (x y)+  Relative lineTo
	        //L (x y)+  Absolute LineTo
	        //h (x)+    Relative horizontal lineTo
	        //H (x)+    Absolute horizontal lineTo
	        //v (y)+    Relative vertical lineTo
	        //V (y)+    Absolute vertical lineTo
	        //z (closepath)
	        //Z (closepath)
	        //c (x1 y1 x2 y2 x y)+ Relative Bezier curve
	        //C (x1 y1 x2 y2 x y)+ Absolute Bezier curve
	        //q (x1 y1 x y)+       Relative Quadratic Bezier
	        //Q (x1 y1 x y)+       Absolute Quadratic Bezier
	        //t (x y)+    Shorthand/Smooth Relative Quadratic Bezier
	        //T (x y)+    Shorthand/Smooth Absolute Quadratic Bezier
	        //s (x2 y2 x y)+       Shorthand/Smooth Relative Bezier curve
	        //S (x2 y2 x y)+       Shorthand/Smooth Absolute Bezier curve
	        //a (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+     Relative Elliptical Arc
	        //A (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+  Absolute Elliptical Arc
	
	        // return early if data is not defined
	        if(!data) {
	            return [];
	        }
	
	        // command string
	        var cs = data;
	
	        // command chars
	        var cc = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'];
	        // convert white spaces to commas
	        cs = cs.replace(new RegExp(' ', 'g'), ',');
	        // create pipes so that we can split the data
	        for(var n = 0; n < cc.length; n++) {
	            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	        }
	        // create array
	        var arr = cs.split('|');
	        var ca = [];
	        // init context point
	        var cpx = 0;
	        var cpy = 0;
	        for( n = 1; n < arr.length; n++) {
	            var str = arr[n];
	            var c = str.charAt(0);
	            str = str.slice(1);
	            // remove ,- for consistency
	            str = str.replace(new RegExp(',-', 'g'), '-');
	            // add commas so that it's easy to split
	            str = str.replace(new RegExp('-', 'g'), ',-');
	            str = str.replace(new RegExp('e,-', 'g'), 'e-');
	            var p = str.split(',');
	            if(p.length > 0 && p[0] === '') {
	                p.shift();
	            }
	            // convert strings to floats
	            for(var i = 0; i < p.length; i++) {
	                p[i] = parseFloat(p[i]);
	            }
	            while(p.length > 0) {
	                if(isNaN(p[0])) {// case for a trailing comma before next command
	                    break;
	                }
	
	                var cmd = null;
	                var points = [];
	                var startX = cpx, startY = cpy;
	                // Move var from within the switch to up here (jshint)
	                var prevCmd, ctlPtx, ctlPty;     // Ss, Tt
	                var rx, ry, psi, fa, fs, x1, y1; // Aa
	
	
	                // convert l, H, h, V, and v to L
	                switch (c) {
	
	                    // Note: Keep the lineTo's above the moveTo's in this switch
	                    case 'l':
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'L':
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        points.push(cpx, cpy);
	                        break;
	
	                    // Note: lineTo handlers need to be above this point
	                    case 'm':
	                        var dx = p.shift();
	                        var dy = p.shift();
	                        cpx += dx;
	                        cpy += dy;
	                        cmd = 'M';
	                        // After closing the path move the current position
	                        // to the the first point of the path (if any).
	                        if(ca.length > 2 && ca[ca.length - 1].command === 'z'){
	                            for(var idx = ca.length - 2; idx >= 0; idx--){
	                                if(ca[idx].command === 'M'){
	                                    cpx = ca[idx].points[0] + dx;
	                                    cpy = ca[idx].points[1] + dy;
	                                    break;
	                                }
	                            }
	                        }
	                        points.push(cpx, cpy);
	                        c = 'l';
	                        // subsequent points are treated as relative lineTo
	                        break;
	                    case 'M':
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'M';
	                        points.push(cpx, cpy);
	                        c = 'L';
	                        // subsequent points are treated as absolute lineTo
	                        break;
	
	                    case 'h':
	                        cpx += p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'H':
	                        cpx = p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'v':
	                        cpy += p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'V':
	                        cpy = p.shift();
	                        cmd = 'L';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'C':
	                        points.push(p.shift(), p.shift(), p.shift(), p.shift());
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        points.push(cpx, cpy);
	                        break;
	                    case 'c':
	                        points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'C';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'S':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if(prevCmd.command === 'C') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
	                            ctlPty = cpy + (cpy - prevCmd.points[3]);
	                        }
	                        points.push(ctlPtx, ctlPty, p.shift(), p.shift());
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'C';
	                        points.push(cpx, cpy);
	                        break;
	                    case 's':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if(prevCmd.command === 'C') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
	                            ctlPty = cpy + (cpy - prevCmd.points[3]);
	                        }
	                        points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'C';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'Q':
	                        points.push(p.shift(), p.shift());
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        points.push(cpx, cpy);
	                        break;
	                    case 'q':
	                        points.push(cpx + p.shift(), cpy + p.shift());
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'Q';
	                        points.push(cpx, cpy);
	                        break;
	                    case 'T':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if(prevCmd.command === 'Q') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
	                            ctlPty = cpy + (cpy - prevCmd.points[1]);
	                        }
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'Q';
	                        points.push(ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 't':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        prevCmd = ca[ca.length - 1];
	                        if(prevCmd.command === 'Q') {
	                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
	                            ctlPty = cpy + (cpy - prevCmd.points[1]);
	                        }
	                        cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'Q';
	                        points.push(ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 'A':
	                        rx = p.shift();
	                        ry = p.shift();
	                        psi = p.shift();
	                        fa = p.shift();
	                        fs = p.shift();
	                        x1 = cpx;
	                        y1 = cpy;
	                        cpx = p.shift();
	                        cpy = p.shift();
	                        cmd = 'A';
	                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
	                        break;
	                    case 'a':
	                        rx = p.shift();
	                        ry = p.shift();
	                        psi = p.shift();
	                        fa = p.shift();
	                        fs = p.shift();
	                        x1 = cpx;
	                        y1 = cpy; cpx += p.shift();
	                        cpy += p.shift();
	                        cmd = 'A';
	                        points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
	                        break;
	                }
	
	                ca.push({
	                    command: cmd || c,
	                    points: points,
	                    start: {
	                        x: startX,
	                        y: startY
	                    },
	                    pathLength: this.calcLength(startX, startY, cmd || c, points)
	                });
	            }
	
	            if(c === 'z' || c === 'Z') {
	                ca.push({
	                    command: 'z',
	                    points: [],
	                    start: undefined,
	                    pathLength: 0
	                });
	            }
	        }
	
	        return ca;
	    };
	    Konva.Path.calcLength = function(x, y, cmd, points) {
	        var len, p1, p2, t;
	        var path = Konva.Path;
	
	        switch (cmd) {
	            case 'L':
	                return path.getLineLength(x, y, points[0], points[1]);
	            case 'C':
	                // Approximates by breaking curve into 100 line segments
	                len = 0.0;
	                p1 = path.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
	                for( t = 0.01; t <= 1; t += 0.01) {
	                    p2 = path.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);
	                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	                    p1 = p2;
	                }
	                return len;
	            case 'Q':
	                // Approximates by breaking curve into 100 line segments
	                len = 0.0;
	                p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
	                for( t = 0.01; t <= 1; t += 0.01) {
	                    p2 = path.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);
	                    len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	                    p1 = p2;
	                }
	                return len;
	            case 'A':
	                // Approximates by breaking curve into line segments
	                len = 0.0;
	                var start = points[4];
	                // 4 = theta
	                var dTheta = points[5];
	                // 5 = dTheta
	                var end = points[4] + dTheta;
	                var inc = Math.PI / 180.0;
	                // 1 degree resolution
	                if(Math.abs(start - end) < inc) {
	                    inc = Math.abs(start - end);
	                }
	                // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi
	                p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
	                if(dTheta < 0) {// clockwise
	                    for( t = start - inc; t > end; t -= inc) {
	                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
	                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	                        p1 = p2;
	                    }
	                }
	                else {// counter-clockwise
	                    for( t = start + inc; t < end; t += inc) {
	                        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);
	                        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	                        p1 = p2;
	                    }
	                }
	                p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
	                len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
	
	                return len;
	        }
	
	        return 0;
	    };
	    Konva.Path.convertEndpointToCenterParameterization = function(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
	        // Derived from: http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
	        var psi = psiDeg * (Math.PI / 180.0);
	        var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
	        var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;
	
	        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
	
	        if(lambda > 1) {
	            rx *= Math.sqrt(lambda);
	            ry *= Math.sqrt(lambda);
	        }
	
	        var f = Math.sqrt((((rx * rx) * (ry * ry)) - ((rx * rx) * (yp * yp)) - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp) + (ry * ry) * (xp * xp)));
	
	        if(fa === fs) {
	            f *= -1;
	        }
	        if(isNaN(f)) {
	            f = 0;
	        }
	
	        var cxp = f * rx * yp / ry;
	        var cyp = f * -ry * xp / rx;
	
	        var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
	        var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;
	
	        var vMag = function(v) {
	            return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	        };
	        var vRatio = function(u, v) {
	            return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	        };
	        var vAngle = function(u, v) {
	            return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
	        };
	        var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
	        var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	        var dTheta = vAngle(u, v);
	
	        if(vRatio(u, v) <= -1) {
	            dTheta = Math.PI;
	        }
	        if(vRatio(u, v) >= 1) {
	            dTheta = 0;
	        }
	        if(fs === 0 && dTheta > 0) {
	            dTheta = dTheta - 2 * Math.PI;
	        }
	        if(fs === 1 && dTheta < 0) {
	            dTheta = dTheta + 2 * Math.PI;
	        }
	        return [cx, cy, rx, ry, theta, dTheta, psi, fs];
	    };
	    // add getters setters
	    Konva.Factory.addGetterSetter(Konva.Path, 'data');
	
	    /**
	     * set SVG path data string.  This method
	     *  also automatically parses the data string
	     *  into a data array.  Currently supported SVG data:
	     *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z
	     * @name setData
	     * @method
	     * @memberof Konva.Path.prototype
	     * @param {String} SVG path command string
	     */
	
	    /**
	     * get SVG path data string
	     * @name getData
	     * @method
	     * @memberof Konva.Path.prototype
	     */
	
	    Konva.Collection.mapMethods(Konva.Path);
	})();
	
	(function() {
	    'use strict';
	    var EMPTY_STRING = '',
	        //CALIBRI = 'Calibri',
	        NORMAL = 'normal';
	
	    /**
	     * Path constructor.
	     * @author Jason Follas
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {String} [config.fontFamily] default is Calibri
	     * @param {Number} [config.fontSize] default is 12
	     * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
	     * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
	     * @param {String} config.text
	     * @param {String} config.data SVG data string
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var textpath = new Konva.TextPath({
	     *   x: 100,
	     *   y: 50,
	     *   fill: '#333',
	     *   fontSize: '24',
	     *   fontFamily: 'Arial',
	     *   text: 'All the world\'s a stage, and all the men and women merely players.',
	     *   data: 'M10,10 C0,0 10,150 100,100 S300,150 400,50'
	     * });
	     */
	    Konva.TextPath = function(config) {
	        this.___init(config);
	    };
	
	    function _fillFunc(context) {
	        context.fillText(this.partialText, 0, 0);
	    }
	    function _strokeFunc(context) {
	        context.strokeText(this.partialText, 0, 0);
	    }
	
	    Konva.TextPath.prototype = {
	        ___init: function(config) {
	            var that = this;
	            this.dummyCanvas = Konva.Util.createCanvasElement();
	            this.dataArray = [];
	
	            // call super constructor
	            Konva.Shape.call(this, config);
	
	            // overrides
	            // TODO: shouldn't this be on the prototype?
	            this._fillFunc = _fillFunc;
	            this._strokeFunc = _strokeFunc;
	            this._fillFuncHit = _fillFunc;
	            this._strokeFuncHit = _strokeFunc;
	
	            this.className = 'TextPath';
	
	            this.dataArray = Konva.Path.parsePathData(this.attrs.data);
	            this.on('dataChange.konva', function() {
	                that.dataArray = Konva.Path.parsePathData(this.attrs.data);
	                that._setTextData();
	            });
	
	            // update text data for certain attr changes
	            this.on('textChange.konva letterSpacingChange.konva', that._setTextData);
	            that._setTextData();
	            this.sceneFunc(this._sceneFunc);
	            this.hitFunc(this._hitFunc);
	        },
	        _sceneFunc: function(context) {
	            context.setAttr('font', this._getContextFont());
	            context.setAttr(this.getTextBaseline(), 'middle');
	            context.setAttr('textAlign', 'left');
	            context.save();
	
	            var glyphInfo = this.glyphInfo;
	            for(var i = 0; i < glyphInfo.length; i++) {
	                context.save();
	
	                var p0 = glyphInfo[i].p0;
	
	                context.translate(p0.x, p0.y);
	                context.rotate(glyphInfo[i].rotation);
	                this.partialText = glyphInfo[i].text;
	
	                context.fillStrokeShape(this);
	                context.restore();
	
	                //// To assist with debugging visually, uncomment following
	                // context.beginPath();
	                // if (i % 2)
	                // context.strokeStyle = 'cyan';
	                // else
	                // context.strokeStyle = 'green';
	                // var p1 = glyphInfo[i].p1;
	                // context.moveTo(p0.x, p0.y);
	                // context.lineTo(p1.x, p1.y);
	                // context.stroke();
	            }
	            context.restore();
	        },
	        _hitFunc: function(context) {
	          context.beginPath();
	
	          var glyphInfo = this.glyphInfo;
	          if (glyphInfo.length >= 1) {
	            var p0 = glyphInfo[0].p0;
	            context.moveTo(p0.x, p0.y);
	          }
	          for(var i = 0; i < glyphInfo.length; i++) {
	              var p1 = glyphInfo[i].p1;
	              context.lineTo(p1.x, p1.y);
	          }
	          context.setAttr('lineWidth', this.getFontSize());
	          context.setAttr('strokeStyle', this.colorKey);
	          context.stroke();
	        },
	        /**
	         * get text width in pixels
	         * @method
	         * @memberof Konva.TextPath.prototype
	         */
	        getTextWidth: function() {
	            return this.textWidth;
	        },
	        /**
	         * get text height in pixels
	         * @method
	         * @memberof Konva.TextPath.prototype
	         */
	        getTextHeight: function() {
	            return this.textHeight;
	        },
	        /**
	         * set text
	         * @method
	         * @memberof Konva.TextPath.prototype
	         * @param {String} text
	         */
	        setText: function(text) {
	            Konva.Text.prototype.setText.call(this, text);
	        },
	        _getTextSize: function(text) {
	            var dummyCanvas = this.dummyCanvas;
	            var _context = dummyCanvas.getContext('2d');
	
	            _context.save();
	
	            _context.font = this._getContextFont();
	            var metrics = _context.measureText(text);
	
	            _context.restore();
	
	            return {
	                width: metrics.width,
	                height: parseInt(this.attrs.fontSize, 10)
	            };
	        },
	        _setTextData: function() {
	
	            var that = this;
	            var size = this._getTextSize(this.attrs.text);
	            var letterSpacing = this.getLetterSpacing();
	
	            this.textWidth = size.width;
	            this.textHeight = size.height;
	
	            this.glyphInfo = [];
	
	            var charArr = this.getText().split('');
	
	            var p0, p1, pathCmd;
	
	            var pIndex = -1;
	            var currentT = 0;
	
	            var getNextPathSegment = function() {
	                currentT = 0;
	                var pathData = that.dataArray;
	
	                for(var j = pIndex + 1; j < pathData.length; j++) {
	                    if(pathData[j].pathLength > 0) {
	                        pIndex = j;
	
	                        return pathData[j];
	                    }
	                    else if(pathData[j].command === 'M') {
	                        p0 = {
	                            x: pathData[j].points[0],
	                            y: pathData[j].points[1]
	                        };
	                    }
	                }
	
	                return {};
	            };
	            var findSegmentToFitCharacter = function(c) {
	
	                var glyphWidth = that._getTextSize(c).width + letterSpacing;
	
	                var currLen = 0;
	                var attempts = 0;
	
	                p1 = undefined;
	                while(Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 && attempts < 25) {
	                    attempts++;
	                    var cumulativePathLength = currLen;
	                    while(pathCmd === undefined) {
	                        pathCmd = getNextPathSegment();
	
	                        if(pathCmd && cumulativePathLength + pathCmd.pathLength < glyphWidth) {
	                            cumulativePathLength += pathCmd.pathLength;
	                            pathCmd = undefined;
	                        }
	                    }
	
	                    if(pathCmd === {} || p0 === undefined) {
	                        return undefined;
	                    }
	
	                    var needNewSegment = false;
	
	                    switch (pathCmd.command) {
	                        case 'L':
	                            if(Konva.Path.getLineLength(p0.x, p0.y, pathCmd.points[0], pathCmd.points[1]) > glyphWidth) {
	                                p1 = Konva.Path.getPointOnLine(glyphWidth, p0.x, p0.y, pathCmd.points[0], pathCmd.points[1], p0.x, p0.y);
	                            }
	                            else {
	                                pathCmd = undefined;
	                            }
	                            break;
	                        case 'A':
	
	                            var start = pathCmd.points[4];
	                            // 4 = theta
	                            var dTheta = pathCmd.points[5];
	                            // 5 = dTheta
	                            var end = pathCmd.points[4] + dTheta;
	
	                            if(currentT === 0){
	                                currentT = start + 0.00000001;
	                            }
	                            // Just in case start is 0
	                            else if(glyphWidth > currLen) {
	                                currentT += (Math.PI / 180.0) * dTheta / Math.abs(dTheta);
	                            }
	                            else {
	                                currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);
	                            }
	
	                            // Credit for bug fix: @therth https://github.com/ericdrowell/KonvaJS/issues/249
	                            // Old code failed to render text along arc of this path: "M 50 50 a 150 50 0 0 1 250 50 l 50 0"
	                            if(dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
	                                currentT = end;
	                                needNewSegment = true;
	                            }
	                            p1 = Konva.Path.getPointOnEllipticalArc(pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], currentT, pathCmd.points[6]);
	                            break;
	                        case 'C':
	                            if(currentT === 0) {
	                                if(glyphWidth > pathCmd.pathLength) {
	                                    currentT = 0.00000001;
	                                }
	                                else {
	                                    currentT = glyphWidth / pathCmd.pathLength;
	                                }
	                            }
	                            else if(glyphWidth > currLen) {
	                                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
	                            }
	                            else {
	                                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
	                            }
	
	                            if(currentT > 1.0) {
	                                currentT = 1.0;
	                                needNewSegment = true;
	                            }
	                            p1 = Konva.Path.getPointOnCubicBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3], pathCmd.points[4], pathCmd.points[5]);
	                            break;
	                        case 'Q':
	                            if(currentT === 0) {
	                                currentT = glyphWidth / pathCmd.pathLength;
	                            }
	                            else if(glyphWidth > currLen) {
	                                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
	                            }
	                            else {
	                                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
	                            }
	
	                            if(currentT > 1.0) {
	                                currentT = 1.0;
	                                needNewSegment = true;
	                            }
	                            p1 = Konva.Path.getPointOnQuadraticBezier(currentT, pathCmd.start.x, pathCmd.start.y, pathCmd.points[0], pathCmd.points[1], pathCmd.points[2], pathCmd.points[3]);
	                            break;
	
	                    }
	
	                    if(p1 !== undefined) {
	                        currLen = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
	                    }
	
	                    if(needNewSegment) {
	                        needNewSegment = false;
	                        pathCmd = undefined;
	                    }
	                }
	            };
	            for(var i = 0; i < charArr.length; i++) {
	
	                // Find p1 such that line segment between p0 and p1 is approx. width of glyph
	                findSegmentToFitCharacter(charArr[i]);
	
	                if(p0 === undefined || p1 === undefined) {
	                    break;
	                }
	
	                var width = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
	
	                // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.
	                // Can foresee having a rough pair table built in that the developer can override as needed.
	
	                var kern = 0;
	                // placeholder for future implementation
	
	                var midpoint = Konva.Path.getPointOnLine(kern + width / 2.0, p0.x, p0.y, p1.x, p1.y);
	
	                var rotation = Math.atan2((p1.y - p0.y), (p1.x - p0.x));
	                this.glyphInfo.push({
	                    transposeX: midpoint.x,
	                    transposeY: midpoint.y,
	                    text: charArr[i],
	                    rotation: rotation,
	                    p0: p0,
	                    p1: p1
	                });
	                p0 = p1;
	            }
	        },
	        getSelfRect: function() {
	            var points = [];
	            var fontSize = this.fontSize();
	
	            this.glyphInfo.forEach(function(info) {
	                points.push(info.p0.x);
	                points.push(info.p0.y);
	                points.push(info.p1.x);
	                points.push(info.p1.y);
	            });
	            var minX = points[0];
	            var maxX = points[0];
	            var minY = points[0];
	            var maxY = points[0];
	            var x, y;
	            for (var i = 0; i < points.length / 2; i++) {
	                x = points[i * 2]; y = points[i * 2 + 1];
	                minX = Math.min(minX, x);
	                maxX = Math.max(maxX, x);
	                minY = Math.min(minY, y);
	                maxY = Math.max(maxY, y);
	            }
	            return {
	                x: Math.round(minX) - fontSize,
	                y: Math.round(minY) - fontSize,
	                width: Math.round(maxX - minX) + fontSize * 2,
	                height: Math.round(maxY - minY) + fontSize * 2
	            };
	        }
	    };
	
	    // map TextPath methods to Text
	    Konva.TextPath.prototype._getContextFont = Konva.Text.prototype._getContextFont;
	
	    Konva.Util.extend(Konva.TextPath, Konva.Shape);
	
	    // add setters and getters
	    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontFamily', 'Arial');
	
	    /**
	     * set font family
	     * @name setFontFamily
	     * @method
	     * @memberof Konva.TextPath.prototype
	     * @param {String} fontFamily
	     */
	
	     /**
	     * get font family
	     * @name getFontFamily
	     * @method
	     * @memberof Konva.TextPath.prototype
	     */
	
	    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontSize', 12);
	
	    /**
	     * set font size
	     * @name setFontSize
	     * @method
	     * @memberof Konva.TextPath.prototype
	     * @param {int} fontSize
	     */
	
	     /**
	     * get font size
	     * @name getFontSize
	     * @method
	     * @memberof Konva.TextPath.prototype
	     */
	
	    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontStyle', NORMAL);
	
	    /**
	     * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
	     * @name setFontStyle
	     * @method
	     * @memberof Konva.TextPath.prototype
	     * @param {String} fontStyle
	     */
	
	    Konva.Factory.addGetterSetter(Konva.TextPath, 'letterSpacing', 0);
	
	     /**
	      * set letter spacing property. Default value is 0.
	      * @name letterSpacing
	      * @method
	      * @memberof Konva.TextPath.prototype
	      * @param {Number} letterSpacing
	      */
	
	    Konva.Factory.addGetterSetter(Konva.TextPath, 'textBaseline', 'middle');
	
	     /**
	      * set textBaseline property. Default value is 'middle'.
	      * Can be 'top', 'bottom', 'middle', 'alphabetic', 'hanging'
	      * @name textBaseline
	      * @method
	      * @memberof Konva.TextPath.prototype
	      * @param {Number} textBaseline
	      */
	
	     /**
	     * get font style
	     * @name getFontStyle
	     * @method
	     * @memberof Konva.TextPath.prototype
	     */
	
	    Konva.Factory.addGetterSetter(Konva.TextPath, 'fontVariant', NORMAL);
	
	
	
	    /**
	     * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
	     * @name setFontVariant
	     * @method
	     * @memberof Konva.TextPath.prototype
	     * @param {String} fontVariant
	     */
	
	    /**
	     * @get font variant
	     * @name getFontVariant
	     * @method
	     * @memberof Konva.TextPath.prototype
	     */
	
	    Konva.Factory.addGetter(Konva.TextPath, 'text', EMPTY_STRING);
	
	    /**
	     * get text
	     * @name getText
	     * @method
	     * @memberof Konva.TextPath.prototype
	     */
	
	    Konva.Collection.mapMethods(Konva.TextPath);
	})();
	
	(function() {
	    'use strict';
	    /**
	     * RegularPolygon constructor.&nbsp; Examples include triangles, squares, pentagons, hexagons, etc.
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {Number} config.sides
	     * @param {Number} config.radius
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var hexagon = new Konva.RegularPolygon({
	     *   x: 100,
	     *   y: 200,
	     *   sides: 6,
	     *   radius: 70,
	     *   fill: 'red',
	     *   stroke: 'black',
	     *   strokeWidth: 4
	     * });
	     */
	    Konva.RegularPolygon = function(config) {
	        this.___init(config);
	    };
	
	    Konva.RegularPolygon.prototype = {
	        _centroid: true,
	        ___init: function(config) {
	            // call super constructor
	            Konva.Shape.call(this, config);
	            this.className = 'RegularPolygon';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var sides = this.attrs.sides,
	                radius = this.attrs.radius,
	                n, x, y;
	
	            context.beginPath();
	            context.moveTo(0, 0 - radius);
	
	            for(n = 1; n < sides; n++) {
	                x = radius * Math.sin(n * 2 * Math.PI / sides);
	                y = -1 * radius * Math.cos(n * 2 * Math.PI / sides);
	                context.lineTo(x, y);
	            }
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        getWidth: function() {
	            return this.getRadius() * 2;
	        },
	        // implements Shape.prototype.getHeight()
	        getHeight: function() {
	            return this.getRadius() * 2;
	        },
	        // implements Shape.prototype.setWidth()
	        setWidth: function(width) {
	            Konva.Node.prototype.setWidth.call(this, width);
	            if (this.radius() !== width / 2) {
	                this.setRadius(width / 2);
	            }
	        },
	        // implements Shape.prototype.setHeight()
	        setHeight: function(height) {
	            Konva.Node.prototype.setHeight.call(this, height);
	            if (this.radius() !== height / 2) {
	                this.setRadius(height / 2);
	            }
	        }
	    };
	    Konva.Util.extend(Konva.RegularPolygon, Konva.Shape);
	
	    // add getters setters
	    Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'radius', 0);
	
	    /**
	     * set radius
	     * @name setRadius
	     * @method
	     * @memberof Konva.RegularPolygon.prototype
	     * @param {Number} radius
	     */
	
	     /**
	     * get radius
	     * @name getRadius
	     * @method
	     * @memberof Konva.RegularPolygon.prototype
	     */
	
	    Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'sides', 0);
	
	    /**
	     * set number of sides
	     * @name setSides
	     * @method
	     * @memberof Konva.RegularPolygon.prototype
	     * @param {int} sides
	     */
	
	    /**
	     * get number of sides
	     * @name getSides
	     * @method
	     * @memberof Konva.RegularPolygon.prototype
	     */
	
	    Konva.Collection.mapMethods(Konva.RegularPolygon);
	})();
	
	(function() {
	    'use strict';
	    /**
	     * Star constructor
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {Integer} config.numPoints
	     * @param {Number} config.innerRadius
	     * @param {Number} config.outerRadius
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var star = new Konva.Star({
	     *   x: 100,
	     *   y: 200,
	     *   numPoints: 5,
	     *   innerRadius: 70,
	     *   outerRadius: 70,
	     *   fill: 'red',
	     *   stroke: 'black',
	     *   strokeWidth: 4
	     * });
	     */
	    Konva.Star = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Star.prototype = {
	        _centroid: true,
	        ___init: function(config) {
	            // call super constructor
	            Konva.Shape.call(this, config);
	            this.className = 'Star';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var innerRadius = this.innerRadius(),
	                outerRadius = this.outerRadius(),
	                numPoints = this.numPoints();
	
	            context.beginPath();
	            context.moveTo(0, 0 - outerRadius);
	
	            for(var n = 1; n < numPoints * 2; n++) {
	                var radius = n % 2 === 0 ? outerRadius : innerRadius;
	                var x = radius * Math.sin(n * Math.PI / numPoints);
	                var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
	                context.lineTo(x, y);
	            }
	            context.closePath();
	
	            context.fillStrokeShape(this);
	        },
	        // implements Shape.prototype.getWidth()
	        getWidth: function() {
	            return this.getOuterRadius() * 2;
	        },
	        // implements Shape.prototype.getHeight()
	        getHeight: function() {
	            return this.getOuterRadius() * 2;
	        },
	        // implements Shape.prototype.setWidth()
	        setWidth: function(width) {
	            Konva.Node.prototype.setWidth.call(this, width);
	            if (this.outerRadius() !== width / 2) {
	                this.setOuterRadius(width / 2);
	            }
	        },
	        // implements Shape.prototype.setHeight()
	        setHeight: function(height) {
	            Konva.Node.prototype.setHeight.call(this, height);
	            if (this.outerRadius() !== height / 2) {
	                this.setOuterRadius(height / 2);
	            }
	        }
	    };
	    Konva.Util.extend(Konva.Star, Konva.Shape);
	
	    // add getters setters
	    Konva.Factory.addGetterSetter(Konva.Star, 'numPoints', 5);
	
	    /**
	     * set number of points
	     * @name setNumPoints
	     * @method
	     * @memberof Konva.Star.prototype
	     * @param {Integer} points
	     */
	
	     /**
	     * get number of points
	     * @name getNumPoints
	     * @method
	     * @memberof Konva.Star.prototype
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Star, 'innerRadius', 0);
	
	    /**
	     * set inner radius
	     * @name setInnerRadius
	     * @method
	     * @memberof Konva.Star.prototype
	     * @param {Number} radius
	     */
	
	     /**
	     * get inner radius
	     * @name getInnerRadius
	     * @method
	     * @memberof Konva.Star.prototype
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Star, 'outerRadius', 0);
	
	    /**
	     * set outer radius
	     * @name setOuterRadius
	     * @method
	     * @memberof Konva.Star.prototype
	     * @param {Number} radius
	     */
	
	     /**
	     * get outer radius
	     * @name getOuterRadius
	     * @method
	     * @memberof Konva.Star.prototype
	     */
	
	    Konva.Collection.mapMethods(Konva.Star);
	})();
	
	(function() {
	    'use strict';
	    // constants
	    var ATTR_CHANGE_LIST = ['fontFamily', 'fontSize', 'fontStyle', 'padding', 'lineHeight', 'text'],
	        CHANGE_KONVA = 'Change.konva',
	        NONE = 'none',
	        UP = 'up',
	        RIGHT = 'right',
	        DOWN = 'down',
	        LEFT = 'left',
	        LABEL = 'Label',
	
	     // cached variables
	     attrChangeListLen = ATTR_CHANGE_LIST.length;
	
	    /**
	     * Label constructor.&nbsp; Labels are groups that contain a Text and Tag shape
	     * @constructor
	     * @memberof Konva
	     * @param {Object} config
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * // create label
	     * var label = new Konva.Label({
	     *   x: 100,
	     *   y: 100,
	     *   draggable: true
	     * });
	     *
	     * // add a tag to the label
	     * label.add(new Konva.Tag({
	     *   fill: '#bbb',
	     *   stroke: '#333',
	     *   shadowColor: 'black',
	     *   shadowBlur: 10,
	     *   shadowOffset: [10, 10],
	     *   shadowOpacity: 0.2,
	     *   lineJoin: 'round',
	     *   pointerDirection: 'up',
	     *   pointerWidth: 20,
	     *   pointerHeight: 20,
	     *   cornerRadius: 5
	     * }));
	     *
	     * // add text to the label
	     * label.add(new Konva.Text({
	     *   text: 'Hello World!',
	     *   fontSize: 50,
	     *   lineHeight: 1.2,
	     *   padding: 10,
	     *   fill: 'green'
	     *  }));
	     */
	    Konva.Label = function(config) {
	        this.____init(config);
	    };
	
	    Konva.Label.prototype = {
	        ____init: function(config) {
	            var that = this;
	
	            Konva.Group.call(this, config);
	            this.className = LABEL;
	
	            this.on('add.konva', function(evt) {
	                that._addListeners(evt.child);
	                that._sync();
	            });
	        },
	        /**
	         * get Text shape for the label.  You need to access the Text shape in order to update
	         * the text properties
	         * @name getText
	         * @method
	         * @memberof Konva.Label.prototype
	         */
	        getText: function() {
	            return this.find('Text')[0];
	        },
	        /**
	         * get Tag shape for the label.  You need to access the Tag shape in order to update
	         * the pointer properties and the corner radius
	         * @name getTag
	         * @method
	         * @memberof Konva.Label.prototype
	         */
	        getTag: function() {
	            return this.find('Tag')[0];
	        },
	        _addListeners: function(text) {
	            var that = this,
	                n;
	            var func = function(){
	                    that._sync();
	                };
	
	            // update text data for certain attr changes
	            for(n = 0; n < attrChangeListLen; n++) {
	                text.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, func);
	            }
	        },
	        getWidth: function() {
	            return this.getText().getWidth();
	        },
	        getHeight: function() {
	            return this.getText().getHeight();
	        },
	        _sync: function() {
	            var text = this.getText(),
	                tag = this.getTag(),
	                width, height, pointerDirection, pointerWidth, x, y, pointerHeight;
	
	            if (text && tag) {
	                width = text.getWidth();
	                height = text.getHeight();
	                pointerDirection = tag.getPointerDirection();
	                pointerWidth = tag.getPointerWidth();
	                pointerHeight = tag.getPointerHeight();
	                x = 0;
	                y = 0;
	
	                switch(pointerDirection) {
	                    case UP:
	                        x = width / 2;
	                        y = -1 * pointerHeight;
	                        break;
	                    case RIGHT:
	                        x = width + pointerWidth;
	                        y = height / 2;
	                        break;
	                    case DOWN:
	                        x = width / 2;
	                        y = height + pointerHeight;
	                        break;
	                    case LEFT:
	                        x = -1 * pointerWidth;
	                        y = height / 2;
	                        break;
	                }
	
	                tag.setAttrs({
	                    x: -1 * x,
	                    y: -1 * y,
	                    width: width,
	                    height: height
	                });
	
	                text.setAttrs({
	                    x: -1 * x,
	                    y: -1 * y
	                });
	            }
	        }
	    };
	
	    Konva.Util.extend(Konva.Label, Konva.Group);
	
	    Konva.Collection.mapMethods(Konva.Label);
	
	    /**
	     * Tag constructor.&nbsp; A Tag can be configured
	     *  to have a pointer element that points up, right, down, or left
	     * @constructor
	     * @memberof Konva
	     * @param {Object} config
	     * @param {String} [config.pointerDirection] can be up, right, down, left, or none; the default
	     *  is none.  When a pointer is present, the positioning of the label is relative to the tip of the pointer.
	     * @param {Number} [config.pointerWidth]
	     * @param {Number} [config.pointerHeight]
	     * @param {Number} [config.cornerRadius]
	     */
	    Konva.Tag = function(config) {
	        this.___init(config);
	    };
	
	    Konva.Tag.prototype = {
	        ___init: function(config) {
	            Konva.Shape.call(this, config);
	            this.className = 'Tag';
	            this.sceneFunc(this._sceneFunc);
	        },
	        _sceneFunc: function(context) {
	            var width = this.getWidth(),
	                height = this.getHeight(),
	                pointerDirection = this.getPointerDirection(),
	                pointerWidth = this.getPointerWidth(),
	                pointerHeight = this.getPointerHeight(),
	                cornerRadius = Math.min(this.getCornerRadius(), width / 2, height / 2);
	
	            context.beginPath();
	            if (!cornerRadius) {
	                context.moveTo(0, 0);
	            } else {
	                context.moveTo(cornerRadius, 0);
	            }
	
	            if (pointerDirection === UP) {
	                context.lineTo((width - pointerWidth) / 2, 0);
	                context.lineTo(width / 2, -1 * pointerHeight);
	                context.lineTo((width + pointerWidth) / 2, 0);
	            }
	
	            if(!cornerRadius) {
	                context.lineTo(width, 0);
	            } else {
	                context.lineTo(width - cornerRadius, 0);
	                context.arc(width - cornerRadius, cornerRadius, cornerRadius, Math.PI * 3 / 2, 0, false);
	            }
	
	            if (pointerDirection === RIGHT) {
	                context.lineTo(width, (height - pointerHeight) / 2);
	                context.lineTo(width + pointerWidth, height / 2);
	                context.lineTo(width, (height + pointerHeight) / 2);
	            }
	
	            if(!cornerRadius) {
	                context.lineTo(width, height);
	            } else {
	                context.lineTo(width, height - cornerRadius);
	                context.arc(width - cornerRadius, height - cornerRadius, cornerRadius, 0, Math.PI / 2, false);
	            }
	
	            if (pointerDirection === DOWN) {
	                context.lineTo((width + pointerWidth) / 2, height);
	                context.lineTo(width / 2, height + pointerHeight);
	                context.lineTo((width - pointerWidth) / 2, height);
	            }
	
	            if(!cornerRadius) {
	                context.lineTo(0, height);
	            } else {
	                context.lineTo(cornerRadius, height);
	                context.arc(cornerRadius, height - cornerRadius, cornerRadius, Math.PI / 2, Math.PI, false);
	            }
	
	            if (pointerDirection === LEFT) {
	                context.lineTo(0, (height + pointerHeight) / 2);
	                context.lineTo(-1 * pointerWidth, height / 2);
	                context.lineTo(0, (height - pointerHeight) / 2);
	            }
	
	            if(cornerRadius) {
	                context.lineTo(0, cornerRadius);
	                context.arc(cornerRadius, cornerRadius, cornerRadius, Math.PI, Math.PI * 3 / 2, false);
	            }
	
	            context.closePath();
	            context.fillStrokeShape(this);
	        },
	        getSelfRect: function() {
	            var x = 0,
	                y = 0,
	                pointerWidth = this.getPointerWidth(),
	                pointerHeight = this.getPointerHeight(),
	                direction = this.pointerDirection(),
	                width = this.getWidth(),
	                height = this.getHeight();
	
	            if (direction === UP) {
	                y -= pointerHeight;
	                height += pointerHeight;
	            } else if (direction === DOWN) {
	                height += pointerHeight;
	            } else if (direction === LEFT) {
	                // ARGH!!! I have no idea why should I used magic 1.5!!!!!!!!!
	                x -= pointerWidth * 1.5;
	                width += pointerWidth;
	            } else if (direction === RIGHT) {
	                width += pointerWidth * 1.5;
	            }
	            return {
	                x: x,
	                y: y,
	                width: width,
	                height: height
	            };
	        }
	    };
	
	    Konva.Util.extend(Konva.Tag, Konva.Shape);
	    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerDirection', NONE);
	
	    /**
	     * set pointer Direction
	     * @name setPointerDirection
	     * @method
	     * @memberof Konva.Tag.prototype
	     * @param {String} pointerDirection can be up, right, down, left, or none.  The
	     *  default is none
	     */
	
	     /**
	     * get pointer Direction
	     * @name getPointerDirection
	     * @method
	     * @memberof Konva.Tag.prototype
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerWidth', 0);
	
	    /**
	     * set pointer width
	     * @name setPointerWidth
	     * @method
	     * @memberof Konva.Tag.prototype
	     * @param {Number} pointerWidth
	     */
	
	     /**
	     * get pointer width
	     * @name getPointerWidth
	     * @method
	     * @memberof Konva.Tag.prototype
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Tag, 'pointerHeight', 0);
	
	    /**
	     * set pointer height
	     * @name setPointerHeight
	     * @method
	     * @memberof Konva.Tag.prototype
	     * @param {Number} pointerHeight
	     */
	
	     /**
	     * get pointer height
	     * @name getPointerHeight
	     * @method
	     * @memberof Konva.Tag.prototype
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Tag, 'cornerRadius', 0);
	
	    /**
	     * set corner radius
	     * @name setCornerRadius
	     * @method
	     * @memberof Konva.Tag.prototype
	     * @param {Number} corner radius
	     */
	
	    /**
	     * get corner radius
	     * @name getCornerRadius
	     * @method
	     * @memberof Konva.Tag.prototype
	     */
	
	    Konva.Collection.mapMethods(Konva.Tag);
	})();
	
	(function() {
	    'use strict';
	    /**
	     * Arrow constructor
	     * @constructor
	     * @memberof Konva
	     * @augments Konva.Shape
	     * @param {Object} config
	     * @param {Array} config.points
	     * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
	     *   The default is 0
	     * @param {Number} config.pointerLength
	     * @param {Number} config.pointerWidth
	     * @param {String} [config.fill] fill color
	     * @param {Image} [config.fillPatternImage] fill pattern image
	     * @param {Number} [config.fillPatternX]
	     * @param {Number} [config.fillPatternY]
	     * @param {Object} [config.fillPatternOffset] object with x and y component
	     * @param {Number} [config.fillPatternOffsetX] 
	     * @param {Number} [config.fillPatternOffsetY] 
	     * @param {Object} [config.fillPatternScale] object with x and y component
	     * @param {Number} [config.fillPatternScaleX]
	     * @param {Number} [config.fillPatternScaleY]
	     * @param {Number} [config.fillPatternRotation]
	     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
	     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientStartPointX]
	     * @param {Number} [config.fillLinearGradientStartPointY]
	     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillLinearGradientEndPointX]
	     * @param {Number} [config.fillLinearGradientEndPointY]
	     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
	     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientStartPointX]
	     * @param {Number} [config.fillRadialGradientStartPointY]
	     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
	     * @param {Number} [config.fillRadialGradientEndPointX] 
	     * @param {Number} [config.fillRadialGradientEndPointY] 
	     * @param {Number} [config.fillRadialGradientStartRadius]
	     * @param {Number} [config.fillRadialGradientEndRadius]
	     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
	     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
	     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
	     * @param {String} [config.stroke] stroke color
	     * @param {Number} [config.strokeWidth] stroke width
	     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
	     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
	     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
	     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
	     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
	     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
	     *  is miter
	     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
	     *  is butt
	     * @param {String} [config.shadowColor]
	     * @param {Number} [config.shadowBlur]
	     * @param {Object} [config.shadowOffset] object with x and y component
	     * @param {Number} [config.shadowOffsetX]
	     * @param {Number} [config.shadowOffsetY]
	     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
	     *  between 0 and 1
	     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
	     * @param {Array} [config.dash]
	     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
	     * @param {Number} [config.x]
	     * @param {Number} [config.y]
	     * @param {Number} [config.width]
	     * @param {Number} [config.height]
	     * @param {Boolean} [config.visible]
	     * @param {Boolean} [config.listening] whether or not the node is listening for events
	     * @param {String} [config.id] unique id
	     * @param {String} [config.name] non-unique name
	     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
	     * @param {Object} [config.scale] set scale
	     * @param {Number} [config.scaleX] set scale x
	     * @param {Number} [config.scaleY] set scale y
	     * @param {Number} [config.rotation] rotation in degrees
	     * @param {Object} [config.offset] offset from center point and rotation point
	     * @param {Number} [config.offsetX] set offset x
	     * @param {Number} [config.offsetY] set offset y
	     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
	     *  the entire stage by dragging any portion of the stage
	     * @param {Number} [config.dragDistance]
	     * @param {Function} [config.dragBoundFunc]
	     * @example
	     * var line = new Konva.Line({
	     *   points: [73, 70, 340, 23, 450, 60, 500, 20],
	     *   stroke: 'red',
	     *   tension: 1,
	     *   pointerLength : 10,
	     *   pointerWidth : 12
	     * });
	     */
	    Konva.Arrow = function(config) {
	        this.____init(config);
	    };
	
	    Konva.Arrow.prototype = {
	        ____init: function(config) {
	            // call super constructor
	            Konva.Line.call(this, config);
	            this.className = 'Arrow';
	        },
	        _sceneFunc: function(ctx) {
	            Konva.Line.prototype._sceneFunc.apply(this, arguments);
	            var PI2 = Math.PI * 2;
	            var points = this.points();
	            var n = points.length;
	            var dx = points[n - 2] - points[n - 4];
	            var dy = points[n - 1] - points[n - 3];
	            var radians = (Math.atan2(dy, dx) + PI2) % PI2;
	            var length = this.pointerLength();
	            var width = this.pointerWidth();
	
	            ctx.save();
	            ctx.beginPath();
	            ctx.translate(points[n - 2], points[n - 1]);
	            ctx.rotate(radians);
	            ctx.moveTo(0, 0);
	            ctx.lineTo(-length, width / 2);
	            ctx.lineTo(-length, -width / 2);
	            ctx.closePath();
	            ctx.restore();
	
	            if (this.pointerAtBeginning()) {
	                ctx.save();
	                ctx.translate(points[0], points[1]);
	                dx = points[2] - points[0];
	                dy = points[3] - points[1];
	                ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
	                ctx.moveTo(0, 0);
	                ctx.lineTo(-length, width / 2);
	                ctx.lineTo(-length, -width / 2);
	                ctx.closePath();
	                ctx.restore();
	            }
	            ctx.fillStrokeShape(this);
	        }
	    };
	
	    Konva.Util.extend(Konva.Arrow, Konva.Line);
	    /**
	     * get/set pointerLength
	     * @name pointerLength
	     * @method
	     * @memberof Konva.Arrow.prototype
	     * @param {Number} Length of pointer of arrow.
	     *   The default is 10.
	     * @returns {Number}
	     * @example
	     * // get tension
	     * var pointerLength = line.pointerLength();
	     *
	     * // set tension
	     * line.pointerLength(15);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerLength', 10);
	    /**
	     * get/set pointerWidth
	     * @name pointerWidth
	     * @method
	     * @memberof Konva.Arrow.prototype
	     * @param {Number} Width of pointer of arrow.
	     *   The default is 10.
	     * @returns {Number}
	     * @example
	     * // get tension
	     * var pointerWidth = line.pointerWidth();
	     *
	     * // set tension
	     * line.pointerWidth(15);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerWidth', 10);
	    /**
	     * get/set pointerAtBeginning
	     * @name pointerAtBeginning
	     * @method
	     * @memberof Konva.Arrow.prototype
	     * @param {Number} Should pointer displayed at beginning of arrow.
	     *   The default is false.
	     * @returns {Boolean}
	     * @example
	     * // get tension
	     * var pointerAtBeginning = line.pointerAtBeginning();
	     *
	     * // set tension
	     * line.pointerAtBeginning(true);
	     */
	
	    Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerAtBeginning', false);
	    Konva.Collection.mapMethods(Konva.Arrow);
	
	})();
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 8 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 9 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	var Circle = __webpack_require__(7).Circle;
	
	var Wire = _interopRequire(__webpack_require__(11));
	
	var Input = (function (_Circle) {
	  function Input(x, y, stand) {
	    var _this = this;
	
	    _classCallCheck(this, Input);
	
	    _get(Object.getPrototypeOf(Input.prototype), "constructor", this).call(this, {
	      x: x,
	      y: y,
	      radius: 8,
	      stroke: "black",
	      strokeWidth: 2,
	      fill: "rgba(12,12,12,0.2)"
	    });
	
	    /* parameters */
	    this.stand = stand;
	    this.x = this.attrs.x;
	    this.y = this.attrs.y;
	    this.connectedInput = null;
	    this.connecting = false;
	    this.type = "Input";
	    this.pointer = null;
	
	    console.log("Created input x:" + this.x + " y:" + this.y);
	    /* handlers */
	    this.on("mouseover", function () {
	      console.log("Hovered");
	      if (_this.connectedInput == null && _this.pointer == null) {
	        _this.pointer = new Circle({
	          x: _this.x,
	          y: _this.y,
	          radius: 8,
	          draggable: true
	        });
	        _this.stand.addElement(_this.pointer);
	        _this.pointer.on("dragstart", function (e) {
	          console.log("Drag start");;
	          _this.wire = new Wire([_this.x, _this.y]);
	          _this.stand.addElement(_this.wire);
	          _this.connecting = true;
	        });
	        _this.pointer.on("dragmove", function (e) {
	          console.log("Drag move");
	          wiring(e, _this);
	        });
	        _this.pointer.on("dragend", function (e) {
	          console.log("Drag end");
	          diswiring(e, _this);
	        });
	      }
	    });
	    this.on("dblclick", function (e) {
	      _this.disconnect();
	    });
	  }
	
	  _inherits(Input, _Circle);
	
	  _createClass(Input, {
	    connect: {
	      value: function connect(input) {
	        this.wire.points([this.x, this.y, input.x, input.y]);
	        this.wire.setSides(this, input);
	        this.connectedInput = input;
	        input.connectedInput = this;
	        this.connecting = false;
	        this.stand.panel.draw();
	      }
	    },
	    disconnect: {
	      value: function disconnect() {
	        this.connectedInput = null;
	        this.pointer = null;
	        this.wire = null;
	      }
	    }
	  });
	
	  return Input;
	})(Circle);
	
	function wiring(e, _this) {
	  _this.wire.points([_this.x, _this.y, e.evt.offsetX, e.evt.offsetY]);
	  _this.stand.panel.draw();
	}
	
	function checkInput(x, y, input) {
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = input.stand.components[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var component = _step.value;
	
	      if (component.type === "Input") {
	        if (component.connectedInput === null) {
	          if (parseInt(component.x) + 8 >= x && parseInt(component.x) - 8 <= x && parseInt(component.y) + 8 >= y && parseInt(component.y) - 8 <= y) {
	            return {
	              result: true,
	              input: component
	            };
	          }
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator["return"]) {
	        _iterator["return"]();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  return {
	    result: false
	  };
	}
	
	function diswiring(e, _this) {
	  var check = checkInput(e.evt.offsetX, e.evt.offsetY, _this);
	  console.log("check == " + check.result);
	  if (check.result === true) {
	    _this.connect(check.input);
	  } else {
	    console.error("Connection failed");
	    _this.wire.destroy();
	    _this.pointer.destroy();
	    _this.stand.panel.draw();
	    _this.disconnect();
	  }
	  _this.connecting = false;
	}
	
	module.exports = Input;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	var Line = __webpack_require__(7).Line;
	
	var Wire = (function (_Line) {
	  function Wire(points) {
	    _classCallCheck(this, Wire);
	
	    _get(Object.getPrototypeOf(Wire.prototype), "constructor", this).call(this, {
	      points: points,
	      stroke: "black",
	      strokeWidth: 2
	    });
	
	    /* parameters */
	    this.type = "Wire";
	    this.sideOne = null;
	    this.sideTwo = null;
	  }
	
	  _inherits(Wire, _Line);
	
	  _createClass(Wire, {
	    setSides: {
	      value: function setSides(inputOne, inputTwo) {
	        this.sideOne = inputOne;
	        this.sideTwo = inputTwo;
	      }
	    }
	  });
	
	  return Wire;
	})(Line);
	
	module.exports = Wire;

/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";
	
	var labs = {
	  Lab_0: [{
	    type: "Meter",
	    x: 80,
	    y: 50,
	    param: "A"
	  }, {
	    type: "Meter",
	    x: 200,
	    y: 50,
	    param: "A"
	  }, {
	    type: "Meter",
	    x: 320,
	    y: 50,
	    param: "V"
	  }, {
	    type: "Meter",
	    x: 440,
	    y: 50,
	    param: "V"
	  }, {
	    type: "Resister",
	    x: 80,
	    y: 150,
	    value: "10"
	  }, {
	    type: "Resister",
	    x: 80,
	    y: 200,
	    value: "100"
	  }, {
	    type: "Resister",
	    x: 80,
	    y: 250,
	    value: "1000"
	  }],
	  Lab_1: [{
	    type: "Input",
	    x: "250",
	    y: "50"
	  }, {
	    type: "Input",
	    x: "150",
	    y: "150"
	  }, {
	    type: "Input",
	    x: "50",
	    y: "250"
	  }, {
	    type: "Meter",
	    param: "A",
	    x: "300",
	    y: "300"
	  }, {
	    type: "Meter",
	    param: "V",
	    x: "100",
	    y: "300"
	  }, {
	    type: "Resister",
	    value: "200",
	    x: "100",
	    y: "400"
	  }],
	  Lab_2: [{
	    type: "Input",
	    x: "250",
	    y: "250"
	  }, {
	    type: "Input",
	    x: "150",
	    y: "150"
	  }, {
	    type: "Input",
	    x: "50",
	    y: "50"
	  }] };
	
	module.exports = labs;

/***/ },
/* 13 */,
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	var _konva = __webpack_require__(7);
	
	var Rect = _konva.Rect;
	var Label = _konva.Label;
	var Text = _konva.Text;
	
	var Input = _interopRequire(__webpack_require__(10));
	
	var Meter = (function (_Rect) {
	    function Meter(x, y, param, stand) {
	        _classCallCheck(this, Meter);
	
	        _get(Object.getPrototypeOf(Meter.prototype), "constructor", this).call(this, {
	            x: x,
	            y: y,
	            width: 50,
	            height: 25,
	            fill: "rgba(12,12,12,0.1)",
	            stroke: "black",
	            strokeWidth: 2
	        });
	
	        /* parameters */
	        this.value = 12;
	        this.param = param;
	        this.stand = stand;
	        this.x = this.attrs.x;
	        this.y = this.attrs.y;
	        this.inputOne = new Input(this.x - 20, parseInt(this.y) + 12.5, this.stand);
	        this.inputTwo = new Input(this.x + 70, parseInt(this.y) + 12.5, this.stand);
	        this.display = new Label({
	            x: this.x,
	            y: this.y });
	
	        this.display.add(new Text({
	            text: this._getValue(),
	            fontFamily: "Calibri",
	            fontSize: 18,
	            padding: 5,
	            fill: "black"
	        }));
	        this.stand.addElements([this.inputOne, this.inputTwo, this.display]);
	        /* handlers */
	    }
	
	    _inherits(Meter, _Rect);
	
	    _createClass(Meter, {
	        _getValue: {
	            value: function _getValue() {
	                return "" + this.value + " " + this.param;
	            }
	        }
	    });
	
	    return Meter;
	})(Rect);
	
	module.exports = Meter;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };
	
	var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };
	
	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };
	
	var _konva = __webpack_require__(7);
	
	var Rect = _konva.Rect;
	var Label = _konva.Label;
	var Text = _konva.Text;
	
	var Input = _interopRequire(__webpack_require__(10));
	
	var Resister = (function (_Rect) {
	    function Resister(x, y, val, stand) {
	        _classCallCheck(this, Resister);
	
	        _get(Object.getPrototypeOf(Resister.prototype), "constructor", this).call(this, {
	            x: x,
	            y: y,
	            width: 65,
	            height: 25,
	            stroke: "black",
	            strokeWidth: 2,
	            fill: "rgba(12,12,12,0.1)"
	        });
	
	        /* parameters */
	        this.x = this.attrs.x;
	        this.y = this.attrs.y;
	        this.value = "" + val + "Om";
	        this.stand = stand;
	        this.inputOne = new Input(this.x - 20, parseInt(this.y) + 12.5, this.stand);
	        this.inputTwo = new Input(this.x + 85, parseInt(this.y) + 12.5, this.stand);
	        this.display = new Label({
	            x: this.x,
	            y: this.y });
	
	        this.display.add(new Text({
	            text: this.value,
	            fontFamily: "Calibri",
	            fontSize: 14,
	            padding: 5,
	            fill: "black"
	        }));
	        this.stand.addElements([this.inputOne, this.inputTwo, this.display]);
	        /* handlers */
	    }
	
	    _inherits(Resister, _Rect);
	
	    return Resister;
	})(Rect);
	
	module.exports = Resister;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAyZmYyMDMxNWM4NTFjMDdkMDY1NCIsIndlYnBhY2s6Ly8vLi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvc3R5bGVzL3N0eWxlLmNzcz9kNThhIiwid2VicGFjazovLy8uL2xpYi9zdHlsZXMvc3R5bGUuY3NzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL2xpYi9tYWluLmpzIiwid2VicGFjazovLy8uL2xpYi9TdGFuZENvbXBvbmVudHMvU3RhbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9rb252YS9rb252YS5qcyIsIndlYnBhY2s6Ly8vY2FudmFzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vanNkb20gKGlnbm9yZWQpIiwid2VicGFjazovLy8uL2xpYi9TdGFuZENvbXBvbmVudHMvSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL1N0YW5kQ29tcG9uZW50cy9XaXJlLmpzIiwid2VicGFjazovLy8uL2xpYi9zdG9yYWdlL2RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL1N0YW5kQ29tcG9uZW50cy9NZXRlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvU3RhbmRDb21wb25lbnRzL1Jlc2lzdGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVCwrQkFBOEIsSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0Esc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFNBQVM7QUFDNUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0Esd0JBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixzQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxR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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWE7QUFDYixVQUFT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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0EscUJB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxRQUFRO0FBQ3ZCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLFFBQVE7QUFDdkIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxRQUFRO0FBQ3ZCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsNkRBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSwrREFBOEQ7QUFD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O0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCLGtCQUFpQixPQUFPO0FBQ3hCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztB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QTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUyxrQ0FBa0M7QUFDM0M7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTs7QUFFQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWdELGtCQUFrQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxTQUFTO0FBQ3hCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxRQUFRO0FBQ3ZCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVO0FBQ1Y7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNB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QUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEI7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEI7QUFDQSxnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9B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QUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0EsdUJBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLHVDQUFzQyx5QkFBeUI7QUFDL0QsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEI7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEI7QUFDQSxnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE1BQU07QUFD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QUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9B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O0FBQ0EsNEJBQTJCLHVCQUF1QjtBQUNsRCxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEM7QUFDNUMsaURBQWdEOzs7QUFHaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0QsVUFBVTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0M7QUFDaEMsMENBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QiwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCLHNCQUFzQjtBQUNoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXVDLHFCQUFxQjtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsSUFBSTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxNQUFNO0FBQ3JCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEI7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUs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LGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFlLFFBQVE7QUFDdkIsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsUUFBUTtBQUN2QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUs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QUFDOztNQUd0RTs7ZUFsQ0csUUFBUTs7WUFBUixRQUFRO0lBQVMsSUFBSTs7a0JBcUNaLFFBQVEsQyIsImZpbGUiOiIuL2Rpc3QvYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZXM2Qm9pbGVycGxhdGVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZXM2Qm9pbGVycGxhdGVcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb25cbiAqKi8iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDJmZjIwMzE1Yzg1MWMwN2QwNjU0XG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2xpYi9zdHlsZXMvc3R5bGUuY3NzJyk7XG5cbndpbmRvdy5vbmxvYWQgPSAoKSA9PiB7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGxldCBtYWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKTtcbiAgICBtYWluLmNsYXNzTmFtZSA9ICcnO1xuICAgIGxldCBwcmVsb2FkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJlbG9hZGVyJyk7XG4gICAgcHJlbG9hZGVyLmNsYXNzTmFtZSA9ICcnO1xuXG4gICAgbGV0IHBhZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWN0aXZlUGFnZScpO1xuXG4gICAgaWYgKHBhZ2UuaW5uZXJIVE1MID09PSAnVmlydHVhbCBMYWInKSB7XG4gICAgICBsZXQgQXBwID0gcmVxdWlyZSgnLi9saWIvbWFpbicpO1xuICAgICAgbGV0IGxhYnMgPSByZXF1aXJlKCcuL2xpYi9zdG9yYWdlL2RhdGEnKTtcbiAgICAgIGxldCBhcHAgPSBuZXcgQXBwKCk7XG5cbiAgICAgIGxldCBsYWJTZWxlY3RvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWxlY3RMYWInKTtcbiAgICAgIGxldCBsYWJJZCA9IGxhYlNlbGVjdG9yLnZhbHVlO1xuICAgICAgbGV0IGRhdGEgPSBsYWJzW2xhYklkXTtcblxuICAgICAgbGFiU2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coZS50YXJnZXQudmFsdWUpO1xuICAgICAgICBkYXRhID0gbGFic1tlLnRhcmdldC52YWx1ZV07XG4gICAgICAgIGFwcC51cGRhdGUoZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIGFwcC5zdGFydChkYXRhKTtcblxuICAgICAgLyogYnV0dG9ucyAqL1xuICAgICAgbGV0IHJlc2V0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc2V0QnRuJyk7XG4gICAgICByZXNldEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgIGFwcC51cGRhdGUoZGF0YSk7XG4gICAgICB9KTtcblxuICAgICAgbGV0IHNlbmRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VuZEJ0bicpO1xuICAgICAgbGV0IGluc3RhbmNlID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgICAgYmFzZVVSTDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCdcbiAgICAgIH0pO1xuXG4gICAgICBzZW5kQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgbGV0IGRhdGEgPSBhcHAuX2dldFN0YW5kQXJyYXkoKTtcbiAgICAgICAgaW5zdGFuY2UucG9zdCgnL2NoZWNrJywge1xuICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2pzaGludC1sb2FkZXIhLi9pbmRleC5qc1xuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3R5bGUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3N0eWxlLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3N0eWxlLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9zdHlsZXMvc3R5bGUuY3NzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIjc3RhbmQge1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICMzMzM7XFxyXFxuXFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcblxcdGhlaWdodDogODB2aDtcXHJcXG5cXHRtYXJnaW4tYm90dG9tOiAyNXB4O1xcclxcbn1cXHJcXG5cXHJcXG4uaW5mbyB7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbi5pbmZvICNzZWxlY3RMYWIge1xcclxcblxcdGZvbnQtc2l6ZTogMC44NWVtICFpbXBvcnRhbnQ7XFxyXFxuXFx0cGFkZGluZzogNXB4XFxyXFxufVxcclxcblxcclxcbi5kYXRhIHtcXHJcXG5cXHRtYXJnaW4tdG9wOiAxMHB4O1xcclxcblxcdG1hcmdpbi1ib3R0b206IDEwcHg7XFxyXFxufVxcclxcblxcclxcbiNtYWluLmhpZGUge1xcclxcblxcdGRpc3BsYXk6IG5vbmU7XFxyXFxuXFx0bWF4LWhlaWdodDogMDtcXHJcXG59XFxyXFxuI3ByZWxvYWRlci5hY3RpdmUge1xcclxcblxcdHBvc2l0aW9uOiBmaXhlZDtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHRoZWlnaHQ6IDEwMHZoO1xcclxcblxcdHdpZHRoOiAxMDB2dztcXHJcXG5cXHRkaXNwbGF5OiBmbGV4O1xcclxcblxcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcblxcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuXFx0YmFja2dyb3VuZDogI2JiZDE0OTtcXHJcXG59XFxyXFxuXFxyXFxuI3ByZWxvYWRlci5hY3RpdmUgI2lubmVyIHtcXHJcXG5cXHR3aWR0aDogNTBweDtcXHJcXG5cXHRoZWlnaHQ6IDUwcHg7XFxyXFxuXFx0cG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG5cXHJcXG4jcHJlbG9hZGVyLmFjdGl2ZSAjaW5uZXI6YmVmb3JlIHtcXHJcXG5cXHRjb250ZW50OiAnJztcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR0b3A6IDY3cHg7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR3aWR0aDogNTBweDtcXHJcXG5cXHRoZWlnaHQ6IDZweDtcXHJcXG5cXHRiYWNrZ3JvdW5kOiBibGFjaztcXHJcXG5cXHRvcGFjaXR5OiAuMjtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA1MCU7XFxyXFxuXFx0YW5pbWF0aW9uOiBzaGFkb3cgLjVzIGxpbmVhciBpbmZpbml0ZTtcXHJcXG59XFxyXFxuI3ByZWxvYWRlci5hY3RpdmUgI2lubmVyOmFmdGVyIHtcXHJcXG5cXHRjb250ZW50OiAnJztcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR3aWR0aDogNTBweDtcXHJcXG5cXHRoZWlnaHQ6IDUwcHg7XFxyXFxuXFx0YmFja2dyb3VuZDogd2hpdGU7XFxyXFxuXFx0YW5pbWF0aW9uOiByb3RhdGUgLjVzIGxpbmVhciBpbmZpbml0ZTtcXHJcXG5cXHRib3JkZXItcmFkaXVzOiA1cHg7XFxyXFxufVxcclxcbkBrZXlmcmFtZXMgcm90YXRlIHtcXHJcXG5cXHQwJSB7XFxyXFxuXFx0XFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApIHJvdGF0ZSgwZGVnKTtcXHJcXG5cXHR9XFxyXFxuXFx0MjUlIHtcXHJcXG5cXHRcXHQgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwcHgpIHJvdGF0ZSgyMi41ZGVnKTtcXHJcXG5cXHR9XFxyXFxuXFx0NTAlIHtcXHJcXG5cXHRcXHQgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDIwcHgpIHNjYWxlKDEuMSwgMC45KSByb3RhdGUoNDVkZWcpO1xcclxcblxcdFxcdCBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNTBweDtcXHJcXG5cXHR9XFxyXFxuXFx0NzUlIHtcXHJcXG5cXHRcXHQgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwcHgpIHJvdGF0ZSg2Ny41ZGVnKTtcXHJcXG5cXHR9XFxyXFxuXFx0MTAwJSB7XFxyXFxuXFx0XFx0IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKSByb3RhdGUoOTBkZWcpO1xcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBzaGFkb3cge1xcclxcblxcdDAlLCAxMDAlIHt0cmFuc2Zvcm06IHNjYWxlWCgxKTt9XFxyXFxuXFx0NTAlIHt0cmFuc2Zvcm06IHNjYWxlWCgxLjIpO31cXHJcXG59XFxyXFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL2xpYi9zdHlsZXMvc3R5bGUuY3NzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IFN0YW5kIGZyb20gJy4vU3RhbmRDb21wb25lbnRzL1N0YW5kLmpzJztcblxuY2xhc3MgQXBwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGFuZCA9IG5ldyBTdGFuZCgpO1xuICB9XG5cbiAgc3RhcnQoZGF0YSkge1xuICAgIHRoaXMuc3RhbmQuYnVpbGQoZGF0YSk7XG4gIH1cblxuICB1cGRhdGUoZGF0YSkge1xuICAgIHRoaXMuc3RhbmQudXBkYXRlKGRhdGEpO1xuICB9XG5cclxuICBfZ2V0U3RhbmRBcnJheSgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YW5kLmdldEFzQXJyYXkoKTtcclxuICB9XHJcbn1cblxuZXhwb3J0IGRlZmF1bHQgQXBwO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2pzaGludC1sb2FkZXIhLi9saWIvbWFpbi5qc1xuICoqLyIsImltcG9ydCB7IFN0YWdlLCBMYXllciwgUmVjdCB9IGZyb20gJ2tvbnZhJztcclxuaW1wb3J0IElucHV0IGZyb20gJy4vSW5wdXQuanMnO1xyXG5pbXBvcnQgTWV0ZXIgZnJvbSAnLi9NZXRlci5qcyc7XHJcbmltcG9ydCBSZXNpc3RlciBmcm9tICcuL1Jlc2lzdGVyLmpzJztcclxuXHJcbmNsYXNzIFN0YW5kIGV4dGVuZHMgU3RhZ2Uge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgbGV0IHN0YW5kV3JhcHBlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFuZCcpO1xyXG4gICAgbGV0IHdpZHRoID0gc3RhbmRXcmFwcGVyLnNjcm9sbFdpZHRoO1xyXG4gICAgbGV0IGhlaWdodCA9IHN0YW5kV3JhcHBlci5jbGllbnRIZWlnaHQ7XHJcbiAgICBzdXBlcih7XHJcbiAgICAgIGNvbnRhaW5lcjogJ3N0YW5kJyxcclxuICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLnBhbmVsID0gbmV3IExheWVyKCk7XHJcbiAgICB0aGlzLmNvbXBvbmVudHMgPSBbXTtcclxuICAgIHRoaXMuYWRkKHRoaXMucGFuZWwpO1xyXG4gIH1cclxuXHJcbiAgYnVpbGQoZGF0YSkge1xyXG4gICAgY29uc29sZS5sb2coJ0J1aWxkaW5nIHN0YW5kLi4uJyk7XHJcbiAgICBsZXQgZWxlbWVudHMgPSB0aGlzLnBhcnNlSlNPTihkYXRhKTtcclxuICAgIGZvciAobGV0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcclxuICAgICAgdGhpcy5hZGRFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hZGQodGhpcy5wYW5lbCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGUoZGF0YSkge1xyXG4gICAgdGhpcy5wYW5lbC5kZXN0cm95Q2hpbGRyZW4oKTtcclxuICAgIHRoaXMuY29tcG9uZW50cyA9IFtdO1xyXG4gICAgdGhpcy5idWlsZChkYXRhKTtcclxuICB9XHJcblxyXG4gIGFkZEVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgIHRoaXMuY29tcG9uZW50cy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgdGhpcy5hZGQodGhpcy5wYW5lbC5hZGQoZWxlbWVudCkpO1xyXG4gIH1cclxuXHJcbiAgYWRkRWxlbWVudHMoZWxlbWVudHMpIHtcclxuICAgIGZvciAobGV0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcclxuICAgICAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnB1c2goZWxlbWVudCk7XHJcbiAgICAgIHRoaXMuYWRkKHRoaXMucGFuZWwuYWRkKGVsZW1lbnQpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHBhcnNlSlNPTihkYXRhKSB7XHJcbiAgICBsZXQgZWxlbWVudHMgPSBbXTtcclxuICAgIGZvciAobGV0IGVsIG9mIGRhdGEpIHtcclxuICAgICAgaWYgKGVsLnR5cGUpIHtcclxuICAgICAgICBzd2l0Y2goZWwudHlwZSkge1xyXG4gICAgICAgICAgY2FzZSAnSW5wdXQnOlxyXG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKG5ldyBJbnB1dChlbC54LCBlbC55LCB0aGlzKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAnTWV0ZXInOlxyXG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKG5ldyBNZXRlcihlbC54LCBlbC55LCBlbC5wYXJhbSwgdGhpcykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ1Jlc2lzdGVyJzpcclxuICAgICAgICAgICAgZWxlbWVudHMucHVzaChuZXcgUmVzaXN0ZXIoZWwueCwgZWwueSwgZWwudmFsdWUsIHRoaXMpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudHM7XHJcbiAgfVxyXG5cclxuICBnZXRBc0FycmF5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5tYXAoKGVsZW1lbnQpID0+IHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAndHlwZSc6IGVsZW1lbnQudHlwZSxcclxuICAgICAgICAneCc6IGVsZW1lbnQueCxcclxuICAgICAgICAneSc6IGVsZW1lbnQueVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0YW5kO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vanNoaW50LWxvYWRlciEuL2xpYi9TdGFuZENvbXBvbmVudHMvU3RhbmQuanNcbiAqKi8iLCJcbi8qXG4gKiBLb252YSBKYXZhU2NyaXB0IEZyYW1ld29yayB2MS4yLjJcbiAqIGh0dHA6Ly9rb252YWpzLmdpdGh1Yi5pby9cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgb3IgR1BMIFZlcnNpb24gMiBsaWNlbnNlcy5cbiAqIERhdGU6IFR1ZSBTZXAgMjAgMjAxNlxuICpcbiAqIE9yaWdpbmFsIHdvcmsgQ29weXJpZ2h0IChDKSAyMDExIC0gMjAxMyBieSBFcmljIFJvd2VsbCAoS2luZXRpY0pTKVxuICogTW9kaWZpZWQgd29yayBDb3B5cmlnaHQgKEMpIDIwMTQgLSAyMDE1IGJ5IEFudG9uIExhdnJlbm92IChLb252YSlcbiAqXG4gKiBAbGljZW5zZVxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vLyBydW50aW1lIGNoZWNrIGZvciBhbHJlYWR5IGluY2x1ZGVkIEtvbnZhXG4oZnVuY3Rpb24oZ2xvYmFsKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZSBLb252YVxuICAgICAqL1xuXG4gICAgdmFyIFBJX09WRVJfMTgwID0gTWF0aC5QSSAvIDE4MDtcblxuICAgIHZhciBLb252YSA9IHtcbiAgICAgICAgLy8gcHVibGljXG4gICAgICAgIHZlcnNpb246ICcxLjIuMicsXG5cbiAgICAgICAgLy8gcHJpdmF0ZVxuICAgICAgICBzdGFnZXM6IFtdLFxuICAgICAgICBpZENvdW50ZXI6IDAsXG4gICAgICAgIGlkczoge30sXG4gICAgICAgIG5hbWVzOiB7fSxcbiAgICAgICAgc2hhcGVzOiB7fSxcbiAgICAgICAgbGlzdGVuQ2xpY2tUYXA6IGZhbHNlLFxuICAgICAgICBpbkRibENsaWNrV2luZG93OiBmYWxzZSxcblxuICAgICAgICAvLyBjb25maWd1cmF0aW9uc1xuICAgICAgICBlbmFibGVUcmFjZTogZmFsc2UsXG4gICAgICAgIHRyYWNlQXJyTWF4OiAxMDAsXG4gICAgICAgIGRibENsaWNrV2luZG93OiA0MDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHbG9iYWwgcGl4ZWwgcmF0aW8gY29uZmlndXJhdGlvbi4gS29udmFKUyBhdXRvbWF0aWNhbGx5IGRldGVjdCBwaXhlbCByYXRpbyBvZiBjdXJyZW50IGRldmljZS5cbiAgICAgICAgICogQnV0IHlvdSBtYXkgb3ZlcnJpZGUgc3VjaCBwcm9wZXJ0eSwgaWYgeW91IHdhbnQgdG8gdXNlIHlvdXIgdmFsdWUuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBwaXhlbFJhdGlvXG4gICAgICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogS29udmEucGl4ZWxSYXRpbyA9IDE7XG4gICAgICAgICAqL1xuICAgICAgICBwaXhlbFJhdGlvOiB1bmRlZmluZWQsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmFnIGRpc3RhbmNlIHByb3BlcnR5LiBJZiB5b3Ugc3RhcnQgdG8gZHJhZyBhIG5vZGUgeW91IG1heSB3YW50IHRvIHdhaXQgdW50aWwgcG9pbnRlciBpcyBtb3ZlZCB0byBzb21lIGRpc3RhbmNlIGZyb20gc3RhcnQgcG9pbnQsXG4gICAgICAgICAqIG9ubHkgdGhlbiBzdGFydCBkcmFnZ2luZy5cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdEaXN0YW5jZVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBLb252YS5kcmFnRGlzdGFuY2UgPSAxMDtcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdEaXN0YW5jZTogMCxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBkZWdyZWUgdmFsdWVzIGZvciBhbmdsZSBwcm9wZXJ0aWVzLiBZb3UgbWF5IHNldCB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIHVzZSByYWRpYW50IHZhbHVlcy5cbiAgICAgICAgICogQHByb3BlcnR5IGFuZ2xlRGVnXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUucm90YXRpb24oNDUpOyAvLyA0NSBkZWdyZWVzXG4gICAgICAgICAqIEtvbnZhLmFuZ2xlRGVnID0gZmFsc2U7XG4gICAgICAgICAqIG5vZGUucm90YXRpb24oTWF0aC5QSSAvIDIpOyAvLyBQSS8yIHJhZGlhblxuICAgICAgICAgKi9cbiAgICAgICAgYW5nbGVEZWc6IHRydWUsXG4gICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyBkaWZmZXJlbnQgd2FybmluZ3MgYWJvdXQgZXJyb3JzIG9yIHdyb25nIEFQSSB1c2FnZVxuICAgICAgICAgKiBAcHJvcGVydHkgc2hvd1dhcm5pbmdzXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIEtvbnZhLnNob3dXYXJuaW5ncyA9IGZhbHNlO1xuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1dhcm5pbmdzOiB0cnVlLFxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWVzcGFjZSBGaWx0ZXJzXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAgICAgKi9cbiAgICAgICAgRmlsdGVyczoge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybnMgd2hldGhlciBvciBub3QgZHJhZyBhbmQgZHJvcCBpcyBjdXJyZW50bHkgYWN0aXZlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICAgICAqL1xuICAgICAgICBpc0RyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZCA9IEtvbnZhLkREO1xuXG4gICAgICAgICAgICAvLyBpZiBERCBpcyBub3QgaW5jbHVkZWQgd2l0aCB0aGUgYnVpbGQsIHRoZW5cbiAgICAgICAgICAgIC8vIGRyYWcgYW5kIGRyb3AgaXMgbm90IGV2ZW4gcG9zc2libGVcbiAgICAgICAgICAgIGlmIChkZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZC5pc0RyYWdnaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiByZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEgZHJhZyBhbmQgZHJvcCBvcGVyYXRpb24gaXMgcmVhZHksIGJ1dCBtYXlcbiAgICAgICAgKiAgbm90IG5lY2Vzc2FyaWx5IGhhdmUgc3RhcnRlZFxuICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgICAgKi9cbiAgICAgICAgaXNEcmFnUmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XG5cbiAgICAgICAgICAgIC8vIGlmIEREIGlzIG5vdCBpbmNsdWRlZCB3aXRoIHRoZSBidWlsZCwgdGhlblxuICAgICAgICAgICAgLy8gZHJhZyBhbmQgZHJvcCBpcyBub3QgZXZlbiBwb3NzaWJsZVxuICAgICAgICAgICAgaWYgKGRkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhZGQubm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgX2FkZElkOiBmdW5jdGlvbihub2RlLCBpZCkge1xuICAgICAgICAgICAgaWYoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaWRzW2lkXSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9yZW1vdmVJZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIGlmKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pZHNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfYWRkTmFtZTogZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICAgICAgICAgICAgaWYobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLm5hbWVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZXNbbmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tuYW1lXS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfcmVtb3ZlTmFtZTogZnVuY3Rpb24obmFtZSwgX2lkKSB7XG4gICAgICAgICAgICBpZighbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMubmFtZXNbbmFtZV07XG4gICAgICAgICAgICBpZighbm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm8gPSBub2Rlc1tuXTtcbiAgICAgICAgICAgICAgICBpZihuby5faWQgPT09IF9pZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UobiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMubmFtZXNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldEFuZ2xlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGVEZWcgPyBhbmdsZSAqIFBJX09WRVJfMTgwIDogYW5nbGU7XG4gICAgICAgIH0sXG4gICAgICAgIF9kZXRlY3RJRTogZnVuY3Rpb24odWEpIHtcbiAgICAgICAgICAgIHZhciBtc2llID0gdWEuaW5kZXhPZignbXNpZSAnKTtcbiAgICAgICAgICAgIGlmIChtc2llID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIElFIDEwIG9yIG9sZGVyID0+IHJldHVybiB2ZXJzaW9uIG51bWJlclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcobXNpZSArIDUsIHVhLmluZGV4T2YoJy4nLCBtc2llKSksIDEwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRyaWRlbnQgPSB1YS5pbmRleE9mKCd0cmlkZW50LycpO1xuICAgICAgICAgICAgaWYgKHRyaWRlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUgMTEgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgICAgICAgICAgdmFyIHJ2ID0gdWEuaW5kZXhPZigncnY6Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhydiArIDMsIHVhLmluZGV4T2YoJy4nLCBydikpLCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlZGdlID0gdWEuaW5kZXhPZignZWRnZS8nKTtcbiAgICAgICAgICAgIGlmIChlZGdlID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEVkZ2UgKElFIDEyKykgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhlZGdlICsgNSwgdWEuaW5kZXhPZignLicsIGVkZ2UpKSwgMTApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvdGhlciBicm93c2VyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIF9wYXJzZVVBOiBmdW5jdGlvbih1c2VyQWdlbnQpIHtcbiAgICAgICAgICAgIHZhciB1YSA9IHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBVQSByZWdleFxuICAgICAgICAgICAgICAgIG1hdGNoID0gLyhjaHJvbWUpWyBcXC9dKFtcXHcuXSspLy5leGVjKCB1YSApIHx8XG4gICAgICAgICAgICAgICAgLyh3ZWJraXQpWyBcXC9dKFtcXHcuXSspLy5leGVjKCB1YSApIHx8XG4gICAgICAgICAgICAgICAgLyhvcGVyYSkoPzouKnZlcnNpb258KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyggdWEgKSB8fFxuICAgICAgICAgICAgICAgIC8obXNpZSkgKFtcXHcuXSspLy5leGVjKCB1YSApIHx8XG4gICAgICAgICAgICAgICAgdWEuaW5kZXhPZignY29tcGF0aWJsZScpIDwgMCAmJiAvKG1vemlsbGEpKD86Lio/IHJ2OihbXFx3Ll0rKXwpLy5leGVjKCB1YSApIHx8XG4gICAgICAgICAgICAgICAgW10sXG5cbiAgICAgICAgICAgICAgICAvLyBhZGRpbmcgbW9iaWxlIGZsYWcgYXMgd2VsbFxuICAgICAgICAgICAgICAgIG1vYmlsZSA9ICEhKHVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZHxCbGFja0JlcnJ5fGlQaG9uZXxpUGFkfGlQb2R8T3BlcmEgTWluaXxJRU1vYmlsZS9pKSksXG4gICAgICAgICAgICAgICAgaWVNb2JpbGUgPSAhISh1c2VyQWdlbnQubWF0Y2goL0lFTW9iaWxlL2kpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBicm93c2VyOiBtYXRjaFsgMSBdIHx8ICcnLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IG1hdGNoWyAyIF0gfHwgJzAnLFxuICAgICAgICAgICAgICAgIGlzSUU6IEtvbnZhLl9kZXRlY3RJRSh1YSksXG4gICAgICAgICAgICAgICAgLy8gYWRkaW5nIG1vYmlsZSBmbGFiXG4gICAgICAgICAgICAgICAgbW9iaWxlOiBtb2JpbGUsXG4gICAgICAgICAgICAgICAgaWVNb2JpbGU6IGllTW9iaWxlICAvLyBJZiB0aGlzIGlzIHRydWUgKGkuZS4sIFdQOCksIHRoZW4gS29udmEgdG91Y2ggZXZlbnRzIGFyZSBleGVjdXRlZCBpbnN0ZWFkIG9mIGVxdWl2YWxlbnQgS29udmEgbW91c2UgZXZlbnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvLyB1c2VyIGFnZW50XG4gICAgICAgIFVBOiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgdmFyIGdsb2IgPVxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6XG4gICAgICAgIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICAgICAgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXG4gICAgS29udmEuVUEgPSBLb252YS5fcGFyc2VVQSgoZ2xvYi5uYXZpZ2F0b3IgJiYgZ2xvYi5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCAnJyk7XG5cblxuICAgIGlmIChnbG9iLktvbnZhKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnS29udmEgaW5zdGFuY2UgaXMgYWxyZWFkeSBleGlzdCBpbiBjdXJyZW50IGV2aXJvbWVudC4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVzZSBvbmx5IG9uZSBpbnN0YW5jZS4nXG4gICAgICAgICk7XG4gICAgfVxuICAgIGdsb2IuS29udmEgPSBLb252YTtcbiAgICBLb252YS5nbG9iYWwgPSBnbG9iO1xuXG5cbiAgICBpZiggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIHJ1bnRpbWUtY2hlY2sgZm9yIGJyb3dzZXJpZnkgYW5kIG53LmpzIChub2RlLXdlYmtpdClcbiAgICAgICAgaWYoZ2xvYi53aW5kb3cgJiYgZ2xvYi53aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIEtvbnZhLmRvY3VtZW50ID0gZ2xvYi53aW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgICAgICBLb252YS53aW5kb3cgPSBnbG9iLndpbmRvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb21lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgICAgIHZhciBDYW52YXMgPSByZXF1aXJlKCdjYW52YXMnKTtcbiAgICAgICAgICAgIHZhciBqc2RvbSA9IHJlcXVpcmUoJ2pzZG9tJykuanNkb207XG5cbiAgICAgICAgICAgIEtvbnZhLndpbmRvdyA9IGpzZG9tKCc8IURPQ1RZUEUgaHRtbD48aHRtbD48aGVhZD48L2hlYWQ+PGJvZHk+PC9ib2R5PjwvaHRtbD4nKS5kZWZhdWx0VmlldztcbiAgICAgICAgICAgIEtvbnZhLmRvY3VtZW50ID0gS29udmEud2luZG93LmRvY3VtZW50O1xuICAgICAgICAgICAgS29udmEud2luZG93LkltYWdlID0gQ2FudmFzLkltYWdlO1xuICAgICAgICAgICAgS29udmEuX25vZGVDYW52YXMgPSBDYW52YXM7XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBLb252YTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gS29udmE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBLb252YS5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIEtvbnZhLndpbmRvdyA9IHdpbmRvdztcbn0pKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKTtcblxuLyplc2xpbnQtZGlzYWJsZSAgZXFlcWVxLCBuby1jb25kLWFzc2lnbiwgbm8tZW1wdHkqL1xuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIGNvbnN0cnVjdG9yLiAgQ29sbGVjdGlvbiBleHRlbmRzXG4gICAgICogIEFycmF5LiAgVGhpcyBjbGFzcyBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIEtvbnZhLkNvbnRhaW5lciNnZXR9XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICovXG4gICAgS29udmEuQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgbGVuZ3RoID0gYXJncy5sZW5ndGgsIGkgPSAwO1xuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICBmb3IoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBhcmdzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBbXTtcbiAgICAvKipcbiAgICAgKiBpdGVyYXRlIHRocm91Z2ggbm9kZSBhcnJheSBhbmQgcnVuIGEgZnVuY3Rpb24gZm9yIGVhY2ggbm9kZS5cbiAgICAgKiAgVGhlIG5vZGUgYW5kIGluZGV4IGlzIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgYWxsIG5vZGVzIHdpdGggbmFtZSBmb28gaW5zaWRlIGxheWVyLCBhbmQgc2V0IHggdG8gMTAgZm9yIGVhY2hcbiAgICAgKiBsYXllci5nZXQoJy5mb28nKS5lYWNoKGZ1bmN0aW9uKHNoYXBlLCBuKSB7XG4gICAgICogICBzaGFwZS5zZXRYKDEwKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgdGhpcy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgZnVuYyh0aGlzW25dLCBuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogY29udmVydCBjb2xsZWN0aW9uIGludG8gYW4gYXJyYXlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJyID0gW10sXG4gICAgICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgIG47XG5cbiAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgIGFyci5wdXNoKHRoaXNbbl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGFycmF5IGludG8gYSBjb2xsZWN0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAgICovXG4gICAgS29udmEuQ29sbGVjdGlvbi50b0NvbGxlY3Rpb24gPSBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBuZXcgS29udmEuQ29sbGVjdGlvbigpLFxuICAgICAgICAgICAgbGVuID0gYXJyLmxlbmd0aCxcbiAgICAgICAgICAgIG47XG5cbiAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaChhcnJbbl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH07XG5cbiAgICAvLyBtYXAgb25lIG1ldGhvZCBieSBpdCdzIG5hbWVcbiAgICBLb252YS5Db2xsZWN0aW9uLl9tYXBNZXRob2QgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbaV1bbWV0aG9kTmFtZV0uYXBwbHkodGhpc1tpXSwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMgPSBmdW5jdGlvbihjb25zdHJ1Y3Rvcikge1xuICAgICAgICB2YXIgcHJvdCA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgZm9yKHZhciBtZXRob2ROYW1lIGluIHByb3QpIHtcbiAgICAgICAgICAgIEtvbnZhLkNvbGxlY3Rpb24uX21hcE1ldGhvZChtZXRob2ROYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICogTGFzdCB1cGRhdGVkIE5vdmVtYmVyIDIwMTFcbiAgICAqIEJ5IFNpbW9uIFNhcnJpc1xuICAgICogd3d3LnNpbW9uc2FycmlzLmNvbVxuICAgICogc2FycmlzQGFjbS5vcmdcbiAgICAqXG4gICAgKiBGcmVlIHRvIHVzZSBhbmQgZGlzdHJpYnV0ZSBhdCB3aWxsXG4gICAgKiBTbyBsb25nIGFzIHlvdSBhcmUgbmljZSB0byBwZW9wbGUsIGV0Y1xuICAgICovXG5cbiAgICAvKlxuICAgICogVGhlIHVzYWdlIG9mIHRoaXMgY2xhc3Mgd2FzIGluc3BpcmVkIGJ5IHNvbWUgb2YgdGhlIHdvcmsgZG9uZSBieSBhIGZvcmtlZFxuICAgICogcHJvamVjdCwgS2luZXRpY0pTLUV4dCBieSBXYXBwd29ya3MsIHdoaWNoIGlzIGJhc2VkIG9uIFNpbW9uJ3MgVHJhbnNmb3JtXG4gICAgKiBjbGFzcy4gIE1vZGlmaWVkIGJ5IEVyaWMgUm93ZWxsXG4gICAgKi9cblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFttXSBPcHRpb25hbCBzaXgtZWxlbWVudCBtYXRyaXhcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKi9cbiAgICBLb252YS5UcmFuc2Zvcm0gPSBmdW5jdGlvbihtKSB7XG4gICAgICAgIHRoaXMubSA9IChtICYmIG0uc2xpY2UoKSkgfHwgWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIH07XG5cbiAgICBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29weSBLb252YS5UcmFuc2Zvcm0gb2JqZWN0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLb252YS5UcmFuc2Zvcm0odGhpcy5tKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZm9ybSBwb2ludFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCAyRCBwb2ludCh4LCB5KVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAyRCBwb2ludCh4LCB5KVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMubTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogbVswXSAqIHBvaW50LnggKyBtWzJdICogcG9pbnQueSArIG1bNF0sXG4gICAgICAgICAgICAgICAgeTogbVsxXSAqIHBvaW50LnggKyBtWzNdICogcG9pbnQueSArIG1bNV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSB0cmFuc2xhdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMubVs0XSArPSB0aGlzLm1bMF0gKiB4ICsgdGhpcy5tWzJdICogeTtcbiAgICAgICAgICAgIHRoaXMubVs1XSArPSB0aGlzLm1bMV0gKiB4ICsgdGhpcy5tWzNdICogeTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgc2NhbGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3hcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN5XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5KSB7XG4gICAgICAgICAgICB0aGlzLm1bMF0gKj0gc3g7XG4gICAgICAgICAgICB0aGlzLm1bMV0gKj0gc3g7XG4gICAgICAgICAgICB0aGlzLm1bMl0gKj0gc3k7XG4gICAgICAgICAgICB0aGlzLm1bM10gKj0gc3k7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IHJvdGF0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZCAgQW5nbGUgaW4gcmFkaWFuc1xuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlOiBmdW5jdGlvbihyYWQpIHtcbiAgICAgICAgICAgIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgICAgICAgICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICAgICAgICAgIHZhciBtMTEgPSB0aGlzLm1bMF0gKiBjICsgdGhpcy5tWzJdICogcztcbiAgICAgICAgICAgIHZhciBtMTIgPSB0aGlzLm1bMV0gKiBjICsgdGhpcy5tWzNdICogcztcbiAgICAgICAgICAgIHZhciBtMjEgPSB0aGlzLm1bMF0gKiAtcyArIHRoaXMubVsyXSAqIGM7XG4gICAgICAgICAgICB2YXIgbTIyID0gdGhpcy5tWzFdICogLXMgKyB0aGlzLm1bM10gKiBjO1xuICAgICAgICAgICAgdGhpcy5tWzBdID0gbTExO1xuICAgICAgICAgICAgdGhpcy5tWzFdID0gbTEyO1xuICAgICAgICAgICAgdGhpcy5tWzJdID0gbTIxO1xuICAgICAgICAgICAgdGhpcy5tWzNdID0gbTIyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IDJEIHBvaW50KHgsIHkpXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMubVs0XSxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLm1bNV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBza2V3XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN4XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgc2tldzogZnVuY3Rpb24oc3gsIHN5KSB7XG4gICAgICAgICAgICB2YXIgbTExID0gdGhpcy5tWzBdICsgdGhpcy5tWzJdICogc3k7XG4gICAgICAgICAgICB2YXIgbTEyID0gdGhpcy5tWzFdICsgdGhpcy5tWzNdICogc3k7XG4gICAgICAgICAgICB2YXIgbTIxID0gdGhpcy5tWzJdICsgdGhpcy5tWzBdICogc3g7XG4gICAgICAgICAgICB2YXIgbTIyID0gdGhpcy5tWzNdICsgdGhpcy5tWzFdICogc3g7XG4gICAgICAgICAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgICAgICAgICB0aGlzLm1bMV0gPSBtMTI7XG4gICAgICAgICAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgICAgICAgICB0aGlzLm1bM10gPSBtMjI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFuc2Zvcm0gbXVsdGlwbGljYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLlRyYW5zZm9ybX0gbWF0cml4XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseTogZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgICAgICB2YXIgbTExID0gdGhpcy5tWzBdICogbWF0cml4Lm1bMF0gKyB0aGlzLm1bMl0gKiBtYXRyaXgubVsxXTtcbiAgICAgICAgICAgIHZhciBtMTIgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVswXSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzFdO1xuXG4gICAgICAgICAgICB2YXIgbTIxID0gdGhpcy5tWzBdICogbWF0cml4Lm1bMl0gKyB0aGlzLm1bMl0gKiBtYXRyaXgubVszXTtcbiAgICAgICAgICAgIHZhciBtMjIgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVsyXSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzNdO1xuXG4gICAgICAgICAgICB2YXIgZHggPSB0aGlzLm1bMF0gKiBtYXRyaXgubVs0XSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzVdICsgdGhpcy5tWzRdO1xuICAgICAgICAgICAgdmFyIGR5ID0gdGhpcy5tWzFdICogbWF0cml4Lm1bNF0gKyB0aGlzLm1bM10gKiBtYXRyaXgubVs1XSArIHRoaXMubVs1XTtcblxuICAgICAgICAgICAgdGhpcy5tWzBdID0gbTExO1xuICAgICAgICAgICAgdGhpcy5tWzFdID0gbTEyO1xuICAgICAgICAgICAgdGhpcy5tWzJdID0gbTIxO1xuICAgICAgICAgICAgdGhpcy5tWzNdID0gbTIyO1xuICAgICAgICAgICAgdGhpcy5tWzRdID0gZHg7XG4gICAgICAgICAgICB0aGlzLm1bNV0gPSBkeTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW52ZXJ0IHRoZSBtYXRyaXhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgaW52ZXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gMSAvICh0aGlzLm1bMF0gKiB0aGlzLm1bM10gLSB0aGlzLm1bMV0gKiB0aGlzLm1bMl0pO1xuICAgICAgICAgICAgdmFyIG0wID0gdGhpcy5tWzNdICogZDtcbiAgICAgICAgICAgIHZhciBtMSA9IC10aGlzLm1bMV0gKiBkO1xuICAgICAgICAgICAgdmFyIG0yID0gLXRoaXMubVsyXSAqIGQ7XG4gICAgICAgICAgICB2YXIgbTMgPSB0aGlzLm1bMF0gKiBkO1xuICAgICAgICAgICAgdmFyIG00ID0gZCAqICh0aGlzLm1bMl0gKiB0aGlzLm1bNV0gLSB0aGlzLm1bM10gKiB0aGlzLm1bNF0pO1xuICAgICAgICAgICAgdmFyIG01ID0gZCAqICh0aGlzLm1bMV0gKiB0aGlzLm1bNF0gLSB0aGlzLm1bMF0gKiB0aGlzLm1bNV0pO1xuICAgICAgICAgICAgdGhpcy5tWzBdID0gbTA7XG4gICAgICAgICAgICB0aGlzLm1bMV0gPSBtMTtcbiAgICAgICAgICAgIHRoaXMubVsyXSA9IG0yO1xuICAgICAgICAgICAgdGhpcy5tWzNdID0gbTM7XG4gICAgICAgICAgICB0aGlzLm1bNF0gPSBtNDtcbiAgICAgICAgICAgIHRoaXMubVs1XSA9IG01O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gbWF0cml4XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldE1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHRvIGFic29sdXRlIHBvc2l0aW9uIHZpYSB0cmFuc2xhdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqIEBhdXRob3IgZXJpY2Ryb3dlbGxcbiAgICAgICAgICovXG4gICAgICAgIHNldEFic29sdXRlUG9zaXRpb246IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBtMCA9IHRoaXMubVswXSxcbiAgICAgICAgICAgICAgICBtMSA9IHRoaXMubVsxXSxcbiAgICAgICAgICAgICAgICBtMiA9IHRoaXMubVsyXSxcbiAgICAgICAgICAgICAgICBtMyA9IHRoaXMubVszXSxcbiAgICAgICAgICAgICAgICBtNCA9IHRoaXMubVs0XSxcbiAgICAgICAgICAgICAgICBtNSA9IHRoaXMubVs1XSxcbiAgICAgICAgICAgICAgICB5dCA9ICgobTAgKiAoeSAtIG01KSkgLSAobTEgKiAoeCAtIG00KSkpIC8gKChtMCAqIG0zKSAtIChtMSAqIG0yKSksXG4gICAgICAgICAgICAgICAgeHQgPSAoeCAtIG00IC0gKG0yICogeXQpKSAvIG0wO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGUoeHQsIHl0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDT05TVEFOVFNcbiAgICB2YXIgQ09OVEVYVF8yRCA9ICcyZCcsXG4gICAgICAgIE9CSkVDVF9BUlJBWSA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICAgIE9CSkVDVF9OVU1CRVIgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgICAgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgICAgICBQSV9PVkVSX0RFRzE4MCA9IE1hdGguUEkgLyAxODAsXG4gICAgICAgIERFRzE4MF9PVkVSX1BJID0gMTgwIC8gTWF0aC5QSSxcbiAgICAgICAgSEFTSCA9ICcjJyxcbiAgICAgICAgRU1QVFlfU1RSSU5HID0gJycsXG4gICAgICAgIFpFUk8gPSAnMCcsXG4gICAgICAgIEtPTlZBX1dBUk5JTkcgPSAnS29udmEgd2FybmluZzogJyxcbiAgICAgICAgS09OVkFfRVJST1IgPSAnS29udmEgZXJyb3I6ICcsXG4gICAgICAgIFJHQl9QQVJFTiA9ICdyZ2IoJyxcbiAgICAgICAgQ09MT1JTID0ge1xuICAgICAgICAgICAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gICAgICAgICAgICBhbnRpcXVld2hpdGU6IFsyNTAsIDIzNSwgMjE1XSxcbiAgICAgICAgICAgIGFxdWE6IFswLCAyNTUsIDI1NV0sXG4gICAgICAgICAgICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gICAgICAgICAgICBhenVyZTogWzI0MCwgMjU1LCAyNTVdLFxuICAgICAgICAgICAgYmVpZ2U6IFsyNDUsIDI0NSwgMjIwXSxcbiAgICAgICAgICAgIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICAgICAgICAgICAgYmxhY2s6IFswLCAwLCAwXSxcbiAgICAgICAgICAgIGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNV0sXG4gICAgICAgICAgICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgICAgICAgICAgIGJsdWV2aW9sZXQ6IFsxMzgsIDQzLCAyMjZdLFxuICAgICAgICAgICAgYnJvd246IFsxNjUsIDQyLCA0Ml0sXG4gICAgICAgICAgICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgICAgICAgICAgIGNhZGV0Ymx1ZTogWzk1LCAxNTgsIDE2MF0sXG4gICAgICAgICAgICBjaGFydHJldXNlOiBbMTI3LCAyNTUsIDBdLFxuICAgICAgICAgICAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgICAgICAgICAgIGNvcmFsOiBbMjU1LCAxMjcsIDgwXSxcbiAgICAgICAgICAgIGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzN10sXG4gICAgICAgICAgICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICAgICAgICAgICAgY3JpbXNvbjogWzIyMCwgMjAsIDYwXSxcbiAgICAgICAgICAgIGN5YW46IFswLCAyNTUsIDI1NV0sXG4gICAgICAgICAgICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gICAgICAgICAgICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5XSxcbiAgICAgICAgICAgIGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzMiwgMTFdLFxuICAgICAgICAgICAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICAgICAgICAgIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXG4gICAgICAgICAgICBkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjldLFxuICAgICAgICAgICAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gICAgICAgICAgICBkYXJrbWFnZW50YTogWzEzOSwgMCwgMTM5XSxcbiAgICAgICAgICAgIGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDddLFxuICAgICAgICAgICAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgICAgICAgICAgIGRhcmtvcmNoaWQ6IFsxNTMsIDUwLCAyMDRdLFxuICAgICAgICAgICAgZGFya3JlZDogWzEzOSwgMCwgMF0sXG4gICAgICAgICAgICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gICAgICAgICAgICBkYXJrc2VhZ3JlZW46IFsxNDMsIDE4OCwgMTQzXSxcbiAgICAgICAgICAgIGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOV0sXG4gICAgICAgICAgICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gICAgICAgICAgICBkYXJrc2xhdGVncmV5OiBbNDcsIDc5LCA3OV0sXG4gICAgICAgICAgICBkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDldLFxuICAgICAgICAgICAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgICAgICAgICAgIGRlZXBwaW5rOiBbMjU1LCAyMCwgMTQ3XSxcbiAgICAgICAgICAgIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTVdLFxuICAgICAgICAgICAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICAgICAgICAgICAgZGltZ3JleTogWzEwNSwgMTA1LCAxMDVdLFxuICAgICAgICAgICAgZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NV0sXG4gICAgICAgICAgICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gICAgICAgICAgICBmbG9yYWx3aGl0ZTogWzI1NSwgMjU1LCAyNDBdLFxuICAgICAgICAgICAgZm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNF0sXG4gICAgICAgICAgICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICAgICAgICAgICAgZ2FpbnNib3JvOiBbMjIwLCAyMjAsIDIyMF0sXG4gICAgICAgICAgICBnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NV0sXG4gICAgICAgICAgICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICAgICAgICAgICAgZ29sZGVucm9kOiBbMjE4LCAxNjUsIDMyXSxcbiAgICAgICAgICAgIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICAgICAgICAgIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgICAgICAgICAgIGdyZWVueWVsbG93OiBbMTczLCAyNTUsIDQ3XSxcbiAgICAgICAgICAgIGdyZXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICAgICAgICAgIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gICAgICAgICAgICBob3RwaW5rOiBbMjU1LCAxMDUsIDE4MF0sXG4gICAgICAgICAgICBpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5Ml0sXG4gICAgICAgICAgICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgICAgICAgICAgIGl2b3J5OiBbMjU1LCAyNTUsIDI0MF0sXG4gICAgICAgICAgICBraGFraTogWzI0MCwgMjMwLCAxNDBdLFxuICAgICAgICAgICAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgICAgICAgICAgIGxhdmVuZGVyYmx1c2g6IFsyNTUsIDI0MCwgMjQ1XSxcbiAgICAgICAgICAgIGxhd25ncmVlbjogWzEyNCwgMjUyLCAwXSxcbiAgICAgICAgICAgIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICAgICAgICAgICAgbGlnaHRibHVlOiBbMTczLCAyMTYsIDIzMF0sXG4gICAgICAgICAgICBsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOF0sXG4gICAgICAgICAgICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgICAgICAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLCAyNTAsIDIxMF0sXG4gICAgICAgICAgICBsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgICAgICAgICAgIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgICAgICAgICAgIGxpZ2h0Z3JleTogWzIxMSwgMjExLCAyMTFdLFxuICAgICAgICAgICAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG4gICAgICAgICAgICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICAgICAgICAgICAgbGlnaHRzZWFncmVlbjogWzMyLCAxNzgsIDE3MF0sXG4gICAgICAgICAgICBsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwXSxcbiAgICAgICAgICAgIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gICAgICAgICAgICBsaWdodHNsYXRlZ3JleTogWzExOSwgMTM2LCAxNTNdLFxuICAgICAgICAgICAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyXSxcbiAgICAgICAgICAgIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gICAgICAgICAgICBsaW1lOiBbMCwgMjU1LCAwXSxcbiAgICAgICAgICAgIGxpbWVncmVlbjogWzUwLCAyMDUsIDUwXSxcbiAgICAgICAgICAgIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gICAgICAgICAgICBtYWdlbnRhOiBbMjU1LCAwLCAyNTVdLFxuICAgICAgICAgICAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgICAgICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgICAgICAgICAgIG1lZGl1bWJsdWU6IFswLCAwLCAyMDVdLFxuICAgICAgICAgICAgbWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExXSxcbiAgICAgICAgICAgIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICAgICAgICAgICAgbWVkaXVtc2VhZ3JlZW46IFs2MCwgMTc5LCAxMTNdLFxuICAgICAgICAgICAgbWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOF0sXG4gICAgICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgICAgICAgICAgIG1lZGl1bXR1cnF1b2lzZTogWzcyLCAyMDksIDIwNF0sXG4gICAgICAgICAgICBtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzNdLFxuICAgICAgICAgICAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICAgICAgICAgICAgbWludGNyZWFtOiBbMjQ1LCAyNTUsIDI1MF0sXG4gICAgICAgICAgICBtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1XSxcbiAgICAgICAgICAgIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gICAgICAgICAgICBuYXZham93aGl0ZTogWzI1NSwgMjIyLCAxNzNdLFxuICAgICAgICAgICAgbmF2eTogWzAsIDAsIDEyOF0sXG4gICAgICAgICAgICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gICAgICAgICAgICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgICAgICAgICAgIG9saXZlZHJhYjogWzEwNywgMTQyLCAzNV0sXG4gICAgICAgICAgICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gICAgICAgICAgICBvcmFuZ2VyZWQ6IFsyNTUsIDY5LCAwXSxcbiAgICAgICAgICAgIG9yY2hpZDogWzIxOCwgMTEyLCAyMTRdLFxuICAgICAgICAgICAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICAgICAgICAgICAgcGFsZWdyZWVuOiBbMTUyLCAyNTEsIDE1Ml0sXG4gICAgICAgICAgICBwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOF0sXG4gICAgICAgICAgICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gICAgICAgICAgICBwYXBheWF3aGlwOiBbMjU1LCAyMzksIDIxM10sXG4gICAgICAgICAgICBwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1XSxcbiAgICAgICAgICAgIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICAgICAgICAgICAgcGluazogWzI1NSwgMTkyLCAyMDNdLFxuICAgICAgICAgICAgcGx1bTogWzIyMSwgMTYwLCAyMDNdLFxuICAgICAgICAgICAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICAgICAgICAgICAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICAgICAgICAgICAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gICAgICAgICAgICByZWQ6IFsyNTUsIDAsIDBdLFxuICAgICAgICAgICAgcm9zeWJyb3duOiBbMTg4LCAxNDMsIDE0M10sXG4gICAgICAgICAgICByb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjVdLFxuICAgICAgICAgICAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gICAgICAgICAgICBzYWxtb246IFsyNTAsIDEyOCwgMTE0XSxcbiAgICAgICAgICAgIHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTZdLFxuICAgICAgICAgICAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gICAgICAgICAgICBzZWFzaGVsbDogWzI1NSwgMjQ1LCAyMzhdLFxuICAgICAgICAgICAgc2llbm5hOiBbMTYwLCA4MiwgNDVdLFxuICAgICAgICAgICAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgICAgICAgICBza3libHVlOiBbMTM1LCAyMDYsIDIzNV0sXG4gICAgICAgICAgICBzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDVdLFxuICAgICAgICAgICAgc2xhdGVncmF5OiBbMTE5LCAxMjgsIDE0NF0sXG4gICAgICAgICAgICBzbGF0ZWdyZXk6IFsxMTksIDEyOCwgMTQ0XSxcbiAgICAgICAgICAgIHNub3c6IFsyNTUsIDI1NSwgMjUwXSxcbiAgICAgICAgICAgIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICAgICAgICAgICAgc3RlZWxibHVlOiBbNzAsIDEzMCwgMTgwXSxcbiAgICAgICAgICAgIHRhbjogWzIxMCwgMTgwLCAxNDBdLFxuICAgICAgICAgICAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgICAgICAgICAgIHRoaXN0bGU6IFsyMTYsIDE5MSwgMjE2XSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiBbMjU1LCAyNTUsIDI1NSwgMF0sXG4gICAgICAgICAgICB0b21hdG86IFsyNTUsIDk5LCA3MV0sXG4gICAgICAgICAgICB0dXJxdW9pc2U6IFs2NCwgMjI0LCAyMDhdLFxuICAgICAgICAgICAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gICAgICAgICAgICB3aGVhdDogWzI0NSwgMjIyLCAxNzldLFxuICAgICAgICAgICAgd2hpdGU6IFsyNTUsIDI1NSwgMjU1XSxcbiAgICAgICAgICAgIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgICAgICAgICAgIHllbGxvdzogWzI1NSwgMjU1LCAwXSxcbiAgICAgICAgICAgIHllbGxvd2dyZWVuOiBbMTU0LCAyMDUsIDVdXG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCX1JFR0VYID0gL3JnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpLztcblxuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2UgVXRpbFxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqL1xuICAgIEtvbnZhLlV0aWwgPSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGNoZXJyeS1waWNrZWQgdXRpbGl0aWVzIGZyb20gdW5kZXJzY29yZS5qc1xuICAgICAgICAgKi9cbiAgICAgICAgX2lzRWxlbWVudDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuICEhKG9iaiAmJiBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNhbGwgJiYgb2JqLmFwcGx5KTtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiAoISFvYmogJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuICAgICAgICB9LFxuICAgICAgICBfaXNBcnJheTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9BUlJBWTtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzTnVtYmVyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX05VTUJFUjtcbiAgICAgICAgfSxcbiAgICAgICAgX2lzU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX1NUUklORztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gICAgICAgIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAgICAgICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gICAgICAgIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gICAgICAgIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICAgICAgICBfdGhyb3R0bGU6IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLypcbiAgICAgICAgICogb3RoZXIgdXRpbHNcbiAgICAgICAgICovXG4gICAgICAgIF9oYXNNZXRob2RzOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IFtdLFxuICAgICAgICAgICAgICAgIGtleTtcblxuICAgICAgICAgICAgZm9yKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih0aGlzLl9pc0Z1bmN0aW9uKG9ialtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWVzLmxlbmd0aCA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGlzVmFsaWRTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpcnN0Q2hhciA9IHNlbGVjdG9yWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0Q2hhciA9PT0gJyMnIHx8IGZpcnN0Q2hhciA9PT0gJy4nIHx8IGZpcnN0Q2hhciA9PT0gZmlyc3RDaGFyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IEtvbnZhLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgLy8gb24gc29tZSBlbnZpcm9ubWVudHMgY2FudmFzLnN0eWxlIGlzIHJlYWRvbmx5XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZSA9IGNhbnZhcy5zdHlsZSB8fCB7fTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH0sXG4gICAgICAgIGlzQnJvd3NlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBleHBvcnRzICE9PSAnb2JqZWN0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc0luRG9jdW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB3aGlsZShlbCA9IGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZihlbCA9PSBLb252YS5kb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIF9zaW1wbGlmeUFycmF5OiBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgICAgIHZhciByZXRBcnIgPSBbXSxcbiAgICAgICAgICAgICAgICBsZW4gPSBhcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHV0aWwgPSBLb252YS5VdGlsLFxuICAgICAgICAgICAgICAgIG4sIHZhbDtcblxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gYXJyW25dO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLl9pc051bWJlcih2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IE1hdGgucm91bmQodmFsICogMTAwMCkgLyAxMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdXRpbC5faXNTdHJpbmcodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXRBcnIucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiBhcmcgY2FuIGJlIGFuIGltYWdlIG9iamVjdCBvciBpbWFnZSBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0SW1hZ2U6IGZ1bmN0aW9uKGFyZywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpbWFnZU9iaiwgY2FudmFzO1xuXG4gICAgICAgICAgICAvLyBpZiBhcmcgaXMgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGlmKCFhcmcpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYXJnIGlzIGFscmVhZHkgYW4gaW1hZ2Ugb2JqZWN0XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuX2lzRWxlbWVudChhcmcpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soYXJnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYXJnIGlzIGEgc3RyaW5nLCB0aGVuIGl0J3MgYSBkYXRhIHVybFxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLl9pc1N0cmluZyhhcmcpKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2VPYmogPSBuZXcgS29udmEud2luZG93LkltYWdlKCk7XG4gICAgICAgICAgICAgICAgaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGltYWdlT2JqKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltYWdlT2JqLnNyYyA9IGFyZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9pZiBhcmcgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgcHJvcGVydHksIGl0J3MgYW4gaW1hZ2Ugb2JqZWN0XG4gICAgICAgICAgICBlbHNlIGlmKGFyZy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gYXJnLndpZHRoO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBhcmcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBfY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KENPTlRFWFRfMkQpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnB1dEltYWdlRGF0YShhcmcsIDAsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldEltYWdlKGNhbnZhcy50b0RhdGFVUkwoKSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRSR0JBU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciByZWQgPSBvYmoucmVkIHx8IDAsXG4gICAgICAgICAgICAgICAgZ3JlZW4gPSBvYmouZ3JlZW4gfHwgMCxcbiAgICAgICAgICAgICAgICBibHVlID0gb2JqLmJsdWUgfHwgMCxcbiAgICAgICAgICAgICAgICBhbHBoYSA9IG9iai5hbHBoYSB8fCAxO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdyZ2JhKCcsXG4gICAgICAgICAgICAgICAgcmVkLFxuICAgICAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICAgICBncmVlbixcbiAgICAgICAgICAgICAgICAnLCcsXG4gICAgICAgICAgICAgICAgYmx1ZSxcbiAgICAgICAgICAgICAgICAnLCcsXG4gICAgICAgICAgICAgICAgYWxwaGEsXG4gICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICBdLmpvaW4oRU1QVFlfU1RSSU5HKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3JnYlRvSGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgxIDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICB9LFxuICAgICAgICBfaGV4VG9SZ2I6IGZ1bmN0aW9uKGhleCkge1xuICAgICAgICAgICAgaGV4ID0gaGV4LnJlcGxhY2UoSEFTSCwgRU1QVFlfU1RSSU5HKTtcbiAgICAgICAgICAgIHZhciBiaWdpbnQgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcjogKGJpZ2ludCA+PiAxNikgJiAyNTUsXG4gICAgICAgICAgICAgICAgZzogKGJpZ2ludCA+PiA4KSAmIDI1NSxcbiAgICAgICAgICAgICAgICBiOiBiaWdpbnQgJiAyNTVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gcmFuZG9tIGhleCBjb2xvclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmFuZG9tQ29sb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJhbmRDb2xvciA9IChNYXRoLnJhbmRvbSgpICogMHhGRkZGRkYgPDwgMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgd2hpbGUgKHJhbmRDb2xvci5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICAgICAgcmFuZENvbG9yID0gWkVSTyArIHJhbmRDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBIQVNIICsgcmFuZENvbG9yO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIHZhbHVlIHdpdGggZGVmYXVsdCBmYWxsYmFja1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbih2YWwsIGRlZikge1xuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgUkdCIGNvbXBvbmVudHMgb2YgYSBjb2xvclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5VdGlsLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gZWFjaCBvZiB0aGUgZm9sbG93aW5nIGV4YW1wbGVzIHJldHVybiB7cjowLCBnOjAsIGI6MjU1fVxuICAgICAgICAgKiB2YXIgcmdiID0gS29udmEuVXRpbC5nZXRSR0IoJ2JsdWUnKTtcbiAgICAgICAgICogdmFyIHJnYiA9IEtvbnZhLlV0aWwuZ2V0UkdCKCcjMDAwMGZmJyk7XG4gICAgICAgICAqIHZhciByZ2IgPSBLb252YS5VdGlsLmdldFJHQigncmdiKDAsMCwyNTUpJyk7XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSR0I6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgcmdiO1xuICAgICAgICAgICAgLy8gY29sb3Igc3RyaW5nXG4gICAgICAgICAgICBpZiAoY29sb3IgaW4gQ09MT1JTKSB7XG4gICAgICAgICAgICAgICAgcmdiID0gQ09MT1JTW2NvbG9yXTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByOiByZ2JbMF0sXG4gICAgICAgICAgICAgICAgICAgIGc6IHJnYlsxXSxcbiAgICAgICAgICAgICAgICAgICAgYjogcmdiWzJdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhleFxuICAgICAgICAgICAgZWxzZSBpZiAoY29sb3JbMF0gPT09IEhBU0gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGV4VG9SZ2IoY29sb3Iuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJnYiBzdHJpbmdcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yLnN1YnN0cigwLCA0KSA9PT0gUkdCX1BBUkVOKSB7XG4gICAgICAgICAgICAgICAgcmdiID0gUkdCX1JFR0VYLmV4ZWMoY29sb3IucmVwbGFjZSgvIC9nLCAnJykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50KHJnYlsxXSwgMTApLFxuICAgICAgICAgICAgICAgICAgICBnOiBwYXJzZUludChyZ2JbMl0sIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgYjogcGFyc2VJbnQocmdiWzNdLCAxMClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVmYXVsdFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcjogMCxcbiAgICAgICAgICAgICAgICAgICAgZzogMCxcbiAgICAgICAgICAgICAgICAgICAgYjogMFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGNvbnZlcnQgYW55IGNvbG9yIHN0cmluZyB0byBSR0JBIG9iamVjdFxuICAgICAgICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvY29sb3ItcGFyc2VyXG4gICAgICAgIGNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ciB8fCAnYmxhY2snO1xuICAgICAgICAgICAgcmV0dXJuIEtvbnZhLlV0aWwuX25hbWVkQ29sb3JUb1JCQShzdHIpXG4gICAgICAgICAgICAgICAgfHwgS29udmEuVXRpbC5faGV4M0NvbG9yVG9SR0JBKHN0cilcbiAgICAgICAgICAgICAgICB8fCBLb252YS5VdGlsLl9oZXg2Q29sb3JUb1JHQkEoc3RyKVxuICAgICAgICAgICAgICAgIHx8IEtvbnZhLlV0aWwuX3JnYkNvbG9yVG9SR0JBKHN0cilcbiAgICAgICAgICAgICAgICB8fCBLb252YS5VdGlsLl9yZ2JhQ29sb3JUb1JHQkEoc3RyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUGFyc2UgbmFtZWQgY3NzIGNvbG9yLiBMaWtlIFwiZ3JlZW5cIlxuICAgICAgICBfbmFtZWRDb2xvclRvUkJBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciBjID0gQ09MT1JTW3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmICghYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByOiBjWzBdLFxuICAgICAgICAgICAgICAgIGc6IGNbMV0sXG4gICAgICAgICAgICAgICAgYjogY1syXSxcbiAgICAgICAgICAgICAgICBhOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvLyBQYXJzZSByZ2IobiwgbiwgbilcbiAgICAgICAgX3JnYkNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIGlmIChzdHIuaW5kZXhPZigncmdiKCcpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLm1hdGNoKC9yZ2JcXCgoW14pXSspXFwpLylbMV07XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKiwgKi8pLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICBnOiBwYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgYjogcGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIGE6IDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBQYXJzZSByZ2JhKG4sIG4sIG4sIG4pXG4gICAgICAgIF9yZ2JhQ29sb3JUb1JHQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdyZ2JhKCcpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLm1hdGNoKC9yZ2JhXFwoKFteKV0rKVxcKS8pWzFdO1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICosICovKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByOiBwYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgZzogcGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIGI6IHBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBhOiBwYXJ0c1szXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcbiAgICAgICAgLy8gUGFyc2UgI25ubm5ublxuICAgICAgICBfaGV4NkNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIGlmICgoc3RyWzBdID09PSAnIycpICYmIChzdHIubGVuZ3RoID09PSA3KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50KHN0ci5zbGljZSgxLCAzKSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBnOiBwYXJzZUludChzdHIuc2xpY2UoMywgNSksIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgYjogcGFyc2VJbnQoc3RyLnNsaWNlKDUsIDcpLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIGE6IDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBQYXJzZSAjbm5uXG4gICAgICAgIF9oZXgzQ29sb3JUb1JHQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgaWYgKChzdHJbMF0gPT09ICcjJykgJiYgKHN0ci5sZW5ndGggPT09IDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcjogcGFyc2VJbnQoc3RyWzFdICsgc3RyWzFdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50KHN0clsyXSArIHN0clsyXSwgMTYpLFxuICAgICAgICAgICAgICAgICAgICBiOiBwYXJzZUludChzdHJbM10gKyBzdHJbM10sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgYTogMVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG8xIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBvMlxuICAgICAgICBfbWVyZ2U6IGZ1bmN0aW9uKG8xLCBvMikge1xuICAgICAgICAgICAgdmFyIHJldE9iaiA9IHRoaXMuX2Nsb25lKG8yKTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIG8xKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5faXNPYmplY3QobzFba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0T2JqW2tleV0gPSB0aGlzLl9tZXJnZShvMVtrZXldLCByZXRPYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXRPYmpba2V5XSA9IG8xW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldE9iajtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmVPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIHJldE9iaiA9IHt9O1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5faXNPYmplY3Qob2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldE9ialtrZXldID0gdGhpcy5jbG9uZU9iamVjdChvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQXJyYXkob2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldE9ialtrZXldID0gdGhpcy5jbG9uZUFycmF5KG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXRPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXRPYmo7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb25lQXJyYXk6IGZ1bmN0aW9uKGFycikge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5zbGljZSgwKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2RlZ1RvUmFkOiBmdW5jdGlvbihkZWcpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWcgKiBQSV9PVkVSX0RFRzE4MDtcbiAgICAgICAgfSxcbiAgICAgICAgX3JhZFRvRGVnOiBmdW5jdGlvbihyYWQpIHtcbiAgICAgICAgICAgIHJldHVybiByYWQgKiBERUcxODBfT1ZFUl9QSTtcbiAgICAgICAgfSxcbiAgICAgICAgX2NhcGl0YWxpemU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGhyb3c6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEtPTlZBX0VSUk9SICsgc3RyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoS09OVkFfRVJST1IgKyBzdHIpO1xuICAgICAgICB9LFxuICAgICAgICB3YXJuOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBJRTkgb24gV2luZG93czcgNjRiaXQgd2lsbCB0aHJvdyBhIEpTIGVycm9yXG4gICAgICAgICAgICAgKiBpZiB3ZSBkb24ndCB1c2Ugd2luZG93LmNvbnNvbGUgaW4gdGhlIGNvbmRpdGlvbmFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmKEtvbnZhLmdsb2JhbC5jb25zb2xlICYmIGNvbnNvbGUud2FybiAmJiBLb252YS5zaG93V2FybmluZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oS09OVkFfV0FSTklORyArIHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZDogZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gQ3RvcigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgb2xkUHJvdG8gPSBjaGlsZC5wcm90b3R5cGU7XG4gICAgICAgICAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgQ3RvcigpO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9sZFByb3RvKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFByb3RvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlW2tleV0gPSBvbGRQcm90b1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcmVmZXJlbmNlIHRvIHBhcmVudFxuICAgICAgICAgICAgY2hpbGQuc3VwZXIgPSBwYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGRzIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvciBwcm90b3R5cGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVXRpbC5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1ldGhvZHNcbiAgICAgICAgICovXG4gICAgICAgIGFkZE1ldGhvZHM6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBtZXRob2RzKSB7XG4gICAgICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRDb250cm9sUG9pbnRzOiBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB0KSB7XG4gICAgICAgICAgICB2YXIgZDAxID0gTWF0aC5zcXJ0KE1hdGgucG93KHgxIC0geDAsIDIpICsgTWF0aC5wb3coeTEgLSB5MCwgMikpLFxuICAgICAgICAgICAgICAgIGQxMiA9IE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCAyKSArIE1hdGgucG93KHkyIC0geTEsIDIpKSxcbiAgICAgICAgICAgICAgICBmYSA9IHQgKiBkMDEgLyAoZDAxICsgZDEyKSxcbiAgICAgICAgICAgICAgICBmYiA9IHQgKiBkMTIgLyAoZDAxICsgZDEyKSxcbiAgICAgICAgICAgICAgICBwMXggPSB4MSAtIGZhICogKHgyIC0geDApLFxuICAgICAgICAgICAgICAgIHAxeSA9IHkxIC0gZmEgKiAoeTIgLSB5MCksXG4gICAgICAgICAgICAgICAgcDJ4ID0geDEgKyBmYiAqICh4MiAtIHgwKSxcbiAgICAgICAgICAgICAgICBwMnkgPSB5MSArIGZiICogKHkyIC0geTApO1xuXG4gICAgICAgICAgICByZXR1cm4gW3AxeCwgcDF5LCBwMngsIHAyeV07XG4gICAgICAgIH0sXG4gICAgICAgIF9leHBhbmRQb2ludHM6IGZ1bmN0aW9uKHAsIHRlbnNpb24pIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBwLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhbGxQb2ludHMgPSBbXSxcbiAgICAgICAgICAgICAgICBuLCBjcDtcblxuICAgICAgICAgICAgZm9yIChuID0gMjsgbiA8IGxlbiAtIDI7IG4gKz0gMikge1xuICAgICAgICAgICAgICAgIGNwID0gS29udmEuVXRpbC5fZ2V0Q29udHJvbFBvaW50cyhwW24gLSAyXSwgcFtuIC0gMV0sIHBbbl0sIHBbbiArIDFdLCBwW24gKyAyXSwgcFtuICsgM10sIHRlbnNpb24pO1xuICAgICAgICAgICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzBdKTtcbiAgICAgICAgICAgICAgICBhbGxQb2ludHMucHVzaChjcFsxXSk7XG4gICAgICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2gocFtuXSk7XG4gICAgICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2gocFtuICsgMV0pO1xuICAgICAgICAgICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzJdKTtcbiAgICAgICAgICAgICAgICBhbGxQb2ludHMucHVzaChjcFszXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhbGxQb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIF9yZW1vdmVMYXN0TGV0dGVyOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgZWFjaDogZnVuY3Rpb24ob2JqLCBmdW5jKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgZnVuYyhrZXksIG9ialtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldFByb2plY3Rpb25Ub1NlZ21lbnQ6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgICAgIHZhciB4LCB5LCBkaXN0O1xuXG4gICAgICAgICAgICB2YXIgcGQyID0gKHgxIC0geDIpICogKHgxIC0geDIpICsgKHkxIC0geTIpICogKHkxIC0geTIpO1xuICAgICAgICAgICAgaWYocGQyID09IDApIHtcbiAgICAgICAgICAgICAgICB4ID0geDE7XG4gICAgICAgICAgICAgICAgeSA9IHkxO1xuICAgICAgICAgICAgICAgIGRpc3QgPSAoeDMgLSB4MikgKiAoeDMgLSB4MikgKyAoeTMgLSB5MikgKiAoeTMgLSB5Mik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB1ID0gKCh4MyAtIHgxKSAqICh4MiAtIHgxKSArICh5MyAtIHkxKSAqICh5MiAtIHkxKSkgLyBwZDI7XG4gICAgICAgICAgICAgICAgaWYodSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgxO1xuICAgICAgICAgICAgICAgICAgICB5ID0geTE7XG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSAoeDEgLSB4MykgKiAoeDEgLSB4MykgKyAoeTEgLSB5MykgKiAoeTEgLSB5Myk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh1ID4gMS4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkyO1xuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gKHgyIC0geDMpICogKHgyIC0geDMpICsgKHkyIC0geTMpICogKHkyIC0geTMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4MSArIHUgKiAoeDIgLSB4MSk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5MSArIHUgKiAoeTIgLSB5MSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSAoeCAtIHgzKSAqICh4IC0geDMpICsgKHkgLSB5MykgKiAoeSAtIHkzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3gsIHksIGRpc3RdO1xuICAgICAgICB9LFxuICAgICAgICAvLyBsaW5lIGFzIGFycmF5IG9mIHBvaW50cy5cbiAgICAgICAgLy8gbGluZSBtaWdodCBiZSBjbG9zZWRcbiAgICAgICAgX2dldFByb2plY3Rpb25Ub0xpbmU6IGZ1bmN0aW9uKHB0LCBsaW5lLCBpc0Nsb3NlZCkge1xuICAgICAgICAgICAgdmFyIHBjID0gS29udmEuVXRpbC5jbG9uZU9iamVjdChwdCk7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICBsaW5lLmZvckVhY2goZnVuY3Rpb24ocDEsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2xvc2VkICYmIGkgPT09IGxpbmUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwMiA9IGxpbmVbKGkgKyAxKSAlIGxpbmUubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvaiA9IEtvbnZhLlV0aWwuX2dldFByb2plY3Rpb25Ub1NlZ21lbnQocDEueCwgcDEueSwgcDIueCwgcDIueSwgcHQueCwgcHQueSk7XG4gICAgICAgICAgICAgICAgdmFyIHB4ID0gcHJvalswXSwgcHkgPSBwcm9qWzFdLCBwZGlzdCA9IHByb2pbMl07XG4gICAgICAgICAgICAgICAgaWYgKHBkaXN0IDwgZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBwYy54ID0gcHg7XG4gICAgICAgICAgICAgICAgICAgIHBjLnkgPSBweTtcbiAgICAgICAgICAgICAgICAgICAgZGlzdCA9IHBkaXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBjO1xuICAgICAgICB9LFxuICAgICAgICBfcHJlcGFyZUFycmF5Rm9yVHdlZW46IGZ1bmN0aW9uKHN0YXJ0QXJyYXksIGVuZEFycmF5LCBpc0Nsb3NlZCkge1xuICAgICAgICAgICAgdmFyIG4sIHN0YXJ0ID0gW10sIGVuZCA9IFtdO1xuICAgICAgICAgICAgaWYgKHN0YXJ0QXJyYXkubGVuZ3RoID4gZW5kQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBlbmRBcnJheTtcbiAgICAgICAgICAgICAgICBlbmRBcnJheSA9IHN0YXJ0QXJyYXk7XG4gICAgICAgICAgICAgICAgc3RhcnRBcnJheSA9IHRlbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgc3RhcnRBcnJheS5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgICAgICAgIHN0YXJ0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB4OiBzdGFydEFycmF5W25dLFxuICAgICAgICAgICAgICAgICAgICB5OiBzdGFydEFycmF5W24gKyAxXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGVuZEFycmF5Lmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICAgICAgZW5kLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB4OiBlbmRBcnJheVtuXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZW5kQXJyYXlbbiArIDFdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdmFyIG5ld1N0YXJ0ID0gW107XG4gICAgICAgICAgICBlbmQuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBwciA9IEtvbnZhLlV0aWwuX2dldFByb2plY3Rpb25Ub0xpbmUocG9pbnQsIHN0YXJ0LCBpc0Nsb3NlZCk7XG4gICAgICAgICAgICAgICAgbmV3U3RhcnQucHVzaChwci54KTtcbiAgICAgICAgICAgICAgICBuZXdTdGFydC5wdXNoKHByLnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3U3RhcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9wcmVwYXJlVG9TdHJpbmdpZnk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIGRlc2M7XG5cbiAgICAgICAgICAgIG9iai52aXNpdGVkQnlDaXJjdWxhclJlZmVyZW5jZVJlbW92YWwgPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoIShvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBvYmpba2V5XSAmJiB0eXBlb2Ygb2JqW2tleV0gPT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG9ialtrZXldLnZpc2l0ZWRCeUNpcmN1bGFyUmVmZXJlbmNlUmVtb3ZhbCB8fCBLb252YS5VdGlsLl9pc0VsZW1lbnQob2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEtvbnZhLlV0aWwuX3ByZXBhcmVUb1N0cmluZ2lmeShvYmpba2V5XSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIG9iai52aXNpdGVkQnlDaXJjdWxhclJlZmVyZW5jZVJlbW92YWw7XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBjYWxjdWxhdGUgcGl4ZWwgcmF0aW9cbiAgICB2YXIgY2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgX3BpeGVsUmF0aW8gPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gS29udmEud2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcbiAgICAgICAgICAgIGJhY2tpbmdTdG9yZVJhdGlvID0gY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgfHwgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgfHwgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW9cbiAgICAgICAgICAgICAgICB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgfHwgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvXG4gICAgICAgICAgICAgICAgfHwgMTtcbiAgICAgICAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgICAgIH0pKCk7XG5cbiAgICAvKipcbiAgICAgKiBDYW52YXMgUmVuZGVyZXIgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy53aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5waXhlbFJhdGlvIEtvbnZhSlMgYXV0b21hdGljYWxseSBoYW5kbGVzIHBpeGVsIHJhdGlvIGFkanVzdG1lbnRzIGluIG9yZGVyIHRvIHJlbmRlciBjcmlzcCBkcmF3aW5nc1xuICAgICAqICBvbiBhbGwgZGV2aWNlcy4gTW9zdCBkZXNrdG9wcywgbG93IGVuZCB0YWJsZXRzLCBhbmQgbG93IGVuZCBwaG9uZXMsIGhhdmUgZGV2aWNlIHBpeGVsIHJhdGlvc1xuICAgICAqICBvZiAxLiAgU29tZSBoaWdoIGVuZCB0YWJsZXRzIGFuZCBwaG9uZXMsIGxpa2UgaVBob25lcyBhbmQgaVBhZHMgKG5vdCB0aGUgbWluaSkgaGF2ZSBhIGRldmljZSBwaXhlbCByYXRpb1xuICAgICAqICBvZiAyLiAgU29tZSBNYWNib29rIFByb3MsIGFuZCBpTWFjcyBhbHNvIGhhdmUgYSBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgMi4gIFNvbWUgaGlnaCBlbmQgQW5kcm9pZCBkZXZpY2VzIGhhdmUgcGl4ZWxcbiAgICAgKiAgcmF0aW9zIG9mIDIgb3IgMy4gIFNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94IGFsbG93IHlvdSB0byBjb25maWd1cmUgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSB2aWV3cG9ydC4gIFVubGVzcyBvdGhlcndpc2VcbiAgICAgKiAgc3BlY2lmaWVkLCB0aGUgcGl4ZWwgcmF0aW8gd2lsbCBiZSBkZWZhdWx0ZWQgdG8gdGhlIGFjdHVhbCBkZXZpY2UgcGl4ZWwgcmF0aW8uICBZb3UgY2FuIG92ZXJyaWRlIHRoZSBkZXZpY2UgcGl4ZWxcbiAgICAgKiAgcmF0aW8gZm9yIHNwZWNpYWwgc2l0dWF0aW9ucywgb3IsIGlmIHlvdSBkb24ndCB3YW50IHRoZSBwaXhlbCByYXRpbyB0byBiZSB0YWtlbiBpbnRvIGFjY291bnQsIHlvdSBjYW4gc2V0IGl0IHRvIDEuXG4gICAgICovXG4gICAgS29udmEuQ2FudmFzID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuaW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5DYW52YXMucHJvdG90eXBlID0ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IGNvbmYucGl4ZWxSYXRpbyB8fCBLb252YS5waXhlbFJhdGlvIHx8IF9waXhlbFJhdGlvO1xuXG4gICAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG5cbiAgICAgICAgICAgIC8vIHNldCBpbmxpbmUgc3R5bGVzXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUucGFkZGluZyA9IDA7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUubWFyZ2luID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5ib3JkZXIgPSAwO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS50b3AgPSAwO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGNhbnZhcyBjb250ZXh0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0NhbnZhc0NvbnRleHR9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBwaXhlbCByYXRpb1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBpeGVsIHJhdGlvXG4gICAgICAgICAqL1xuICAgICAgICBnZXRQaXhlbFJhdGlvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgcGl4ZWwgcmF0aW9cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcGl4ZWxSYXRpbyBLb252YUpTIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBwaXhlbCByYXRpbyBhZHVzdG1lbnRzIGluIG9yZGVyIHRvIHJlbmRlciBjcmlzcCBkcmF3aW5nc1xuICAgICAgICAgKiAgb24gYWxsIGRldmljZXMuIE1vc3QgZGVza3RvcHMsIGxvdyBlbmQgdGFibGV0cywgYW5kIGxvdyBlbmQgcGhvbmVzLCBoYXZlIGRldmljZSBwaXhlbCByYXRpb3NcbiAgICAgICAgICogIG9mIDEuICBTb21lIGhpZ2ggZW5kIHRhYmxldHMgYW5kIHBob25lcywgbGlrZSBpUGhvbmVzIGFuZCBpUGFkcyBoYXZlIGEgZGV2aWNlIHBpeGVsIHJhdGlvXG4gICAgICAgICAqICBvZiAyLiAgU29tZSBNYWNib29rIFByb3MsIGFuZCBpTWFjcyBhbHNvIGhhdmUgYSBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgMi4gIFNvbWUgaGlnaCBlbmQgQW5kcm9pZCBkZXZpY2VzIGhhdmUgcGl4ZWxcbiAgICAgICAgICogIHJhdGlvcyBvZiAyIG9yIDMuICBTb21lIGJyb3dzZXJzIGxpa2UgRmlyZWZveCBhbGxvdyB5b3UgdG8gY29uZmlndXJlIHRoZSBwaXhlbCByYXRpbyBvZiB0aGUgdmlld3BvcnQuICBVbmxlc3Mgb3RoZXJ3aXNlXG4gICAgICAgICAqICBzcGVjaWZpY2VkLCB0aGUgcGl4ZWwgcmF0aW8gd2lsbCBiZSBkZWZhdWx0ZWQgdG8gdGhlIGFjdHVhbCBkZXZpY2UgcGl4ZWwgcmF0aW8uICBZb3UgY2FuIG92ZXJyaWRlIHRoZSBkZXZpY2UgcGl4ZWxcbiAgICAgICAgICogIHJhdGlvIGZvciBzcGVjaWFsIHNpdHVhdGlvbnMsIG9yLCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgcGl4ZWwgcmF0aW8gdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LCB5b3UgY2FuIHNldCBpdCB0byAxLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UGl4ZWxSYXRpbzogZnVuY3Rpb24ocGl4ZWxSYXRpbykge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5zZXRTaXplKHRoaXMuZ2V0V2lkdGgoKSAvIHByZXZpb3VzUmF0aW8sIHRoaXMuZ2V0SGVpZ2h0KCkgLyBwcmV2aW91c1JhdGlvKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCB3aWR0aFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBwaXhlbCByYXRpb1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2NhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXG4gICAgICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgICAgICAgICBfY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLl9jb250ZXh0O1xuICAgICAgICAgICAgX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgaGVpZ2h0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IHBpeGVsIHJhdGlvXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICAgICAgICAgIF9jb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KCkuX2NvbnRleHQ7XG4gICAgICAgICAgICBfY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB3aWR0aFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHdpZHRoXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBoZWlnaHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgc2l6ZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICAgICAqL1xuICAgICAgICBzZXRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFdpZHRoKHdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0byBkYXRhIHVybFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbGl0eSBiZXR3ZWVuIDAgYW5kIDEgZm9yIGpwZyBtaW1lIHR5cGVzXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGRhdGEgdXJsIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdG9EYXRhVVJMOiBmdW5jdGlvbihtaW1lVHlwZSwgcXVhbGl0eSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGNhbGwgZmFpbHMgKGR1ZSB0byBicm93c2VyIGJ1ZywgbGlrZSBpbiBGaXJlZm94IDMuNiksXG4gICAgICAgICAgICAgICAgLy8gdGhlbiByZXZlcnQgdG8gcHJldmlvdXMgbm8tcGFyYW1ldGVyIGltYWdlL3BuZyBiZWhhdmlvclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlLCBxdWFsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdVbmFibGUgdG8gZ2V0IGRhdGEgVVJMLiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLlNjZW5lQ2FudmFzID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuICAgICAgICB2YXIgd2lkdGggPSBjb25mLndpZHRoIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25mLmhlaWdodCB8fCAwO1xuXG4gICAgICAgIEtvbnZhLkNhbnZhcy5jYWxsKHRoaXMsIGNvbmYpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgS29udmEuU2NlbmVDb250ZXh0KHRoaXMpO1xuICAgICAgICB0aGlzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlNjZW5lQ2FudmFzLCBLb252YS5DYW52YXMpO1xuXG4gICAgS29udmEuSGl0Q2FudmFzID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuICAgICAgICB2YXIgd2lkdGggPSBjb25mLndpZHRoIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25mLmhlaWdodCB8fCAwO1xuXG4gICAgICAgIEtvbnZhLkNhbnZhcy5jYWxsKHRoaXMsIGNvbmYpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgS29udmEuSGl0Q29udGV4dCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhpdENhbnZhcyA9IHRydWU7XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5IaXRDYW52YXMsIEtvbnZhLkNhbnZhcyk7XG5cbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIENPTU1BID0gJywnLFxuICAgICAgICBPUEVOX1BBUkVOID0gJygnLFxuICAgICAgICBDTE9TRV9QQVJFTiA9ICcpJyxcbiAgICAgICAgT1BFTl9QQVJFTl9CUkFDS0VUID0gJyhbJyxcbiAgICAgICAgQ0xPU0VfQlJBQ0tFVF9QQVJFTiA9ICddKScsXG4gICAgICAgIFNFTUlDT0xPTiA9ICc7JyxcbiAgICAgICAgRE9VQkxFX1BBUkVOID0gJygpJyxcbiAgICAgICAgLy8gRU1QVFlfU1RSSU5HID0gJycsXG4gICAgICAgIEVRVUFMUyA9ICc9JyxcbiAgICAgICAgLy8gU0VUID0gJ3NldCcsXG4gICAgICAgIENPTlRFWFRfTUVUSE9EUyA9IFtcbiAgICAgICAgICAgICdhcmMnLFxuICAgICAgICAgICAgJ2FyY1RvJyxcbiAgICAgICAgICAgICdiZWdpblBhdGgnLFxuICAgICAgICAgICAgJ2JlemllckN1cnZlVG8nLFxuICAgICAgICAgICAgJ2NsZWFyUmVjdCcsXG4gICAgICAgICAgICAnY2xpcCcsXG4gICAgICAgICAgICAnY2xvc2VQYXRoJyxcbiAgICAgICAgICAgICdjcmVhdGVMaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAnY3JlYXRlUGF0dGVybicsXG4gICAgICAgICAgICAnY3JlYXRlUmFkaWFsR3JhZGllbnQnLFxuICAgICAgICAgICAgJ2RyYXdJbWFnZScsXG4gICAgICAgICAgICAnZmlsbCcsXG4gICAgICAgICAgICAnZmlsbFRleHQnLFxuICAgICAgICAgICAgJ2dldEltYWdlRGF0YScsXG4gICAgICAgICAgICAnY3JlYXRlSW1hZ2VEYXRhJyxcbiAgICAgICAgICAgICdsaW5lVG8nLFxuICAgICAgICAgICAgJ21vdmVUbycsXG4gICAgICAgICAgICAncHV0SW1hZ2VEYXRhJyxcbiAgICAgICAgICAgICdxdWFkcmF0aWNDdXJ2ZVRvJyxcbiAgICAgICAgICAgICdyZWN0JyxcbiAgICAgICAgICAgICdyZXN0b3JlJyxcbiAgICAgICAgICAgICdyb3RhdGUnLFxuICAgICAgICAgICAgJ3NhdmUnLFxuICAgICAgICAgICAgJ3NjYWxlJyxcbiAgICAgICAgICAgICdzZXRMaW5lRGFzaCcsXG4gICAgICAgICAgICAnc2V0VHJhbnNmb3JtJyxcbiAgICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICAgJ3N0cm9rZVRleHQnLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICAgICAndHJhbnNsYXRlJ1xuICAgICAgICBdO1xuXG4gICAgdmFyIENPTlRFWFRfUFJPUEVSVElFUyA9IFsnZmlsbFN0eWxlJywgJ3N0cm9rZVN0eWxlJywgJ3NoYWRvd0NvbG9yJywgJ3NoYWRvd0JsdXInLCAnc2hhZG93T2Zmc2V0WCcsXG4gICAgICAgICdzaGFkb3dPZmZzZXRZJywgJ2xpbmVDYXAnLCAnbGluZUpvaW4nLCAnbGluZVdpZHRoJywgJ21pdGVyTGltaXQnLCAnZm9udCcsICd0ZXh0QWxpZ24nLCAndGV4dEJhc2VsaW5lJyxcbiAgICAgICAgJ2dsb2JhbEFscGhhJywgJ2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiddO1xuXG4gICAgLyoqXG4gICAgICogQ2FudmFzIENvbnRleHQgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKi9cbiAgICBLb252YS5Db250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgIHRoaXMuaW5pdChjYW52YXMpO1xuICAgIH07XG5cbiAgICBLb252YS5Db250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjYW52YXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBpZiAoS29udmEuZW5hYmxlVHJhY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlQXJyID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlVHJhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpbGwgc2hhcGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtLb252YS5TaGFwZX0gc2hhcGVcbiAgICAgICAgICovXG4gICAgICAgIGZpbGxTaGFwZTogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIGlmKHNoYXBlLmdldEZpbGxFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsKHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0cm9rZSBzaGFwZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLlNoYXBlfSBzaGFwZVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlU2hhcGU6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICBpZihzaGFwZS5nZXRTdHJva2VFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2Uoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZmlsbCB0aGVuIHN0cm9rZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLlNoYXBlfSBzaGFwZVxuICAgICAgICAgKi9cbiAgICAgICAgZmlsbFN0cm9rZVNoYXBlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGZpbGxFbmFibGVkID0gc2hhcGUuZ2V0RmlsbEVuYWJsZWQoKTtcbiAgICAgICAgICAgIGlmKGZpbGxFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzaGFwZS5nZXRTdHJva2VFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJva2Uoc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGNvbnRleHQgdHJhY2UgaWYgdHJhY2UgaXMgZW5hYmxlZFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbGF4ZWQgaWYgZmFsc2UsIHJldHVybiBzdHJpY3QgY29udGV4dCB0cmFjZSwgd2hpY2ggaW5jbHVkZXMgbWV0aG9kIG5hbWVzLCBtZXRob2QgcGFyYW1ldGVyc1xuICAgICAgICAgKiAgcHJvcGVydGllcywgYW5kIHByb3BlcnR5IHZhbHVlcy4gIElmIHRydWUsIHJldHVybiByZWxheGVkIGNvbnRleHQgdHJhY2UsIHdoaWNoIG9ubHkgcmV0dXJucyBtZXRob2QgbmFtZXMgYW5kXG4gICAgICAgICAqICBwcm9wZXJpdGVzLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VHJhY2U6IGZ1bmN0aW9uKHJlbGF4ZWQpIHtcbiAgICAgICAgICAgIHZhciB0cmFjZUFyciA9IHRoaXMudHJhY2VBcnIsXG4gICAgICAgICAgICAgICAgbGVuID0gdHJhY2VBcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHN0ciA9ICcnLFxuICAgICAgICAgICAgICAgIG4sIHRyYWNlLCBtZXRob2QsIGFyZ3M7XG5cbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIHRyYWNlID0gdHJhY2VBcnJbbl07XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHJhY2UubWV0aG9kO1xuXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IHRyYWNlLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBtZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxheGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gRE9VQkxFX1BBUkVOO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gT1BFTl9QQVJFTl9CUkFDS0VUICsgYXJncy5qb2luKENPTU1BKSArIENMT1NFX0JSQUNLRVRfUEFSRU47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gT1BFTl9QQVJFTiArIGFyZ3Muam9pbihDT01NQSkgKyBDTE9TRV9QQVJFTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSB0cmFjZS5wcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWxheGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gRVFVQUxTICsgdHJhY2UudmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RyICs9IFNFTUlDT0xPTjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsZWFyIHRyYWNlIGlmIHRyYWNlIGlzIGVuYWJsZWRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyVHJhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZUFyciA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBfdHJhY2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIHRyYWNlQXJyID0gdGhpcy50cmFjZUFycixcbiAgICAgICAgICAgICAgICBsZW47XG5cbiAgICAgICAgICAgIHRyYWNlQXJyLnB1c2goc3RyKTtcbiAgICAgICAgICAgIGxlbiA9IHRyYWNlQXJyLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKGxlbiA+PSBLb252YS50cmFjZUFyck1heCkge1xuICAgICAgICAgICAgICAgIHRyYWNlQXJyLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXNldCBjYW52YXMgY29udGV4dCB0cmFuc2Zvcm1cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5nZXRDYW52YXMoKS5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSgxICogcGl4ZWxSYXRpbywgMCwgMCwgMSAqIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGNhbnZhc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuQ2FudmFzfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsZWFyIGNhbnZhc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2JvdW5kc11cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMueF1cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMueV1cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMud2lkdGhdXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLmhlaWdodF1cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuXG4gICAgICAgICAgICBpZiAoYm91bmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclJlY3QoYm91bmRzLnggfHwgMCwgYm91bmRzLnkgfHwgMCwgYm91bmRzLndpZHRoIHx8IDAsIGJvdW5kcy5oZWlnaHQgfHwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMuZ2V0V2lkdGgoKSAvIGNhbnZhcy5waXhlbFJhdGlvLCBjYW52YXMuZ2V0SGVpZ2h0KCkgLyBjYW52YXMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hcHBseUxpbmVDYXA6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgbGluZUNhcCA9IHNoYXBlLmdldExpbmVDYXAoKTtcbiAgICAgICAgICAgIGlmKGxpbmVDYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVDYXAnLCBsaW5lQ2FwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2FwcGx5T3BhY2l0eTogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBhYnNPcGFjaXR5ID0gc2hhcGUuZ2V0QWJzb2x1dGVPcGFjaXR5KCk7XG4gICAgICAgICAgICBpZihhYnNPcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdnbG9iYWxBbHBoYScsIGFic09wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfYXBwbHlMaW5lSm9pbjogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lSm9pbiA9IHNoYXBlLmdldExpbmVKb2luKCk7XG4gICAgICAgICAgICBpZihsaW5lSm9pbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbGluZUpvaW4nLCBsaW5lSm9pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldEF0dHI6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dFthdHRyXSA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBjb250ZXh0IHBhc3MgdGhyb3VnaCBtZXRob2RzXG4gICAgICAgIGFyYzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYXJjKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgICAgICB9LFxuICAgICAgICBiZWdpblBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhclJlY3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsaXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbGlwKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBpZihhLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZUltYWdlRGF0YShhWzBdLCBhWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoYS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVJbWFnZURhdGEoYVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUxpbmVhckdyYWRpZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVBhdHRlcm46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVQYXR0ZXJuKGFbMF0sIGFbMV0pO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVSYWRpYWxHcmFkaWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgICAgICB9LFxuICAgICAgICBkcmF3SW1hZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgX2NvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgICAgICAgICBpZihhLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LmRyYXdJbWFnZShhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoYS5sZW5ndGggPT09IDUpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5kcmF3SW1hZ2UoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGEubGVuZ3RoID09PSA5KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc1BvaW50SW5QYXRoOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5pc1BvaW50SW5QYXRoKHgsIHkpO1xuICAgICAgICB9LFxuICAgICAgICBmaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbCgpO1xuICAgICAgICB9LFxuICAgICAgICBmaWxsUmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlUmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zdHJva2VSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBmaWxsVGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFRleHQoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lYXN1cmVUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0SW1hZ2VEYXRhKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lVG86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyhhWzBdLCBhWzFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW92ZVRvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oYVswXSwgYVsxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnJlY3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1dEltYWdlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQucHV0SW1hZ2VEYXRhKGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgICAgICB9LFxuICAgICAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgICAgICB9LFxuICAgICAgICByZXN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICByb3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnJvdGF0ZShhWzBdKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNjYWxlKGFbMF0sIGFbMV0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRMaW5lRGFzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICBfY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICAgICAgICAgIC8vIHdvcmtzIGZvciBDaHJvbWUgYW5kIElFMTFcbiAgICAgICAgICAgIGlmKHRoaXMuX2NvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5zZXRMaW5lRGFzaChhWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZlcmlmaWVkIHRoYXQgdGhpcyB3b3JrcyBpbiBmaXJlZm94XG4gICAgICAgICAgICBlbHNlIGlmKCdtb3pEYXNoJyBpbiBfY29udGV4dCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm1vekRhc2ggPSBhWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9lcyBub3QgY3VycmVudGx5IHdvcmsgZm9yIFNhZmFyaVxuICAgICAgICAgICAgZWxzZSBpZignd2Via2l0TGluZURhc2gnIGluIF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQud2Via2l0TGluZURhc2ggPSBhWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBubyBzdXBwb3J0IGZvciBJRTkgYW5kIElFMTBcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGluZURhc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0TGluZURhc2goKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zZXRUcmFuc2Zvcm0oYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9LFxuICAgICAgICBzdHJva2VUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zdHJva2VUZXh0KGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnRyYW5zZm9ybShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC50cmFuc2xhdGUoYVswXSwgYVsxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9lbmFibGVUcmFjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbGVuID0gQ09OVEVYVF9NRVRIT0RTLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBfc2ltcGxpZnlBcnJheSA9IEtvbnZhLlV0aWwuX3NpbXBsaWZ5QXJyYXksXG4gICAgICAgICAgICAgICAgb3JpZ1NldHRlciA9IHRoaXMuc2V0QXR0cixcbiAgICAgICAgICAgICAgICBuLCBhcmdzO1xuXG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IGNyZWF0aW5nIHNjb3BlIGZ1bmN0aW9uIGF0IGVhY2ggbG9vcFxuICAgICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnTWV0aG9kID0gdGhhdFttZXRob2ROYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldDtcblxuICAgICAgICAgICAgICAgICAgICB0aGF0W21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gX3NpbXBsaWZ5QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBvcmlnTWV0aG9kLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RyYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgZnVuYyhDT05URVhUX01FVEhPRFNbbl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhdHRyc1xuICAgICAgICAgICAgdGhhdC5zZXRBdHRyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb3JpZ1NldHRlci5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoYXQuX3RyYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsOiBhcmd1bWVudHNbMV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ09OVEVYVF9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS29udmEuQ29udGV4dC5wcm90b3R5cGUsIHByb3AsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0W3Byb3BdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgS29udmEuU2NlbmVDb250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgIEtvbnZhLkNvbnRleHQuY2FsbCh0aGlzLCBjYW52YXMpO1xuICAgIH07XG5cbiAgICBLb252YS5TY2VuZUNvbnRleHQucHJvdG90eXBlID0ge1xuICAgICAgICBfZmlsbENvbG9yOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGZpbGwgPSBzaGFwZS5maWxsKCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgZmlsbCk7XG4gICAgICAgICAgICBzaGFwZS5fZmlsbEZ1bmModGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9maWxsUGF0dGVybjogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBmaWxsUGF0dGVyblggPSBzaGFwZS5nZXRGaWxsUGF0dGVyblgoKSxcbiAgICAgICAgICAgICAgICBmaWxsUGF0dGVyblkgPSBzaGFwZS5nZXRGaWxsUGF0dGVyblkoKSxcbiAgICAgICAgICAgICAgICBmaWxsUGF0dGVyblNjYWxlID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5TY2FsZSgpLFxuICAgICAgICAgICAgICAgIGZpbGxQYXR0ZXJuUm90YXRpb24gPSBLb252YS5nZXRBbmdsZShzaGFwZS5nZXRGaWxsUGF0dGVyblJvdGF0aW9uKCkpLFxuICAgICAgICAgICAgICAgIGZpbGxQYXR0ZXJuT2Zmc2V0ID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5PZmZzZXQoKTtcblxuICAgICAgICAgICAgaWYoZmlsbFBhdHRlcm5YIHx8IGZpbGxQYXR0ZXJuWSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKGZpbGxQYXR0ZXJuWCB8fCAwLCBmaWxsUGF0dGVyblkgfHwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihmaWxsUGF0dGVyblJvdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGUoZmlsbFBhdHRlcm5Sb3RhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihmaWxsUGF0dGVyblNjYWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZShmaWxsUGF0dGVyblNjYWxlLngsIGZpbGxQYXR0ZXJuU2NhbGUueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihmaWxsUGF0dGVybk9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKC0xICogZmlsbFBhdHRlcm5PZmZzZXQueCwgLTEgKiBmaWxsUGF0dGVybk9mZnNldC55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdmaWxsU3R5bGUnLCB0aGlzLmNyZWF0ZVBhdHRlcm4oc2hhcGUuZ2V0RmlsbFBhdHRlcm5JbWFnZSgpLCBzaGFwZS5nZXRGaWxsUGF0dGVyblJlcGVhdCgpIHx8ICdyZXBlYXQnKSk7XG4gICAgICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2ZpbGxMaW5lYXJHcmFkaWVudDogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHNoYXBlLmdldEZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQoKSxcbiAgICAgICAgICAgICAgICBlbmQgPSBzaGFwZS5nZXRGaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludCgpLFxuICAgICAgICAgICAgICAgIGNvbG9yU3RvcHMgPSBzaGFwZS5nZXRGaWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCksXG4gICAgICAgICAgICAgICAgZ3JkID0gdGhpcy5jcmVhdGVMaW5lYXJHcmFkaWVudChzdGFydC54LCBzdGFydC55LCBlbmQueCwgZW5kLnkpO1xuXG4gICAgICAgICAgICBpZiAoY29sb3JTdG9wcykge1xuICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGNvbG9yIHN0b3BzXG4gICAgICAgICAgICAgICAgZm9yKHZhciBuID0gMDsgbiA8IGNvbG9yU3RvcHMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcChjb2xvclN0b3BzW25dLCBjb2xvclN0b3BzW24gKyAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgZ3JkKTtcbiAgICAgICAgICAgICAgICBzaGFwZS5fZmlsbEZ1bmModGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9maWxsUmFkaWFsR3JhZGllbnQ6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50KCksXG4gICAgICAgICAgICAgICAgZW5kID0gc2hhcGUuZ2V0RmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQoKSxcbiAgICAgICAgICAgICAgICBzdGFydFJhZGl1cyA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzKCksXG4gICAgICAgICAgICAgICAgZW5kUmFkaXVzID0gc2hhcGUuZ2V0RmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzKCksXG4gICAgICAgICAgICAgICAgY29sb3JTdG9wcyA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKSxcbiAgICAgICAgICAgICAgICBncmQgPSB0aGlzLmNyZWF0ZVJhZGlhbEdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIHN0YXJ0UmFkaXVzLCBlbmQueCwgZW5kLnksIGVuZFJhZGl1cyk7XG5cbiAgICAgICAgICAgIC8vIGJ1aWxkIGNvbG9yIHN0b3BzXG4gICAgICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgY29sb3JTdG9wcy5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wc1tuXSwgY29sb3JTdG9wc1tuICsgMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdmaWxsU3R5bGUnLCBncmQpO1xuICAgICAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9maWxsOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdmFyIGhhc0NvbG9yID0gc2hhcGUuZmlsbCgpLFxuICAgICAgICAgICAgICAgIGhhc1BhdHRlcm4gPSBzaGFwZS5nZXRGaWxsUGF0dGVybkltYWdlKCksXG4gICAgICAgICAgICAgICAgaGFzTGluZWFyR3JhZGllbnQgPSBzaGFwZS5nZXRGaWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCksXG4gICAgICAgICAgICAgICAgaGFzUmFkaWFsR3JhZGllbnQgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCksXG4gICAgICAgICAgICAgICAgZmlsbFByaW9yaXR5ID0gc2hhcGUuZ2V0RmlsbFByaW9yaXR5KCk7XG5cbiAgICAgICAgICAgIC8vIHByaW9yaXR5IGZpbGxzXG4gICAgICAgICAgICBpZihoYXNDb2xvciAmJiBmaWxsUHJpb3JpdHkgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsQ29sb3Ioc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihoYXNQYXR0ZXJuICYmIGZpbGxQcmlvcml0eSA9PT0gJ3BhdHRlcm4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbFBhdHRlcm4oc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihoYXNMaW5lYXJHcmFkaWVudCAmJiBmaWxsUHJpb3JpdHkgPT09ICdsaW5lYXItZ3JhZGllbnQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbExpbmVhckdyYWRpZW50KHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoaGFzUmFkaWFsR3JhZGllbnQgJiYgZmlsbFByaW9yaXR5ID09PSAncmFkaWFsLWdyYWRpZW50Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxSYWRpYWxHcmFkaWVudChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub3cganVzdCB0cnkgYW5kIGZpbGwgd2l0aCB3aGF0ZXZlciBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgIGVsc2UgaWYoaGFzQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maWxsQ29sb3Ioc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihoYXNQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbFBhdHRlcm4oc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihoYXNMaW5lYXJHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbGxMaW5lYXJHcmFkaWVudChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGhhc1JhZGlhbEdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlsbFJhZGlhbEdyYWRpZW50KHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3N0cm9rZTogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciBkYXNoID0gc2hhcGUuZGFzaCgpLFxuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBzdHJva2VTY2FsZUVuYWJsZWQgZm9yIFRleHRcbiAgICAgICAgICAgICAgICBzdHJva2VTY2FsZUVuYWJsZWQgPSAoc2hhcGUuZ2V0U3Ryb2tlU2NhbGVFbmFibGVkKCkgfHwgKHNoYXBlIGluc3RhbmNlb2YgS29udmEuVGV4dCkpO1xuXG4gICAgICAgICAgICBpZihzaGFwZS5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgIGlmICghc3Ryb2tlU2NhbGVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUxpbmVDYXAoc2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmKGRhc2ggJiYgc2hhcGUuZGFzaEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldExpbmVEYXNoKGRhc2gpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbGluZVdpZHRoJywgc2hhcGUuc3Ryb2tlV2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzdHJva2VTdHlsZScsIHNoYXBlLnN0cm9rZSgpKTtcblxuICAgICAgICAgICAgICAgIGlmICghc2hhcGUuZ2V0U2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93Q29sb3InLCAncmdiYSgwLDAsMCwwKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaGFwZS5fc3Ryb2tlRnVuYyh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGlmICghc3Ryb2tlU2NhbGVFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2FwcGx5U2hhZG93OiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgICAgICAgdmFyIHV0aWwgPSBLb252YS5VdGlsLFxuICAgICAgICAgICAgICAgIGNvbG9yID0gdXRpbC5nZXQoc2hhcGUuZ2V0U2hhZG93UkdCQSgpLCAnYmxhY2snKSxcbiAgICAgICAgICAgICAgICBibHVyID0gdXRpbC5nZXQoc2hhcGUuZ2V0U2hhZG93Qmx1cigpLCA1KSxcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB1dGlsLmdldChzaGFwZS5nZXRTaGFkb3dPZmZzZXQoKSwge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZ2V0IHRoaXMgaW5mbyBmcm9tIHRyYW5zZm9ybT8/XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBzaGFwZS5nZXRBYnNvbHV0ZVNjYWxlKCksXG4gICAgICAgICAgICAgICAgc2NhbGVYID0gc2NhbGUueCxcbiAgICAgICAgICAgICAgICBzY2FsZVkgPSBzY2FsZS55O1xuXG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3NoYWRvd0NvbG9yJywgY29sb3IpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dCbHVyJywgYmx1cik7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3NoYWRvd09mZnNldFgnLCBvZmZzZXQueCAqIHNjYWxlWCk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3NoYWRvd09mZnNldFknLCBvZmZzZXQueSAqIHNjYWxlWSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlNjZW5lQ29udGV4dCwgS29udmEuQ29udGV4dCk7XG5cbiAgICBLb252YS5IaXRDb250ZXh0ID0gZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgIEtvbnZhLkNvbnRleHQuY2FsbCh0aGlzLCBjYW52YXMpO1xuICAgIH07XG5cbiAgICBLb252YS5IaXRDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2ZpbGw6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignZmlsbFN0eWxlJywgc2hhcGUuY29sb3JLZXkpO1xuICAgICAgICAgICAgc2hhcGUuX2ZpbGxGdW5jSGl0KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zdHJva2U6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICBpZihzaGFwZS5oYXNTdHJva2UoKSAmJiBzaGFwZS5zdHJva2VIaXRFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgc3Ryb2tlU2NhbGVFbmFibGVkIGZvciBUZXh0XG4gICAgICAgICAgICAgICAgdmFyIHN0cm9rZVNjYWxlRW5hYmxlZCA9IChzaGFwZS5nZXRTdHJva2VTY2FsZUVuYWJsZWQoKSB8fCAoc2hhcGUgaW5zdGFuY2VvZiBLb252YS5UZXh0KSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUxpbmVDYXAoc2hhcGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbGluZVdpZHRoJywgc2hhcGUuc3Ryb2tlV2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdzdHJva2VTdHlsZScsIHNoYXBlLmNvbG9yS2V5KTtcbiAgICAgICAgICAgICAgICBzaGFwZS5fc3Ryb2tlRnVuY0hpdCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0cm9rZVNjYWxlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkhpdENvbnRleHQsIEtvbnZhLkNvbnRleHQpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBDT05TVEFOVFNcbiAgICB2YXIgR0VUID0gJ2dldCcsXG4gICAgICAgIFNFVCA9ICdzZXQnO1xuXG4gICAgS29udmEuRmFjdG9yeSA9IHtcbiAgICAgICAgYWRkR2V0dGVyU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmLCB2YWxpZGF0b3IsIGFmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEdldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmKTtcbiAgICAgICAgICAgIHRoaXMuYWRkU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyLCB2YWxpZGF0b3IsIGFmdGVyKTtcbiAgICAgICAgICAgIHRoaXMuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihjb25zdHJ1Y3RvciwgYXR0cik7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEdldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIGRlZikge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IEdFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuYXR0cnNbYXR0cl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmIDogdmFsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBhZnRlcikge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFNFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWxpZGF0b3IuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoYXR0ciwgdmFsKTtcblxuICAgICAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICAgICAgICBhZnRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkQ29tcG9uZW50c0dldHRlclNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIGNvbXBvbmVudHMsIHZhbGlkYXRvciwgYWZ0ZXIpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjYXBpdGFsaXplID0gS29udmEuVXRpbC5fY2FwaXRhbGl6ZSxcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSBHRVQgKyBjYXBpdGFsaXplKGF0dHIpLFxuICAgICAgICAgICAgICAgIHNldHRlciA9IFNFVCArIGNhcGl0YWxpemUoYXR0ciksXG4gICAgICAgICAgICAgICAgbiwgY29tcG9uZW50O1xuXG4gICAgICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtnZXR0ZXJdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHt9O1xuXG4gICAgICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbbl07XG4gICAgICAgICAgICAgICAgICAgIHJldFtjb21wb25lbnRdID0gdGhpcy5nZXRBdHRyKGF0dHIgKyBjYXBpdGFsaXplKGNvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtzZXR0ZXJdID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbCA9IHRoaXMuYXR0cnNbYXR0cl0sXG4gICAgICAgICAgICAgICAgICAgIGtleTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsaWRhdG9yLmNhbGwodGhpcywgdmFsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWwuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0QXR0cihhdHRyICsgY2FwaXRhbGl6ZShrZXkpLCB2YWxba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KGF0dHIsIG9sZFZhbCwgdmFsKTtcblxuICAgICAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICAgICAgICBhZnRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBjYXBpdGFsaXplZEF0dHIgPSBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpLFxuICAgICAgICAgICAgICAgIHNldHRlciA9IFNFVCArIGNhcGl0YWxpemVkQXR0cixcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSBHRVQgKyBjYXBpdGFsaXplZEF0dHI7XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVthdHRyXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIHNldHRpbmdcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3NldHRlcl0oYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tnZXR0ZXJdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBhZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmLCB2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBHRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBhdHRyICsgJyBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbi4gTG9vayBhdCBLb252YSBjaGFuZ2UgbG9nIGZvciBtb3JlIGluZm9ybWF0aW9uLic7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuYXR0cnNbYXR0cl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gZGVmIDogdmFsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYWRkU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyLCB2YWxpZGF0b3IsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBLb252YS5VdGlsLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIpO1xuICAgICAgICB9LFxuICAgICAgICBiYWNrQ29tcGF0OiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgbWV0aG9kcykge1xuICAgICAgICAgICAgS29udmEuVXRpbC5lYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKG9sZE1ldGhvZE5hbWUsIG5ld01ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gY29uc3RydWN0b3IucHJvdG90eXBlW25ld01ldGhvZE5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtvbGRNZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBLb252YS5VdGlsLmVycm9yKG9sZE1ldGhvZE5hbWUgKyAnIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgc29vbi4gVXNlICcgKyBuZXdNZXRob2ROYW1lICsgJyBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhZnRlclNldEZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLlZhbGlkYXRvcnMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBSR0JDb21wb25lbnQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyNTU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFscGhhQ29tcG9uZW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaHJvbWUgZG9lcyBub3QgaG9ub3IgYWxwaGEgdmFsdWVzIG9mIDBcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDAuMDAwMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjAwMDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIENPTlNUQU5UU1xuICAgIHZhciBBQlNPTFVURV9PUEFDSVRZID0gJ2Fic29sdXRlT3BhY2l0eScsXG4gICAgICAgIEFCU09MVVRFX1RSQU5TRk9STSA9ICdhYnNvbHV0ZVRyYW5zZm9ybScsXG4gICAgICAgIEFCU09MVVRFX1NDQUxFID0gJ2Fic29sdXRlU2NhbGUnLFxuICAgICAgICBDSEFOR0UgPSAnQ2hhbmdlJyxcbiAgICAgICAgQ0hJTERSRU4gPSAnY2hpbGRyZW4nLFxuICAgICAgICBET1QgPSAnLicsXG4gICAgICAgIEVNUFRZX1NUUklORyA9ICcnLFxuICAgICAgICBHRVQgPSAnZ2V0JyxcbiAgICAgICAgSUQgPSAnaWQnLFxuICAgICAgICBLT05WQSA9ICdrb252YScsXG4gICAgICAgIExJU1RFTklORyA9ICdsaXN0ZW5pbmcnLFxuICAgICAgICBNT1VTRUVOVEVSID0gJ21vdXNlZW50ZXInLFxuICAgICAgICBNT1VTRUxFQVZFID0gJ21vdXNlbGVhdmUnLFxuICAgICAgICBOQU1FID0gJ25hbWUnLFxuICAgICAgICBTRVQgPSAnc2V0JyxcbiAgICAgICAgU0hBUEUgPSAnU2hhcGUnLFxuICAgICAgICBTUEFDRSA9ICcgJyxcbiAgICAgICAgU1RBR0UgPSAnc3RhZ2UnLFxuICAgICAgICBUUkFOU0ZPUk0gPSAndHJhbnNmb3JtJyxcbiAgICAgICAgVVBQRVJfU1RBR0UgPSAnU3RhZ2UnLFxuICAgICAgICBWSVNJQkxFID0gJ3Zpc2libGUnLFxuICAgICAgICBDTE9ORV9CTEFDS19MSVNUID0gWydpZCddLFxuXG4gICAgICAgIFRSQU5TRk9STV9DSEFOR0VfU1RSID0gW1xuICAgICAgICAgICAgJ3hDaGFuZ2Uua29udmEnLFxuICAgICAgICAgICAgJ3lDaGFuZ2Uua29udmEnLFxuICAgICAgICAgICAgJ3NjYWxlWENoYW5nZS5rb252YScsXG4gICAgICAgICAgICAnc2NhbGVZQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgICAgICdza2V3WENoYW5nZS5rb252YScsXG4gICAgICAgICAgICAnc2tld1lDaGFuZ2Uua29udmEnLFxuICAgICAgICAgICAgJ3JvdGF0aW9uQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgICAgICdvZmZzZXRYQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgICAgICdvZmZzZXRZQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgICAgICd0cmFuc2Zvcm1zRW5hYmxlZENoYW5nZS5rb252YSdcbiAgICAgICAgXS5qb2luKFNQQUNFKSxcblxuICAgICAgICBTQ0FMRV9DSEFOR0VfU1RSID0gW1xuICAgICAgICAgICAgJ3NjYWxlWENoYW5nZS5rb252YScsXG4gICAgICAgICAgICAnc2NhbGVZQ2hhbmdlLmtvbnZhJ1xuICAgICAgICBdLmpvaW4oU1BBQ0UpO1xuXG4gICAgLyoqXG4gICAgICogTm9kZSBjb25zdHJ1Y3Rvci4gTm9kZXMgYXJlIGVudGl0aWVzIHRoYXQgY2FuIGJlIHRyYW5zZm9ybWVkLCBsYXllcmVkLFxuICAgICAqIGFuZCBoYXZlIGJvdW5kIGV2ZW50cy4gVGhlIHN0YWdlLCBsYXllcnMsIGdyb3VwcywgYW5kIHNoYXBlcyBhbGwgZXh0ZW5kIE5vZGUuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICovXG4gICAgS29udmEuTm9kZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5Ob2RlLCB7XG4gICAgICAgIF9pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2lkID0gS29udmEuaWRDb3VudGVyKys7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cnMoY29uZmlnKTtcblxuICAgICAgICAgICAgLy8gZXZlbnQgYmluZGluZ3MgZm9yIGNhY2hlIGhhbmRsaW5nXG4gICAgICAgICAgICB0aGlzLm9uKFRSQU5TRk9STV9DSEFOR0VfU1RSLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICAgICAgICAgICAgdGhhdC5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5vbihTQ0FMRV9DSEFOR0VfU1RSLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfU0NBTEUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMub24oJ3Zpc2libGVDaGFuZ2Uua29udmEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoVklTSUJMRSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMub24oJ2xpc3RlbmluZ0NoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShMSVNURU5JTkcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdvcGFjaXR5Q2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX09QQUNJVFkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9jbGVhckNhY2hlOiBmdW5jdGlvbihhdHRyKXtcbiAgICAgICAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhY2hlW2F0dHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldENhY2hlOiBmdW5jdGlvbihhdHRyLCBwcml2YXRlR2V0dGVyKXtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IHRoaXMuX2NhY2hlW2F0dHJdO1xuXG4gICAgICAgICAgICAvLyBpZiBub3QgY2FjaGVkLCB3ZSBuZWVkIHRvIHNldCBpdCB1c2luZyB0aGUgcHJpdmF0ZSBnZXR0ZXIgbWV0aG9kLlxuICAgICAgICAgICAgaWYgKGNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVthdHRyXSA9IHByaXZhdGVHZXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW2F0dHJdO1xuICAgICAgICB9LFxuICAgICAgICAvKlxuICAgICAgICAgKiB3aGVuIHRoZSBsb2dpYyBmb3IgYSBjYWNoZWQgcmVzdWx0IGRlcGVuZHMgb24gYW5jZXN0b3IgcHJvcGFnYXRpb24sIHVzZSB0aGlzXG4gICAgICAgICAqIG1ldGhvZCB0byBjbGVhciBzZWxmIGFuZCBjaGlsZHJlbiBjYWNoZVxuICAgICAgICAgKi9cbiAgICAgICAgX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZTogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJDYWNoZShhdHRyKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShhdHRyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogY2xlYXIgY2FjaGVkIGNhbnZhc1xuICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAqIG5vZGUuY2xlYXJDYWNoZSgpO1xuICAgICAgICAqL1xuICAgICAgICBjbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZS5jYW52YXM7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqICBjYWNoZSBub2RlIHRvIGltcHJvdmUgZHJhd2luZyBwZXJmb3JtYW5jZSwgYXBwbHkgZmlsdGVycywgb3IgY3JlYXRlIG1vcmUgYWNjdXJhdGVcbiAgICAgICAgKiAgaGl0IHJlZ2lvbnMuIEZvciBhbGwgYmFzaWMgc2hhcGVzIHNpemUgb2YgY2FjaGUgY2FudmFzIHdpbGwgYmUgYXV0b21hdGljYWxseSBkZXRlY3RlZC5cbiAgICAgICAgKiAgSWYgeW91IG5lZWQgdG8gY2FjaGUgeW91ciBjdXN0b20gYEtvbnZhLlNoYXBlYCBpbnN0YW5jZSB5b3UgaGF2ZSB0byBwYXNzIHNoYXBlJ3MgYm91bmRpbmcgYm94XG4gICAgICAgICogIHByb3BlcnRpZXMuIExvb2sgYXQgW2xpbmsgdG8gZGVtbyBwYWdlXShsaW5rIHRvIGRlbW8gcGFnZSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICAgICogQG1ldGhvZFxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXVxuICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0XSAgaW5jcmVhc2UgY2FudmFzIHNpemUgYnkgYG9mZnNldGAgcGl4ZWwgaW4gYWxsIGRpcmVjdGlvbnMuXG4gICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYXdCb3JkZXJdIHdoZW4gc2V0IHRvIHRydWUsIGEgcmVkIGJvcmRlciB3aWxsIGJlIGRyYXduIGFyb3VuZCB0aGUgY2FjaGVkXG4gICAgICAgICogIHJlZ2lvbiBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgKiAvLyBjYWNoZSBhIHNoYXBlIHdpdGggdGhlIHgseSBwb3NpdGlvbiBvZiB0aGUgYm91bmRpbmcgYm94IGF0IHRoZSBjZW50ZXIgYW5kXG4gICAgICAgICogLy8gdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIGJveCBlcXVhbCB0byB0aGUgd2lkdGggYW5kIGhlaWdodCBvZlxuICAgICAgICAqIC8vIHRoZSBzaGFwZSBvYnRhaW5lZCBmcm9tIHNoYXBlLndpZHRoKCkgYW5kIHNoYXBlLmhlaWdodCgpXG4gICAgICAgICogaW1hZ2UuY2FjaGUoKTtcbiAgICAgICAgKlxuICAgICAgICAqIC8vIGNhY2hlIGEgbm9kZSBhbmQgZGVmaW5lIHRoZSBib3VuZGluZyBib3ggcG9zaXRpb24gYW5kIHNpemVcbiAgICAgICAgKiBub2RlLmNhY2hlKHtcbiAgICAgICAgKiAgIHg6IC0zMCxcbiAgICAgICAgKiAgIHk6IC0zMCxcbiAgICAgICAgKiAgIHdpZHRoOiAxMDAsXG4gICAgICAgICogICBoZWlnaHQ6IDIwMFxuICAgICAgICAqIH0pO1xuICAgICAgICAqXG4gICAgICAgICogLy8gY2FjaGUgYSBub2RlIGFuZCBkcmF3IGEgcmVkIGJvcmRlciBhcm91bmQgdGhlIGJvdW5kaW5nIGJveFxuICAgICAgICAqIC8vIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgICAgICAgKiBub2RlLmNhY2hlKHtcbiAgICAgICAgKiAgIHg6IC0zMCxcbiAgICAgICAgKiAgIHk6IC0zMCxcbiAgICAgICAgKiAgIHdpZHRoOiAxMDAsXG4gICAgICAgICogICBoZWlnaHQ6IDIwMCxcbiAgICAgICAgKiAgIG9mZnNldCA6IDEwLFxuICAgICAgICAqICAgZHJhd0JvcmRlcjogdHJ1ZVxuICAgICAgICAqIH0pO1xuICAgICAgICAqL1xuICAgICAgICBjYWNoZTogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgY29uZiA9IGNvbmZpZyB8fCB7fSxcbiAgICAgICAgICAgICAgICByZWN0ID0gdGhpcy5nZXRDbGllbnRSZWN0KHRydWUpLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gY29uZi53aWR0aCB8fCByZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IGNvbmYuaGVpZ2h0IHx8IHJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHggPSBjb25mLnggfHwgcmVjdC54LFxuICAgICAgICAgICAgICAgIHkgPSBjb25mLnkgfHwgcmVjdC55LFxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGNvbmYub2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICAgICAgZHJhd0JvcmRlciA9IGNvbmYuZHJhd0JvcmRlciB8fCBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaWR0aCBvciBoZWlnaHQgb2YgY2FjaGluZyBjb25maWd1cmF0aW9uIGVxdWFscyAwLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aWR0aCArPSBvZmZzZXQgKiAyO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IG9mZnNldCAqIDI7XG5cbiAgICAgICAgICAgIHggLT0gb2Zmc2V0O1xuICAgICAgICAgICAgeSAtPSBvZmZzZXQ7XG5cblxuICAgICAgICAgICAgdmFyIGNhY2hlZFNjZW5lQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY2FjaGVkRmlsdGVyQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY2FjaGVkSGl0Q2FudmFzID0gbmV3IEtvbnZhLkhpdENhbnZhcyh7XG4gICAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogMSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2NlbmVDb250ZXh0ID0gY2FjaGVkU2NlbmVDYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgaGl0Q29udGV4dCA9IGNhY2hlZEhpdENhbnZhcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIGNhY2hlZEhpdENhbnZhcy5pc0NhY2hlID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG5cbiAgICAgICAgICAgIHNjZW5lQ29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBoaXRDb250ZXh0LnNhdmUoKTtcblxuICAgICAgICAgICAgc2NlbmVDb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgICAgICAgICAgaGl0Q29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcblxuICAgICAgICAgICAgdGhpcy5kcmF3U2NlbmUoY2FjaGVkU2NlbmVDYW52YXMsIHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5kcmF3SGl0KGNhY2hlZEhpdENhbnZhcywgdGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHNjZW5lQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBoaXRDb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGRyYXcgYSByZWQgYm9yZGVyIGFyb3VuZCB0aGUgY2FjaGVkIGJveCBmb3JcbiAgICAgICAgICAgIC8vIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICAgICAgaWYgKGRyYXdCb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBzY2VuZUNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIHNjZW5lQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBzY2VuZUNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzY2VuZUNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnNldEF0dHIoJ3N0cm9rZVN0eWxlJywgJ3JlZCcpO1xuICAgICAgICAgICAgICAgIHNjZW5lQ29udGV4dC5zZXRBdHRyKCdsaW5lV2lkdGgnLCA1KTtcbiAgICAgICAgICAgICAgICBzY2VuZUNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgc2NlbmVDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2FudmFzID0ge1xuICAgICAgICAgICAgICAgIHNjZW5lOiBjYWNoZWRTY2VuZUNhbnZhcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGNhY2hlZEZpbHRlckNhbnZhcyxcbiAgICAgICAgICAgICAgICBoaXQ6IGNhY2hlZEhpdENhbnZhcyxcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGNsaWVudCByZWN0YW5nbGUge3gsIHksIHdpZHRoLCBoZWlnaHR9IG9mIG5vZGUuIFRoaXMgcmVjdGFuZ2xlIGFsc28gaW5jbHVkZSBhbGwgc3R5bGluZyAoc3Ryb2tlcywgc2hhZG93cywgZXRjKS5cbiAgICAgICAgICogVGhlIHJlY3RhbmdsZSBwb3NpdGlvbiBpcyByZWxhdGl2ZSB0byBwYXJlbnQgY29udGFpbmVyLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwVHJhbnNmb3JtXSBmbGFnIHNob3VsZCB3ZSBza2lwIHRyYW5zZm9ybWF0aW9uIHRvIHJlY3RhbmdsZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZWN0IHdpdGgge3gsIHksIHdpZHRoLCBoZWlnaHR9IHByb3BlcnRpZXNcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIHJlY3QgPSBuZXcgS29udmEuUmVjdCh7XG4gICAgICAgICAqICAgICAgd2lkdGggOiAxMDAsXG4gICAgICAgICAqICAgICAgaGVpZ2h0IDogMTAwLFxuICAgICAgICAgKiAgICAgIHggOiA1MCxcbiAgICAgICAgICogICAgICB5IDogNTAsXG4gICAgICAgICAqICAgICAgc3Ryb2tlV2lkdGggOiA0LFxuICAgICAgICAgKiAgICAgIHN0cm9rZSA6ICdibGFjaycsXG4gICAgICAgICAqICAgICAgb2Zmc2V0WCA6IDUwLFxuICAgICAgICAgKiAgICAgIHNjYWxlWSA6IDJcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGdldCBjbGllbnQgcmVjdCB3aXRob3V0IHRoaW5rIG9mZiB0cmFuc2Zvcm1hdGlvbnMgKHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGUsIG9mZnNldCwgZXRjKVxuICAgICAgICAgKiByZWN0LmdldENsaWVudFJlY3QodHJ1ZSk7XG4gICAgICAgICAqIC8vIHJldHVybnMge1xuICAgICAgICAgKiAvLyAgICAgeCA6IC0yLCAgIC8vIHR3byBwaXhlbHMgZm9yIHN0cm9rZSAvIDJcbiAgICAgICAgICogLy8gICAgIHkgOiAtMixcbiAgICAgICAgICogLy8gICAgIHdpZHRoIDogMTA0LCAvLyBpbmNyZWFzZWQgYnkgNCBmb3Igc3Ryb2tlXG4gICAgICAgICAqIC8vICAgICBoZWlnaHQgOiAxMDRcbiAgICAgICAgICogLy99XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGdldCBjbGllbnQgcmVjdCB3aXRoIHRyYW5zZm9ybWF0aW9uIGFwcGxpZWRcbiAgICAgICAgICogcmVjdC5nZXRDbGllbnRSZWN0KCk7XG4gICAgICAgICAqIC8vIHJldHVybnMgT2JqZWN0IHt4OiAtMiwgeTogNDYsIHdpZHRoOiAxMDQsIGhlaWdodDogMjA4fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q2xpZW50UmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBhYnN0cmFjdCBtZXRob2RcbiAgICAgICAgICAgIC8vIHJlZGVmaW5lIGluIENvbnRhaW5lciBhbmQgU2hhcGVcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWJzdHJhY3QgXCJnZXRDbGllbnRSZWN0XCIgbWV0aG9kIGNhbGwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3RyYW5zZm9ybWVkUmVjdDogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAgICAgICAgICB7eDogcmVjdC54LCB5OiByZWN0Lnl9LFxuICAgICAgICAgICAgICAgIHt4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0Lnl9LFxuICAgICAgICAgICAgICAgIHt4OiByZWN0LnggKyByZWN0LndpZHRoLCB5OiByZWN0LnkgKyByZWN0LmhlaWdodH0sXG4gICAgICAgICAgICAgICAge3g6IHJlY3QueCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHR9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFk7XG4gICAgICAgICAgICB2YXIgdHJhbnMgPSB0aGlzLmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSB0cmFucy5wb2ludChwb2ludCk7XG4gICAgICAgICAgICAgICAgaWYgKG1pblggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5YID0gbWF4WCA9IHRyYW5zZm9ybWVkLng7XG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSBtYXhZID0gdHJhbnNmb3JtZWQueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHRyYW5zZm9ybWVkLngpO1xuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB0cmFuc2Zvcm1lZC55KTtcbiAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgdHJhbnNmb3JtZWQueCk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHRyYW5zZm9ybWVkLnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IG1pblgsXG4gICAgICAgICAgICAgICAgeTogbWluWSxcbiAgICAgICAgICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgX2RyYXdDYWNoZWRTY2VuZUNhbnZhczogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jYW52YXMueCxcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jYW52YXMueVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIGNhY2hlQ2FudmFzID0gdGhpcy5fZ2V0Q2FjaGVkU2NlbmVDYW52YXMoKTtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IGNhY2hlQ2FudmFzLnBpeGVsUmF0aW87XG5cbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGNhY2hlQ2FudmFzLl9jYW52YXMsIDAsIDAsIGNhY2hlQ2FudmFzLndpZHRoIC8gcmF0aW8sIGNhY2hlQ2FudmFzLmhlaWdodCAvIHJhdGlvKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICBfZHJhd0NhY2hlZEhpdENhbnZhczogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgICAgICAgICBoaXRDYW52YXMgPSBjYWNoZWRDYW52YXMuaGl0O1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jYW52YXMueCxcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5jYW52YXMueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGhpdENhbnZhcy5fY2FudmFzLCAwLCAwKTtcbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0Q2FjaGVkU2NlbmVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnMoKSxcbiAgICAgICAgICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgICAgICAgICAgc2NlbmVDYW52YXMgPSBjYWNoZWRDYW52YXMuc2NlbmUsXG4gICAgICAgICAgICAgICAgZmlsdGVyQ2FudmFzID0gY2FjaGVkQ2FudmFzLmZpbHRlcixcbiAgICAgICAgICAgICAgICBmaWx0ZXJDb250ZXh0ID0gZmlsdGVyQ2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgICAgICBsZW4sIGltYWdlRGF0YSwgbiwgZmlsdGVyO1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVycykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZmlsdGVyVXBUb0RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gc2NlbmVDYW52YXMucGl4ZWxSYXRpbztcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gZmlsdGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJDb250ZXh0LmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgY2FjaGVkIGNhbnZhcyBvbnRvIGZpbHRlciBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJDb250ZXh0LmRyYXdJbWFnZShzY2VuZUNhbnZhcy5fY2FudmFzLCAwLCAwLCBzY2VuZUNhbnZhcy5nZXRXaWR0aCgpIC8gcmF0aW8sIHNjZW5lQ2FudmFzLmdldEhlaWdodCgpIC8gcmF0aW8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhID0gZmlsdGVyQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgZmlsdGVyQ2FudmFzLmdldFdpZHRoKCksIGZpbHRlckNhbnZhcy5nZXRIZWlnaHQoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IGZpbHRlcnMgdG8gZmlsdGVyIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlcnNbbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRmlsdGVyIHNob3VsZCBiZSB0eXBlIG9mIGZ1bmN0aW9uLCBidXQgZ290ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZmlsdGVyKSArICcgaW5zdGVkLiBQbGVhc2UgY2hlY2sgY29ycmVjdCBmaWx0ZXJzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmNhbGwodGhpcywgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwuZXJyb3IoJ1VuYWJsZSB0byBhcHBseSBmaWx0ZXIuICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJDYW52YXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NlbmVDYW52YXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiaW5kIGV2ZW50cyB0byB0aGUgbm9kZS4gS29udmFKUyBzdXBwb3J0cyBtb3VzZW92ZXIsIG1vdXNlbW92ZSxcbiAgICAgICAgICogIG1vdXNlb3V0LCBtb3VzZWVudGVyLCBtb3VzZWxlYXZlLCBtb3VzZWRvd24sIG1vdXNldXAsIHdoZWVsLCBjbGljaywgZGJsY2xpY2ssIHRvdWNoc3RhcnQsIHRvdWNobW92ZSxcbiAgICAgICAgICogIHRvdWNoZW5kLCB0YXAsIGRibHRhcCwgZHJhZ3N0YXJ0LCBkcmFnbW92ZSwgYW5kIGRyYWdlbmQgZXZlbnRzLiBUaGUgS29udmEgU3RhZ2Ugc3VwcG9ydHNcbiAgICAgICAgICogIGNvbnRlbnRNb3VzZW92ZXIsIGNvbnRlbnRNb3VzZW1vdmUsIGNvbnRlbnRNb3VzZW91dCwgY29udGVudE1vdXNlZG93biwgY29udGVudE1vdXNldXAsIGNvbnRlbnRXaGVlbFxuICAgICAgICAgKiAgY29udGVudENsaWNrLCBjb250ZW50RGJsY2xpY2ssIGNvbnRlbnRUb3VjaHN0YXJ0LCBjb250ZW50VG91Y2htb3ZlLCBjb250ZW50VG91Y2hlbmQsIGNvbnRlbnRUYXAsXG4gICAgICAgICAqICBhbmQgY29udGVudERibFRhcC4gIFBhc3MgaW4gYSBzdHJpbmcgb2YgZXZlbnRzIGRlbGltbWl0ZWQgYnkgYSBzcGFjZSB0byBiaW5kIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gICAgICAgICAqICBzdWNoIGFzICdtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUnLiBJbmNsdWRlIGEgbmFtZXNwYWNlIHRvIGJpbmQgYW5cbiAgICAgICAgICogIGV2ZW50IGJ5IG5hbWUgc3VjaCBhcyAnY2xpY2suZm9vYmFyJy5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dFN0ciBlLmcuICdjbGljaycsICdtb3VzZWRvd24gdG91Y2hzdGFydCcsICdtb3VzZWRvd24uZm9vIHRvdWNoc3RhcnQuZm9vJ1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIGlzIHBhc3NlZCBhbiBldmVudCBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIGFkZCBjbGljayBsaXN0ZW5lclxuICAgICAgICAgKiBub2RlLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKCd5b3UgY2xpY2tlZCBtZSEnKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGdldCB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgICAgICogbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhldnQudGFyZ2V0KTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHN0b3AgZXZlbnQgcHJvcGFnYXRpb25cbiAgICAgICAgICogbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICogICBldnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGJpbmQgbXVsdGlwbGUgbGlzdGVuZXJzXG4gICAgICAgICAqIG5vZGUub24oJ2NsaWNrIHRvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZygneW91IGNsaWNrZWQvdG91Y2hlZCBtZSEnKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIG5hbWVzcGFjZSBsaXN0ZW5lclxuICAgICAgICAgKiBub2RlLm9uKCdjbGljay5mb28nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZygneW91IGNsaWNrZWQvdG91Y2hlZCBtZSEnKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGdldCB0aGUgZXZlbnQgdHlwZVxuICAgICAgICAgKiBub2RlLm9uKCdjbGljayB0YXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICogICB2YXIgZXZlbnRUeXBlID0gZXZ0LnR5cGU7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBnZXQgbmF0aXZlIGV2ZW50IG9iamVjdFxuICAgICAgICAgKiBub2RlLm9uKCdjbGljayB0YXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICogICB2YXIgbmF0aXZlRXZlbnQgPSBldnQuZXZ0O1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gZm9yIGNoYW5nZSBldmVudHMsIGdldCB0aGUgb2xkIGFuZCBuZXcgdmFsXG4gICAgICAgICAqIG5vZGUub24oJ3hDaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICogICB2YXIgb2xkVmFsID0gZXZ0Lm9sZFZhbDtcbiAgICAgICAgICogICB2YXIgbmV3VmFsID0gZXZ0Lm5ld1ZhbDtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGdldCBldmVudCB0YXJnZXRzXG4gICAgICAgICAqIC8vIHdpdGggZXZlbnQgZGVsZWdhdGlvbnNcbiAgICAgICAgICogbGF5ZXIub24oJ2NsaWNrJywgJ0dyb3VwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAqICAgdmFyIHNoYXBlID0gZXZ0LnRhcmdldDtcbiAgICAgICAgICogICB2YXIgZ3JvdXAgPSBldnRuLmN1cnJlbnRUYXJnZXI7XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgb246IGZ1bmN0aW9uKGV2dFN0ciwgaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudHMgPSBldnRTdHIuc3BsaXQoU1BBQ0UpLFxuICAgICAgICAgICAgICAgIGxlbiA9IGV2ZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbiwgZXZlbnQsIHBhcnRzLCBiYXNlRXZlbnQsIG5hbWU7XG5cbiAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogbG9vcCB0aHJvdWdoIHR5cGVzIGFuZCBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvXG4gICAgICAgICAgICAgKiBlYWNoIG9uZS4gIGVnLiAnY2xpY2sgbW91c2VvdmVyLm5hbWVzcGFjZSBtb3VzZW91dCdcbiAgICAgICAgICAgICAqIHdpbGwgY3JlYXRlIHRocmVlIGV2ZW50IGJpbmRpbmdzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudHNbbl07XG4gICAgICAgICAgICAgICAgcGFydHMgPSBldmVudC5zcGxpdChET1QpO1xuICAgICAgICAgICAgICAgIGJhc2VFdmVudCA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBwYXJ0c1sxXSB8fCBFTVBUWV9TVFJJTkc7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgZXZlbnRzIGFycmF5IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICAgICBpZighdGhpcy5ldmVudExpc3RlbmVyc1tiYXNlRXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbW92ZSBldmVudCBiaW5kaW5ncyBmcm9tIHRoZSBub2RlLiBQYXNzIGluIGEgc3RyaW5nIG9mXG4gICAgICAgICAqICBldmVudCB0eXBlcyBkZWxpbW1pdGVkIGJ5IGEgc3BhY2UgdG8gcmVtb3ZlIG11bHRpcGxlIGV2ZW50XG4gICAgICAgICAqICBiaW5kaW5ncyBhdCBvbmNlIHN1Y2ggYXMgJ21vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZScuXG4gICAgICAgICAqICBpbmNsdWRlIGEgbmFtZXNwYWNlIHRvIHJlbW92ZSBhbiBldmVudCBiaW5kaW5nIGJ5IG5hbWVcbiAgICAgICAgICogIHN1Y2ggYXMgJ2NsaWNrLmZvb2JhcicuIElmIHlvdSBvbmx5IGdpdmUgYSBuYW1lIGxpa2UgJy5mb29iYXInLFxuICAgICAgICAgKiAgYWxsIGV2ZW50cyBpbiB0aGF0IG5hbWVzcGFjZSB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnRTdHIgZS5nLiAnY2xpY2snLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQnLCAnLmZvb2JhcidcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIHJlbW92ZSBsaXN0ZW5lclxuICAgICAgICAgKiBub2RlLm9mZignY2xpY2snKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gcmVtb3ZlIG11bHRpcGxlIGxpc3RlbmVyc1xuICAgICAgICAgKiBub2RlLm9mZignY2xpY2sgdG91Y2hzdGFydCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyByZW1vdmUgbGlzdGVuZXIgYnkgbmFtZVxuICAgICAgICAgKiBub2RlLm9mZignY2xpY2suZm9vJyk7XG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uKGV2dFN0cikge1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IChldnRTdHIgfHwgJycpLnNwbGl0KFNQQUNFKSxcbiAgICAgICAgICAgICAgICBsZW4gPSBldmVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG4sIHQsIGV2ZW50LCBwYXJ0cywgYmFzZUV2ZW50LCBuYW1lO1xuXG4gICAgICAgICAgICBpZiAoIWV2dFN0cikge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnRzXG4gICAgICAgICAgICAgICAgZm9yKHQgaW4gdGhpcy5ldmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmYodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IGV2ZW50c1tuXTtcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IGV2ZW50LnNwbGl0KERPVCk7XG4gICAgICAgICAgICAgICAgYmFzZUV2ZW50ID0gcGFydHNbMF07XG4gICAgICAgICAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYoYmFzZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2ZmKGJhc2VFdmVudCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih0IGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZih0LCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBzb21lIGV2ZW50IGFsaWFzZXMgZm9yIHRoaXJkIHBhcnR5IGludGVncmF0aW9uIGxpa2UgSGFtbWVySlNcbiAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICB0eXBlOiBldnQudHlwZSxcbiAgICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmZpcmUoZXZ0LnR5cGUsIGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcGFzcyBuYXRpdmUgZXZlbnQgdG8gaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5vbih0eXBlLCBmdW5jdGlvbihldnQpe1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBldnQuZXZ0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGxpa2Ugbm9kZS5vblxuICAgICAgICBfZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50LCBzZWxlY3RvciwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIHN0b3BOb2RlID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMub24oZXZlbnQsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRzID0gZXZ0LnRhcmdldC5maW5kQW5jZXN0b3JzKHNlbGVjdG9yLCB0cnVlLCBzdG9wTm9kZSk7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0ID0gS29udmEuVXRpbC5jbG9uZU9iamVjdChldnQpO1xuICAgICAgICAgICAgICAgICAgICBldnQuY3VycmVudFRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0YXJnZXRzW2ldLCBldnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnQsIGJ1dCBkb24ndCBkZXN0cm95XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICBpZihwYXJlbnQgJiYgcGFyZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXZlcnkgY2FjaGVkIGF0dHIgdGhhdCBpcyBjYWxjdWxhdGVkIHZpYSBub2RlIHRyZWVcbiAgICAgICAgICAgIC8vIHRyYXZlcnNhbCBtdXN0IGJlIGNsZWFyZWQgd2hlbiByZW1vdmluZyBhIG5vZGVcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShTVEFHRSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShWSVNJQkxFKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShMSVNURU5JTkcpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX09QQUNJVFkpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbW92ZSBhbmQgZGVzdHJveSBzZWxmXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUuZGVzdHJveSgpO1xuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBpZHMgYW5kIG5hbWVzIGhhc2hlc1xuICAgICAgICAgICAgS29udmEuX3JlbW92ZUlkKHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICBLb252YS5fcmVtb3ZlTmFtZSh0aGlzLmdldE5hbWUoKSwgdGhpcy5faWQpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgYXR0clxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAgICAgKiBAcmV0dXJucyB7SW50ZWdlcnxTdHJpbmd8T2JqZWN0fEFycmF5fVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgeCA9IG5vZGUuZ2V0QXR0cigneCcpO1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXR0cjogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IEdFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG4gICAgICAgICAgICBpZihLb252YS5VdGlsLl9pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1ttZXRob2RdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZ2V0IGRpcmVjdGx5XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyc1thdHRyXTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogZ2V0IGFuY2VzdG9yc1xuICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgKiBAcmV0dXJucyB7S29udmEuQ29sbGVjdGlvbn1cbiAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAqIHNoYXBlLmdldEFuY2VzdG9ycygpLmVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAqICAgY29uc29sZS5sb2cobm9kZS5nZXRJZCgpKTtcbiAgICAgICAgKiB9KVxuICAgICAgICAqL1xuICAgICAgICBnZXRBbmNlc3RvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCksXG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcblxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYW5jZXN0b3JzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGF0dHJzIG9iamVjdCBsaXRlcmFsXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycyB8fCB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBtdWx0aXBsZSBhdHRycyBhdCBvbmNlIHVzaW5nIGFuIG9iamVjdCBsaXRlcmFsXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgb2JqZWN0IGNvbnRhaW5pbmcga2V5IHZhbHVlIHBhaXJzXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLnNldEF0dHJzKHtcbiAgICAgICAgICogICB4OiA1LFxuICAgICAgICAgKiAgIGZpbGw6ICdyZWQnXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgc2V0QXR0cnM6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIGtleSwgbWV0aG9kO1xuXG4gICAgICAgICAgICBpZighY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3Ioa2V5IGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBTRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGtleSk7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHNldHRlciBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICBpZihLb252YS5VdGlsLl9pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1ttZXRob2RdKGNvbmZpZ1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCBkaXJlY3RseVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKGtleSwgY29uZmlnW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZGV0ZXJtaW5lIGlmIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHMgYnkgdGFraW5nIGludG8gYWNjb3VudCBhbmNlc3RvcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmVudCAgICB8IFNlbGYgICAgICB8IGlzTGlzdGVuaW5nXG4gICAgICAgICAqIGxpc3RlbmluZyB8IGxpc3RlbmluZyB8XG4gICAgICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXG4gICAgICAgICAqIFQgICAgICAgICB8IFQgICAgICAgICB8IFRcbiAgICAgICAgICogVCAgICAgICAgIHwgRiAgICAgICAgIHwgRlxuICAgICAgICAgKiBGICAgICAgICAgfCBUICAgICAgICAgfCBUXG4gICAgICAgICAqIEYgICAgICAgICB8IEYgICAgICAgICB8IEZcbiAgICAgICAgICogLS0tLS0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS1cbiAgICAgICAgICogVCAgICAgICAgIHwgSSAgICAgICAgIHwgVFxuICAgICAgICAgKiBGICAgICAgICAgfCBJICAgICAgICAgfCBGXG4gICAgICAgICAqIEkgICAgICAgICB8IEkgICAgICAgICB8IFRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc0xpc3RlbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoTElTVEVOSU5HLCB0aGlzLl9pc0xpc3RlbmluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc0xpc3RlbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuaW5nID0gdGhpcy5nZXRMaXN0ZW5pbmcoKSxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGEgc2ltcGxpZmljYXRpb24gb2YgdGhlIHRydXRoIHRhYmxlIGFib3ZlLlxuICAgICAgICAgICAgLy8gcGxlYXNlIG1vZGlmeSBjYXJlZnVsbHlcbiAgICAgICAgICAgIGlmIChsaXN0ZW5pbmcgPT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5pc0xpc3RlbmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBub2RlIGlzIHZpc2libGUgYnkgdGFraW5nIGludG8gYWNjb3VudCBhbmNlc3RvcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmVudCAgICB8IFNlbGYgICAgICB8IGlzVmlzaWJsZVxuICAgICAgICAgKiB2aXNpYmxlICAgfCB2aXNpYmxlICAgfFxuICAgICAgICAgKiAtLS0tLS0tLS0tKy0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLVxuICAgICAgICAgKiBUICAgICAgICAgfCBUICAgICAgICAgfCBUXG4gICAgICAgICAqIFQgICAgICAgICB8IEYgICAgICAgICB8IEZcbiAgICAgICAgICogRiAgICAgICAgIHwgVCAgICAgICAgIHwgVFxuICAgICAgICAgKiBGICAgICAgICAgfCBGICAgICAgICAgfCBGXG4gICAgICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXG4gICAgICAgICAqIFQgICAgICAgICB8IEkgICAgICAgICB8IFRcbiAgICAgICAgICogRiAgICAgICAgIHwgSSAgICAgICAgIHwgRlxuICAgICAgICAgKiBJICAgICAgICAgfCBJICAgICAgICAgfCBUXG5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFZJU0lCTEUsIHRoaXMuX2lzVmlzaWJsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9pc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHZpc2libGUgPSB0aGlzLmdldFZpc2libGUoKSxcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGEgc2ltcGxpZmljYXRpb24gb2YgdGhlIHRydXRoIHRhYmxlIGFib3ZlLlxuICAgICAgICAgICAgLy8gcGxlYXNlIG1vZGlmeSBjYXJlZnVsbHlcbiAgICAgICAgICAgIGlmICh2aXNpYmxlID09PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQuaXNWaXNpYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBsaXN0ZW5pbmcgaXMgZW5hYmxlZCBieSB0YWtpbmcgaW50byBhY2NvdW50IGRlc2NlbmRhbnRzLiAgSWYgc2VsZiBvciBhbnkgY2hpbGRyZW5cbiAgICAgICAgICogaGF2ZSBfaXNMaXN0ZW5pbmdFbmFibGVkIHNldCB0byB0cnVlLCB0aGVuIHNlbGYgYWxzbyBoYXMgbGlzdGVuaW5nIGVuYWJsZWQuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdWxkRHJhd0hpdDogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgICAgICAgICByZXR1cm4gKGNhbnZhcyAmJiBjYW52YXMuaXNDYWNoZSkgfHwgKGxheWVyICYmIGxheWVyLmhpdEdyYXBoRW5hYmxlZCgpKVxuICAgICAgICAgICAgICAgICYmIHRoaXMuaXNMaXN0ZW5pbmcoKSAmJiB0aGlzLmlzVmlzaWJsZSgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2hvdyBub2RlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhpZGUgbm9kZS4gIEhpZGRlbiBub2RlcyBhcmUgbm8gbG9uZ2VyIGRldGVjdGFibGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqL1xuICAgICAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB6SW5kZXggcmVsYXRpdmUgdG8gdGhlIG5vZGUncyBzaWJsaW5ncyB3aG8gc2hhcmUgdGhlIHNhbWUgcGFyZW50XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0WkluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4IHx8IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgYWJzb2x1dGUgei1pbmRleCB3aGljaCB0YWtlcyBpbnRvIGFjY291bnQgc2libGluZ1xuICAgICAgICAgKiAgYW5kIGFuY2VzdG9yIGluZGljZXNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBYnNvbHV0ZVpJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSB0aGlzLmdldERlcHRoKCksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIG5vZGVzLCBsZW4sIG4sIGNoaWxkO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRDaGlsZHJlbihjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIG5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5bbl07XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoY2hpbGQubm9kZVR5cGUgIT09IFNIQVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZC5nZXRDaGlsZHJlbigpLnRvQXJyYXkoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihjaGlsZC5faWQgPT09IHRoYXQuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gbGVuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYobm9kZXMubGVuZ3RoID4gMCAmJiBub2Rlc1swXS5nZXREZXB0aCgpIDw9IGRlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZENoaWxkcmVuKG5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGF0Lm5vZGVUeXBlICE9PSBVUFBFUl9TVEFHRSkge1xuICAgICAgICAgICAgICAgIGFkZENoaWxkcmVuKHRoYXQuZ2V0U3RhZ2UoKS5nZXRDaGlsZHJlbigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IG5vZGUgZGVwdGggaW4gbm9kZSB0cmVlLiAgUmV0dXJucyBhbiBpbnRlZ2VyLlxuICAgICAgICAgKiAgZS5nLiBTdGFnZSBkZXB0aCB3aWxsIGFsd2F5cyBiZSAwLiAgTGF5ZXJzIHdpbGwgYWx3YXlzIGJlIDEuICBHcm91cHMgYW5kIFNoYXBlcyB3aWxsIGFsd2F5c1xuICAgICAgICAgKiAgYmUgPj0gMlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldERlcHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IDAsXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cbiAgICAgICAgICAgIHdoaWxlKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICAgICAgdGhpcy5zZXRYKHBvcy54KTtcbiAgICAgICAgICAgIHRoaXMuc2V0WShwb3MueSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmdldFgoKSxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmdldFkoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBhYnNvbHV0ZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBzdGFnZSBjb250YWluZXIgZGl2XG4gICAgICAgICAqIG9yIHJlbGF0aXZlIHRvIHBhc3NlZCBub2RlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFt0b3BdIG9wdGlvbmFsIHBhcmVudCBub2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24odG9wKSB7XG4gICAgICAgICAgICB2YXIgYWJzb2x1dGVNYXRyaXggPSB0aGlzLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCksXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUcmFuc2Zvcm0gPSBuZXcgS29udmEuVHJhbnNmb3JtKCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuICAgICAgICAgICAgLy8gY2xvbmUgdGhlIG1hdHJpeCBhcnJheVxuICAgICAgICAgICAgYWJzb2x1dGVUcmFuc2Zvcm0ubSA9IGFic29sdXRlTWF0cml4LnNsaWNlKCk7XG4gICAgICAgICAgICBhYnNvbHV0ZVRyYW5zZm9ybS50cmFuc2xhdGUob2Zmc2V0LngsIG9mZnNldC55KTtcblxuICAgICAgICAgICAgcmV0dXJuIGFic29sdXRlVHJhbnNmb3JtLmdldFRyYW5zbGF0aW9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgYWJzb2x1dGUgcG9zaXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ1RyYW5zID0gdGhpcy5fY2xlYXJUcmFuc2Zvcm0oKSxcbiAgICAgICAgICAgICAgICBpdDtcblxuICAgICAgICAgICAgLy8gZG9uJ3QgY2xlYXIgdHJhbnNsYXRpb25cbiAgICAgICAgICAgIHRoaXMuYXR0cnMueCA9IG9yaWdUcmFucy54O1xuICAgICAgICAgICAgdGhpcy5hdHRycy55ID0gb3JpZ1RyYW5zLnk7XG4gICAgICAgICAgICBkZWxldGUgb3JpZ1RyYW5zLng7XG4gICAgICAgICAgICBkZWxldGUgb3JpZ1RyYW5zLnk7XG5cbiAgICAgICAgICAgIC8vIHVucmF2ZWwgdHJhbnNmb3JtXG4gICAgICAgICAgICBpdCA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgaXQuaW52ZXJ0KCk7XG4gICAgICAgICAgICBpdC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcbiAgICAgICAgICAgIHBvcyA9IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmF0dHJzLnggKyBpdC5nZXRUcmFuc2xhdGlvbigpLngsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5hdHRycy55ICsgaXQuZ2V0VHJhbnNsYXRpb24oKS55XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHt4OiBwb3MueCwgeTogcG9zLnl9KTtcbiAgICAgICAgICAgIHRoaXMuX3NldFRyYW5zZm9ybShvcmlnVHJhbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX3NldFRyYW5zZm9ybTogZnVuY3Rpb24odHJhbnMpIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgICAgIGZvcihrZXkgaW4gdHJhbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzW2tleV0gPSB0cmFuc1trZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2NsZWFyVHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0cmFucyA9IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmdldFgoKSxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmdldFkoKSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgICAgICAgICAgIHNjYWxlWDogdGhpcy5nZXRTY2FsZVgoKSxcbiAgICAgICAgICAgICAgICBzY2FsZVk6IHRoaXMuZ2V0U2NhbGVZKCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0WDogdGhpcy5nZXRPZmZzZXRYKCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0WTogdGhpcy5nZXRPZmZzZXRZKCksXG4gICAgICAgICAgICAgICAgc2tld1g6IHRoaXMuZ2V0U2tld1goKSxcbiAgICAgICAgICAgICAgICBza2V3WTogdGhpcy5nZXRTa2V3WSgpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmF0dHJzLnggPSAwO1xuICAgICAgICAgICAgdGhpcy5hdHRycy55ID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMucm90YXRpb24gPSAwO1xuICAgICAgICAgICAgdGhpcy5hdHRycy5zY2FsZVggPSAxO1xuICAgICAgICAgICAgdGhpcy5hdHRycy5zY2FsZVkgPSAxO1xuICAgICAgICAgICAgdGhpcy5hdHRycy5vZmZzZXRYID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMub2Zmc2V0WSA9IDA7XG4gICAgICAgICAgICB0aGlzLmF0dHJzLnNrZXdYID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMuc2tld1kgPSAwO1xuXG4gICAgICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNKTtcblxuICAgICAgICAgICAgLy8gcmV0dXJuIG9yaWdpbmFsIHRyYW5zZm9ybVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZSBub2RlIGJ5IGFuIGFtb3VudCByZWxhdGl2ZSB0byBpdHMgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UueFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbmdlLnlcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIG1vdmUgbm9kZSBpbiB4IGRpcmVjdGlvbiBieSAxcHggYW5kIHkgZGlyZWN0aW9uIGJ5IDJweFxuICAgICAgICAgKiBub2RlLm1vdmUoe1xuICAgICAgICAgKiAgIHg6IDEsXG4gICAgICAgICAqICAgeTogMilcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlOiBmdW5jdGlvbihjaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VYID0gY2hhbmdlLngsXG4gICAgICAgICAgICAgICAgY2hhbmdlWSA9IGNoYW5nZS55LFxuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldFgoKSxcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRZKCk7XG5cbiAgICAgICAgICAgIGlmKGNoYW5nZVggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHggKz0gY2hhbmdlWDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoY2hhbmdlWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgeSArPSBjaGFuZ2VZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHt4OiB4LCB5OiB5fSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX2VhY2hBbmNlc3RvclJldmVyc2U6IGZ1bmN0aW9uKGZ1bmMsIHRvcCkge1xuICAgICAgICAgICAgdmFyIGZhbWlseSA9IFtdLFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCksXG4gICAgICAgICAgICAgICAgbGVuLCBuO1xuXG4gICAgICAgICAgICAvLyBpZiB0b3Agbm9kZSBpcyBkZWZpbmVkLCBhbmQgdGhpcyBub2RlIGlzIHRvcCBub2RlLFxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIGJ1aWxkIGEgZmFtaWx5IHRyZWUuICBqdXN0IGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGZ1bmMgd2l0aCB0aGlzIGJlY2F1c2UgaXQgd2lsbCBiZSB0aGUgb25seSBub2RlXG4gICAgICAgICAgICBpZiAodG9wICYmIHRvcC5faWQgPT09IHRoaXMuX2lkKSB7XG4gICAgICAgICAgICAgICAgZnVuYyh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmFtaWx5LnVuc2hpZnQodGhpcyk7XG5cbiAgICAgICAgICAgIHdoaWxlKHBhcmVudCAmJiAoIXRvcCB8fCBwYXJlbnQuX2lkICE9PSB0b3AuX2lkKSkge1xuICAgICAgICAgICAgICAgIGZhbWlseS51bnNoaWZ0KHBhcmVudCk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGVuID0gZmFtaWx5Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgZnVuYyhmYW1pbHlbbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcm90YXRlIG5vZGUgYnkgYW4gYW1vdW50IGluIGRlZ3JlZXMgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgcm90YXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHRoZXRhXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlOiBmdW5jdGlvbih0aGV0YSkge1xuICAgICAgICAgICAgdGhpcy5zZXRSb3RhdGlvbih0aGlzLmdldFJvdGF0aW9uKCkgKyB0aGV0YSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmUgbm9kZSB0byB0aGUgdG9wIG9mIGl0cyBzaWJsaW5nc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIG1vdmVUb1RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVUb1RvcCBmdW5jdGlvbiBpcyBpZ25vcmVkLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZSBub2RlIHVwXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBmbGFnIGlzIG1vdmVkIG9yIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gbW92ZVVwIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLnBhcmVudC5nZXRDaGlsZHJlbigpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmKGluZGV4IDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4ICsgMSwgMCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZSBub2RlIGRvd25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVEb3duIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIGlmKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4IC0gMSwgMCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogbW92ZSBub2RlIHRvIHRoZSBib3R0b20gb2YgaXRzIHNpYmxpbmdzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZVRvQm90dG9tOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gbW92ZVRvQm90dG9tIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIGlmKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4udW5zaGlmdCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5fc2V0Q2hpbGRyZW5JbmRpY2VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgekluZGV4IHJlbGF0aXZlIHRvIHNpYmxpbmdzXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gekluZGV4XG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0WkluZGV4OiBmdW5jdGlvbih6SW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gekluZGV4IHBhcmFtZXRlciBpcyBpZ25vcmVkLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHpJbmRleCwgMCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5fc2V0Q2hpbGRyZW5JbmRpY2VzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBhYnNvbHV0ZSBvcGFjaXR5XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBYnNvbHV0ZU9wYWNpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEFCU09MVVRFX09QQUNJVFksIHRoaXMuX2dldEFic29sdXRlT3BhY2l0eSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRBYnNvbHV0ZU9wYWNpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFic09wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICAgICAgICAgIGlmKHRoaXMuZ2V0UGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICBhYnNPcGFjaXR5ICo9IHRoaXMuZ2V0UGFyZW50KCkuZ2V0QWJzb2x1dGVPcGFjaXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWJzT3BhY2l0eTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmUgbm9kZSB0byBhbm90aGVyIGNvbnRhaW5lclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0NvbnRhaW5lcn0gbmV3Q29udGFpbmVyXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBtb3ZlIG5vZGUgZnJvbSBjdXJyZW50IGxheWVyIGludG8gbGF5ZXIyXG4gICAgICAgICAqIG5vZGUubW92ZVRvKGxheWVyMik7XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uKG5ld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZyBpZiBuZXcgY29udGFpbmVyIGlzIGFscmVhZHkgcGFyZW50XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRQYXJlbnQoKSAhPT0gbmV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBuZXdDb250YWluZXIuYWRkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb252ZXJ0IE5vZGUgaW50byBhbiBvYmplY3QgZm9yIHNlcmlhbGl6YXRpb24uICBSZXR1cm5zIGFuIG9iamVjdC5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB7fSxcbiAgICAgICAgICAgICAgICBhdHRycyA9IHRoaXMuZ2V0QXR0cnMoKSxcbiAgICAgICAgICAgICAgICBrZXksIHZhbCwgZ2V0dGVyLCBkZWZhdWx0VmFsdWU7XG5cbiAgICAgICAgICAgIG9iai5hdHRycyA9IHt9O1xuXG4gICAgICAgICAgICBmb3Ioa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gYXR0cnNba2V5XTtcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSB0aGlzW2tleV07XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGF0dHIgdmFsdWUgc28gdGhhdCB3ZSBjYW4gZXh0cmFjdCB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBnZXR0ZXJcbiAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnNba2V5XTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBhdHRyIHZhbHVlXG4gICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmF0dHJzW2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzc05hbWUoKTtcbiAgICAgICAgICAgIHJldHVybiBLb252YS5VdGlsLl9wcmVwYXJlVG9TdHJpbmdpZnkob2JqKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbnZlcnQgTm9kZSBpbnRvIGEgSlNPTiBzdHJpbmcuICBSZXR1cm5zIGEgSlNPTiBzdHJpbmcuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9fVxuICAgICAgICAgKi9cbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvT2JqZWN0KCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHBhcmVudCBjb250YWluZXJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGFsbCBhbmNlc3Ryb3MgKHBhcmVudCB0aGVuIHBhcmVudCBvZiB0aGUgcGFyZW50LCBldGMpIG9mIHRoZSBub2RlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdIHNlbGVjdG9yIGZvciBzZWFyY2hcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5jbHVkZVNlbGZdIHNob3cgd2UgdGhpbmsgdGhhdCBub2RlIGlzIGFuY2VzdHJvIGl0c2VsZj9cbiAgICAgICAgICogQHBhcmFtIHtLb252YS5Ob2RlfSBbc3RvcE5vZGVdIG9wdGlvbmFsIG5vZGUgd2hlcmUgd2UgbmVlZCB0byBzdG9wIHNlYXJjaGluZyAob25lIG9mIGFuY2VzdG9ycylcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBbYW5jZXN0b3JzXVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBnZXQgb25lIG9mIHRoZSBwYXJlbnQgZ3JvdXBcbiAgICAgICAgICogdmFyIHBhcmVudEdyb3VwcyA9IG5vZGUuZmluZEFuY2VzdG9ycygnR3JvdXAnKTtcbiAgICAgICAgICovXG4gICAgICAgIGZpbmRBbmNlc3RvcnM6IGZ1bmN0aW9uKHNlbGVjdG9yLCBpbmNsdWRlU2VsZiwgc3RvcE5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGluY2x1ZGVTZWxmICYmIHRoaXMuX2lzTWF0Y2goc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2VzdG9yID09PSBzdG9wTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYW5jZXN0b3IuX2lzTWF0Y2goc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGFuY2VzdG9yIChwYXJlbnQgb3IgcGFyZW50IG9mIHRoZSBwYXJlbnQsIGV0Yykgb2YgdGhlIG5vZGUgdGhhdCBtYXRjaCBwYXNzZWQgc2VsZWN0b3JcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3Rvcl0gc2VsZWN0b3IgZm9yIHNlYXJjaFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbmNsdWRlU2VsZl0gc2hvdyB3ZSB0aGluayB0aGF0IG5vZGUgaXMgYW5jZXN0cm8gaXRzZWxmP1xuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLk5vZGV9IFtzdG9wTm9kZV0gb3B0aW9uYWwgbm9kZSB3aGVyZSB3ZSBuZWVkIHRvIHN0b3Agc2VhcmNoaW5nIChvbmUgb2YgYW5jZXN0b3JzKVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX0gYW5jZXN0b3JcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gZ2V0IG9uZSBvZiB0aGUgcGFyZW50IGdyb3VwXG4gICAgICAgICAqIHZhciBncm91cCA9IG5vZGUuZmluZEFuY2VzdG9ycygnLm15Z3JvdXAnKTtcbiAgICAgICAgICovXG4gICAgICAgIGZpbmRBbmNlc3RvcjogZnVuY3Rpb24oc2VsZWN0b3IsIGluY2x1ZGVTZWxmLCBzdG9wTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZEFuY2VzdG9ycyhzZWxlY3RvciwgaW5jbHVkZVNlbGYsIHN0b3BOb2RlKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaXMgY3VycmVudCBub2RlIG1hdGNoIHBhc3NlZCBzZWxlY3Rvcj9cbiAgICAgICAgX2lzTWF0Y2g6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yQXJyID0gc2VsZWN0b3IucmVwbGFjZSgvIC9nLCAnJykuc3BsaXQoJywnKSxcbiAgICAgICAgICAgICAgICBsZW4gPSBzZWxlY3RvckFyci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbiwgc2VsO1xuXG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBzZWwgPSBzZWxlY3RvckFycltuXTtcbiAgICAgICAgICAgICAgICBpZiAoIUtvbnZhLlV0aWwuaXNWYWxpZFNlbGVjdG9yKHNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdTZWxlY3RvciBcIicgKyBzZWwgKyAnXCIgaXMgaW52YWxpZC4gQWxsb3dlZCBzZWxlY3RvcnMgZXhhbXBsZXMgYXJlIFwiI2Zvb1wiLCBcIi5iYXJcIiBvciBcIkdyb3VwXCIuJyk7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignSWYgeW91IGhhdmUgYSBjdXN0b20gc2hhcGUgd2l0aCBzdWNoIGNsYXNzTmFtZSwgcGxlYXNlIGNoYW5nZSBpdCB0byBzdGFydCB3aXRoIHVwcGVyIGxldHRlciBsaWtlIFwiVHJpYW5nbGVcIi4nKTtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdLb252YSBpcyBhd2Vzb21lLCByaWdodD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBpZihzZWwuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaWQoKSA9PT0gc2VsLnNsaWNlKDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBuYW1lIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzZWwuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzTmFtZShzZWwuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fZ2V0KHNlbCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBsYXllciBhbmNlc3RvclxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTGF5ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuZ2V0TGF5ZXIoKSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgc3RhZ2UgYW5jZXN0b3JcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLlN0YWdlfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFNUQUdFLCB0aGlzLl9nZXRTdGFnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRTdGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIGlmKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmaXJlIGV2ZW50XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdHlwZS4gIGNhbiBiZSBhIHJlZ3VsYXIgZXZlbnQsIGxpa2UgY2xpY2ssIG1vdXNlb3Zlciwgb3IgbW91c2VvdXQsIG9yIGl0IGNhbiBiZSBhIGN1c3RvbSBldmVudCwgbGlrZSBteUN1c3RvbUV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IFtldnRdIGV2ZW50IG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVdIHNldHRpbmcgdGhlIHZhbHVlIHRvIGZhbHNlLCBvciBsZWF2aW5nIGl0IHVuZGVmaW5lZCwgd2lsbCByZXN1bHQgaW4gdGhlIGV2ZW50XG4gICAgICAgICAqICBub3QgYnViYmxpbmcuICBTZXR0aW5nIHRoZSB2YWx1ZSB0byB0cnVlIHdpbGwgcmVzdWx0IGluIHRoZSBldmVudCBidWJibGluZy5cbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIG1hbnVhbGx5IGZpcmUgY2xpY2sgZXZlbnRcbiAgICAgICAgICogbm9kZS5maXJlKCdjbGljaycpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBmaXJlIGN1c3RvbSBldmVudFxuICAgICAgICAgKiBub2RlLmZpcmUoJ2ZvbycpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBmaXJlIGN1c3RvbSBldmVudCB3aXRoIGN1c3RvbSBldmVudCBvYmplY3RcbiAgICAgICAgICogbm9kZS5maXJlKCdmb28nLCB7XG4gICAgICAgICAqICAgYmFyOiAxMFxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gZmlyZSBjbGljayBldmVudCB0aGF0IGJ1YmJsZXNcbiAgICAgICAgICogbm9kZS5maXJlKCdjbGljaycsIG51bGwsIHRydWUpO1xuICAgICAgICAgKi9cbiAgICAgICAgZmlyZTogZnVuY3Rpb24oZXZlbnRUeXBlLCBldnQsIGJ1YmJsZSkge1xuICAgICAgICAgICAgZXZ0ID0gZXZ0IHx8IHt9O1xuICAgICAgICAgICAgZXZ0LnRhcmdldCA9IGV2dC50YXJnZXQgfHwgdGhpcztcbiAgICAgICAgICAgIC8vIGJ1YmJsZVxuICAgICAgICAgICAgaWYgKGJ1YmJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVBbmRCdWJibGUoZXZlbnRUeXBlLCBldnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gYnViYmxlXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKGV2ZW50VHlwZSwgZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGFic29sdXRlIHRyYW5zZm9ybSBvZiB0aGUgbm9kZSB3aGljaCB0YWtlcyBpbnRvXG4gICAgICAgICAqICBhY2NvdW50IGl0cyBhbmNlc3RvciB0cmFuc2Zvcm1zXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBYnNvbHV0ZVRyYW5zZm9ybTogZnVuY3Rpb24odG9wKSB7XG4gICAgICAgICAgICAvLyBpZiB1c2luZyBhbiBhcmd1bWVudCwgd2UgY2FuJ3QgY2FjaGUgdGhlIHJlc3VsdC5cbiAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIG5vIGFyZ3VtZW50LCB3ZSBjYW4gY2FjaGUgdGhlIHJlc3VsdFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSwgdGhpcy5fZ2V0QWJzb2x1dGVUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZ2V0QWJzb2x1dGVUcmFuc2Zvcm06IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgICAgICAgdmFyIGF0ID0gbmV3IEtvbnZhLlRyYW5zZm9ybSgpLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybXNFbmFibGVkLCB0cmFucztcblxuICAgICAgICAgICAgLy8gc3RhcnQgd2l0aCBzdGFnZSBhbmQgdHJhdmVyc2UgZG93bndhcmRzIHRvIHNlbGZcbiAgICAgICAgICAgIHRoaXMuX2VhY2hBbmNlc3RvclJldmVyc2UoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybXNFbmFibGVkID0gbm9kZS50cmFuc2Zvcm1zRW5hYmxlZCgpO1xuICAgICAgICAgICAgICAgIHRyYW5zID0gbm9kZS5nZXRUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1zRW5hYmxlZCA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXQubXVsdGlwbHkodHJhbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFuc2Zvcm1zRW5hYmxlZCA9PT0gJ3Bvc2l0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBhdC50cmFuc2xhdGUobm9kZS54KCksIG5vZGUueSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0b3ApO1xuICAgICAgICAgICAgcmV0dXJuIGF0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGFic29sdXRlIHNjYWxlIG9mIHRoZSBub2RlIHdoaWNoIHRha2VzIGludG9cbiAgICAgICAgICogIGFjY291bnQgaXRzIGFuY2VzdG9yIHNjYWxlc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWJzb2x1dGVTY2FsZTogZnVuY3Rpb24odG9wKSB7XG4gICAgICAgICAgICAvLyBpZiB1c2luZyBhbiBhcmd1bWVudCwgd2UgY2FuJ3QgY2FjaGUgdGhlIHJlc3VsdC5cbiAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIG5vIGFyZ3VtZW50LCB3ZSBjYW4gY2FjaGUgdGhlIHJlc3VsdFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEFCU09MVVRFX1NDQUxFLCB0aGlzLl9nZXRBYnNvbHV0ZVNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2dldEFic29sdXRlU2NhbGU6IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgICAgICAgdmFyIHNjYWxlWCA9IDEsIHNjYWxlWSA9IDE7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHdpdGggc3RhZ2UgYW5kIHRyYXZlcnNlIGRvd253YXJkcyB0byBzZWxmXG4gICAgICAgICAgICB0aGlzLl9lYWNoQW5jZXN0b3JSZXZlcnNlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBzY2FsZVggKj0gbm9kZS5zY2FsZVgoKTtcbiAgICAgICAgICAgICAgICBzY2FsZVkgKj0gbm9kZS5zY2FsZVkoKTtcbiAgICAgICAgICAgIH0sIHRvcCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHNjYWxlWCxcbiAgICAgICAgICAgICAgICB5OiBzY2FsZVlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdHJhbnNmb3JtIG9mIHRoZSBub2RlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFRSQU5TRk9STSwgdGhpcy5fZ2V0VHJhbnNmb3JtKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbSA9IG5ldyBLb252YS5UcmFuc2Zvcm0oKSxcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5nZXRYKCksXG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuZ2V0WSgpLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gS29udmEuZ2V0QW5nbGUodGhpcy5nZXRSb3RhdGlvbigpKSxcbiAgICAgICAgICAgICAgICBzY2FsZVggPSB0aGlzLmdldFNjYWxlWCgpLFxuICAgICAgICAgICAgICAgIHNjYWxlWSA9IHRoaXMuZ2V0U2NhbGVZKCksXG4gICAgICAgICAgICAgICAgc2tld1ggPSB0aGlzLmdldFNrZXdYKCksXG4gICAgICAgICAgICAgICAgc2tld1kgPSB0aGlzLmdldFNrZXdZKCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0WCA9IHRoaXMuZ2V0T2Zmc2V0WCgpLFxuICAgICAgICAgICAgICAgIG9mZnNldFkgPSB0aGlzLmdldE9mZnNldFkoKTtcblxuICAgICAgICAgICAgaWYoeCAhPT0gMCB8fCB5ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbS50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihyb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG0ucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHNrZXdYICE9PSAwIHx8IHNrZXdZICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbS5za2V3KHNrZXdYLCBza2V3WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgbS5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihvZmZzZXRYICE9PSAwIHx8IG9mZnNldFkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBtLnRyYW5zbGF0ZSgtMSAqIG9mZnNldFgsIC0xICogb2Zmc2V0WSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogY2xvbmUgbm9kZS4gIFJldHVybnMgYSBuZXcgTm9kZSBpbnN0YW5jZSB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzLiAgWW91IGNhbiBhbHNvIG92ZXJyaWRlXG4gICAgICAgICAqICB0aGUgbm9kZSBwcm9wZXJ0aWVzIHdpdGggYW4gb2JqZWN0IGxpdGVyYWwsIGVuYWJsaW5nIHlvdSB0byB1c2UgYW4gZXhpc3Rpbmcgbm9kZSBhcyBhIHRlbXBsYXRlXG4gICAgICAgICAqICBmb3IgYW5vdGhlciBub2RlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogb3ZlcnJpZGUgYXR0cnNcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIHNpbXBsZSBjbG9uZVxuICAgICAgICAgKiB2YXIgY2xvbmUgPSBub2RlLmNsb25lKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGNsb25lIGEgbm9kZSBhbmQgb3ZlcnJpZGUgdGhlIHggcG9zaXRpb25cbiAgICAgICAgICogdmFyIGNsb25lID0gcmVjdC5jbG9uZSh7XG4gICAgICAgICAqICAgeDogNVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIC8vIGluc3RhbnRpYXRlIG5ldyBub2RlXG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBLb252YS5VdGlsLmNsb25lT2JqZWN0KHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIGtleSwgYWxsTGlzdGVuZXJzLCBsZW4sIG4sIGxpc3RlbmVyO1xuICAgICAgICAgICAgLy8gZmlsdGVyIGJsYWNrIGF0dHJzXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIENMT05FX0JMQUNLX0xJU1QpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tBdHRyID0gQ0xPTkVfQkxBQ0tfTElTVFtpXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgYXR0cnNbYmxvY2tBdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGx5IGF0dHIgb3ZlcnJpZGVzXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoYXR0cnMpO1xuICAgICAgICAgICAgLy8gY29weSBvdmVyIGxpc3RlbmVyc1xuICAgICAgICAgICAgZm9yKGtleSBpbiB0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgYWxsTGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVyc1trZXldO1xuICAgICAgICAgICAgICAgIGxlbiA9IGFsbExpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBhbGxMaXN0ZW5lcnNbbl07XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIGRvbid0IGluY2x1ZGUga29udmEgbmFtZXNwYWNlZCBsaXN0ZW5lcnMgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgKiAgdGhlc2UgYXJlIGdlbmVyYXRlZCBieSB0aGUgY29uc3RydWN0b3JzXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZihsaXN0ZW5lci5uYW1lLmluZGV4T2YoS09OVkEpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbGlzdGVuZXJzIGFycmF5IGRvZXNuJ3QgZXhpc3QsIHRoZW4gY3JlYXRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighbm9kZS5ldmVudExpc3RlbmVyc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ldmVudExpc3RlbmVyc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmV2ZW50TGlzdGVuZXJzW2tleV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgZGF0YSBVUkwuIElmIE1JTUUgdHlwZSBpcyBub3RcbiAgICAgICAgICogc3BlY2lmaWVkLCB0aGVuIFwiaW1hZ2UvcG5nXCIgd2lsbCByZXN1bHQuIEZvciBcImltYWdlL2pwZWdcIiwgc3BlY2lmeSBhIHF1YWxpdHlcbiAgICAgICAgICogbGV2ZWwgYXMgcXVhbGl0eSAocmFuZ2UgMC4wIC0gMS4wKVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm1pbWVUeXBlXSBjYW4gYmUgXCJpbWFnZS9wbmdcIiBvciBcImltYWdlL2pwZWdcIi5cbiAgICAgICAgICogIFwiaW1hZ2UvcG5nXCIgaXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF0geCBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XSB5IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSB3aWR0aCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdIGhlaWdodCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5xdWFsaXR5XSBqcGVnIHF1YWxpdHkuICBJZiB1c2luZyBhbiBcImltYWdlL2pwZWdcIiBtaW1lVHlwZSxcbiAgICAgICAgICogIHlvdSBjYW4gc3BlY2lmeSB0aGUgcXVhbGl0eSBmcm9tIDAgdG8gMSwgd2hlcmUgMCBpcyB2ZXJ5IHBvb3IgcXVhbGl0eSBhbmQgMVxuICAgICAgICAgKiAgaXMgdmVyeSBoaWdoIHF1YWxpdHlcbiAgICAgICAgICogQHBhcmVtdCB7TnVtYmVyfSBbY29uZmlnLnBpeGVsUmF0aW9dIHBpeGVsUmF0aW8gb2Ygb3VwdXQgaW1hZ2UgdXJsLiBEZWZhdWx0IGlzIDFcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRvRGF0YVVSTDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICAgICAgICAgIHZhciBtaW1lVHlwZSA9IGNvbmZpZy5taW1lVHlwZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHF1YWxpdHkgPSBjb25maWcucXVhbGl0eSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpLFxuICAgICAgICAgICAgICAgIHggPSBjb25maWcueCB8fCAwLFxuICAgICAgICAgICAgICAgIHkgPSBjb25maWcueSB8fCAwLFxuICAgICAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IG5ldyBLb252YS5TY2VuZUNhbnZhcyh7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb25maWcud2lkdGggfHwgdGhpcy5nZXRXaWR0aCgpIHx8IChzdGFnZSA/IHN0YWdlLmdldFdpZHRoKCkgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjb25maWcuaGVpZ2h0IHx8IHRoaXMuZ2V0SGVpZ2h0KCkgfHwgKHN0YWdlID8gc3RhZ2UuZ2V0SGVpZ2h0KCkgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogcGl4ZWxSYXRpb1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgpO1xuXG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgICAgICAgaWYoeCB8fCB5KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLTEgKiB4LCAtMSAqIHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRyYXdTY2VuZShjYW52YXMpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlLCBxdWFsaXR5KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbnZlcnRzIG5vZGUgaW50byBhbiBpbWFnZS4gIFNpbmNlIHRoZSB0b0ltYWdlXG4gICAgICAgICAqICBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCBhIGNhbGxiYWNrIGlzIHJlcXVpcmVkLiAgdG9JbWFnZSBpcyBtb3N0IGNvbW1vbmx5IHVzZWRcbiAgICAgICAgICogIHRvIGNhY2hlIGNvbXBsZXggZHJhd2luZ3MgYXMgYW4gaW1hZ2Ugc28gdGhhdCB0aGV5IGRvbid0IGhhdmUgdG8gY29uc3RhbnRseSBiZSByZWRyYXduXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLmNhbGxiYWNrIGZ1bmN0aW9uIGV4ZWN1dGVkIHdoZW4gdGhlIGNvbXBvc2l0ZSBoYXMgY29tcGxldGVkXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm1pbWVUeXBlXSBjYW4gYmUgXCJpbWFnZS9wbmdcIiBvciBcImltYWdlL2pwZWdcIi5cbiAgICAgICAgICogIFwiaW1hZ2UvcG5nXCIgaXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF0geCBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XSB5IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSB3aWR0aCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdIGhlaWdodCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5xdWFsaXR5XSBqcGVnIHF1YWxpdHkuICBJZiB1c2luZyBhbiBcImltYWdlL2pwZWdcIiBtaW1lVHlwZSxcbiAgICAgICAgICogIHlvdSBjYW4gc3BlY2lmeSB0aGUgcXVhbGl0eSBmcm9tIDAgdG8gMSwgd2hlcmUgMCBpcyB2ZXJ5IHBvb3IgcXVhbGl0eSBhbmQgMVxuICAgICAgICAgKiAgaXMgdmVyeSBoaWdoIHF1YWxpdHlcbiAgICAgICAgICogQHBhcmVtdCB7TnVtYmVyfSBbY29uZmlnLnBpeGVsUmF0aW9dIHBpeGVsUmF0aW8gb2Ygb3VwdXQgaW1hZ2UuICBEZWZhdWx0IGlzIDEuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciBpbWFnZSA9IG5vZGUudG9JbWFnZSh7XG4gICAgICAgICAqICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgKiAgICAgLy8gZG8gc3R1ZmYgd2l0aCBpbWdcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKi9cbiAgICAgICAgdG9JbWFnZTogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZyB8fCAhY29uZmlnLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2NhbGxiYWNrIHJlcXVpcmVkIGZvciB0b0ltYWdlIG1ldGhvZCBjb25maWcgYXJndW1lbnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgS29udmEuVXRpbC5fZ2V0SW1hZ2UodGhpcy50b0RhdGFVUkwoY29uZmlnKSwgZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrKGltZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRXaWR0aChzaXplLndpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KHNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLndpZHRoIHx8IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5oZWlnaHQgfHwgMDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBjbGFzcyBuYW1lLCB3aGljaCBtYXkgcmV0dXJuIFN0YWdlLCBMYXllciwgR3JvdXAsIG9yIHNoYXBlIGNsYXNzIG5hbWVzIGxpa2UgUmVjdCwgQ2lyY2xlLCBUZXh0LCBldGMuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NOYW1lIHx8IHRoaXMubm9kZVR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGhlIG5vZGUgdHlwZSwgd2hpY2ggbWF5IHJldHVybiBTdGFnZSwgTGF5ZXIsIEdyb3VwLCBvciBOb2RlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBnZXREcmFnRGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gY29tcGFyZSB3aXRoIHVuZGVmaW5lZCBiZWNhdXNlIHdlIG5lZWQgdG8gdHJhY2sgMCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnMuZHJhZ0Rpc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5kcmFnRGlzdGFuY2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldERyYWdEaXN0YW5jZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gS29udmEuZHJhZ0Rpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZ2V0OiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NOYW1lID09PSBzZWxlY3RvciB8fCB0aGlzLm5vZGVUeXBlID09PSBzZWxlY3RvciA/IFt0aGlzXSA6IFtdO1xuICAgICAgICB9LFxuICAgICAgICBfb2ZmOiBmdW5jdGlvbih0eXBlLCBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZXZ0TGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVyc1t0eXBlXSxcbiAgICAgICAgICAgICAgICBpLCBldnROYW1lO1xuXG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBldnRMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBldnROYW1lID0gZXZ0TGlzdGVuZXJzW2ldLm5hbWU7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyB0d28gY29uZGl0aW9ucyBtdXN0IGJlIHRydWUgaW4gb3JkZXIgdG8gcmVtb3ZlIGEgaGFuZGxlcjpcbiAgICAgICAgICAgICAgICAvLyAxKSB0aGUgY3VycmVudCBldmVudCBuYW1lIGNhbm5vdCBiZSBrb252YSB1bmxlc3MgdGhlIGV2ZW50IG5hbWUgaXMga29udmFcbiAgICAgICAgICAgICAgICAvLyAgICB0aGlzIGVuYWJsZXMgZGV2ZWxvcGVycyB0byBmb3JjZSByZW1vdmUgYSBrb252YSBzcGVjaWZpYyBsaXN0ZW5lciBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgICAgICAgICAgICAgLy8gMikgYW4gZXZlbnQgbmFtZSBpcyBub3Qgc3BlY2lmaWVkLCBvciBpZiBvbmUgaXMgc3BlY2lmaWVkLCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgICBpZigoZXZ0TmFtZSAhPT0gJ2tvbnZhJyB8fCBuYW1lID09PSAna29udmEnKSAmJiAoIW5hbWUgfHwgZXZ0TmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0TGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZXZ0TGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRMaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZmlyZUNoYW5nZUV2ZW50OiBmdW5jdGlvbihhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZShhdHRyICsgQ0hBTkdFLCB7XG4gICAgICAgICAgICAgICAgb2xkVmFsOiBvbGRWYWwsXG4gICAgICAgICAgICAgICAgbmV3VmFsOiBuZXdWYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRJZDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHZhciBvbGRJZCA9IHRoaXMuZ2V0SWQoKTtcblxuICAgICAgICAgICAgS29udmEuX3JlbW92ZUlkKG9sZElkKTtcbiAgICAgICAgICAgIEtvbnZhLl9hZGRJZCh0aGlzLCBpZCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyKElELCBpZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdmFyIG9sZE5hbWVzID0gKHRoaXMuZ2V0TmFtZSgpIHx8ICcnKS5zcGxpdCgvXFxzL2cpO1xuICAgICAgICAgICAgdmFyIG5ld05hbWVzID0gKG5hbWUgfHwgJycpLnNwbGl0KC9cXHMvZyk7XG4gICAgICAgICAgICB2YXIgc3VibmFtZSwgaTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbGwgc3VibmFtZXNcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IG9sZE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VibmFtZSA9IG9sZE5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICgobmV3TmFtZXMuaW5kZXhPZihzdWJuYW1lKSkgPT09IC0xICYmIHN1Ym5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuX3JlbW92ZU5hbWUoc3VibmFtZSwgdGhpcy5faWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIG5ldyBuYW1lc1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbmV3TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJuYW1lID0gbmV3TmFtZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKChvbGROYW1lcy5pbmRleE9mKHN1Ym5hbWUpID09PSAtMSkgJiYgc3VibmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBLb252YS5fYWRkTmFtZSh0aGlzLCBzdWJuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoTkFNRSwgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbmFtaW5nIG1ldGhvZHNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFkZCBuYW1lIHRvIG5vZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUubmFtZSgncmVkJyk7XG4gICAgICAgICAqIG5vZGUuYWRkTmFtZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICogbm9kZS5uYW1lKCk7IC8vIHJldHVybiAncmVkIHNlbGVjdGVkJ1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkTmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc05hbWUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkTmFtZSA9IHRoaXMubmFtZSgpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdOYW1lID0gb2xkTmFtZSA/IChvbGROYW1lICsgJyAnICsgbmFtZSkgOiBuYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmFtZShuZXdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogY2hlY2sgaXMgbm9kZSBoYXMgbmFtZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbm9kZS5uYW1lKCdyZWQnKTtcbiAgICAgICAgICogbm9kZS5oYXNOYW1lKCdyZWQnKTsgICAvLyByZXR1cm4gdHJ1ZVxuICAgICAgICAgKiBub2RlLmhhc05hbWUoJ3NlbGVjdGVkJyk7IC8vIHJldHVybiBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgaGFzTmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdmFyIG5hbWVzID0gKHRoaXMubmFtZSgpIHx8ICcnKS5zcGxpdCgvXFxzL2cpO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVzLmluZGV4T2YobmFtZSkgIT09IC0xO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmVtb3ZlIG5hbWUgZnJvbSBub2RlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBub2RlLm5hbWUoJ3JlZCBzZWxlY3RlZCcpO1xuICAgICAgICAgKiBub2RlLnJlbW92ZU5hbWUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAqIG5vZGUuaGFzTmFtZSgnc2VsZWN0ZWQnKTsgLy8gcmV0dXJuIGZhbHNlXG4gICAgICAgICAqIG5vZGUubmFtZSgpOyAvLyByZXR1cm4gJ3JlZCdcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBuYW1lcyA9ICh0aGlzLm5hbWUoKSB8fCAnJykuc3BsaXQoL1xccy9nKTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IG5hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbmFtZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5hbWUobmFtZXMuam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IGF0dHJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWxcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIG5vZGUuc2V0QXR0cigneCcsIDUpO1xuICAgICAgICAgKi9cbiAgICAgICAgc2V0QXR0cjogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gU0VUICsgS29udmEuVXRpbC5fY2FwaXRhbGl6ZShhdHRyKSxcbiAgICAgICAgICAgICAgICBmdW5jID0gdGhpc1ttZXRob2RdO1xuXG4gICAgICAgICAgICBpZihLb252YS5VdGlsLl9pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgZnVuYy5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugc2V0IGRpcmVjdGx5XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKGF0dHIsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX3NldEF0dHI6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgb2xkVmFsO1xuICAgICAgICAgICAgb2xkVmFsID0gdGhpcy5hdHRyc1trZXldO1xuICAgICAgICAgICAgaWYgKG9sZFZhbCA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyc1trZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5hdHRyc1trZXldID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KGtleSwgb2xkVmFsLCB2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0Q29tcG9uZW50QXR0cjogZnVuY3Rpb24oa2V5LCBjb21wb25lbnQsIHZhbCkge1xuICAgICAgICAgICAgdmFyIG9sZFZhbDtcbiAgICAgICAgICAgIGlmKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsID0gdGhpcy5hdHRyc1trZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvbGRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHZhbHVlIHRvIGRlZmF1bHQgdmFsdWUgdXNpbmcgZ2V0QXR0clxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJzW2tleV0gPSB0aGlzLmdldEF0dHIoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJzW2tleV1bY29tcG9uZW50XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlQ2hhbmdlRXZlbnQoa2V5LCBvbGRWYWwsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9maXJlQW5kQnViYmxlOiBmdW5jdGlvbihldmVudFR5cGUsIGV2dCwgY29tcGFyZVNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgb2theVRvUnVuID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYoZXZ0ICYmIHRoaXMubm9kZVR5cGUgPT09IFNIQVBFKSB7XG4gICAgICAgICAgICAgICAgZXZ0LnRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGV2ZW50VHlwZSA9PT0gTU9VU0VFTlRFUiAmJiBjb21wYXJlU2hhcGUgJiYgKHRoaXMuX2lkID09PSBjb21wYXJlU2hhcGUuX2lkIHx8ICh0aGlzLmlzQW5jZXN0b3JPZiAmJiB0aGlzLmlzQW5jZXN0b3JPZihjb21wYXJlU2hhcGUpKSkpIHtcbiAgICAgICAgICAgICAgICBva2F5VG9SdW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoZXZlbnRUeXBlID09PSBNT1VTRUxFQVZFICYmIGNvbXBhcmVTaGFwZSAmJiAodGhpcy5faWQgPT09IGNvbXBhcmVTaGFwZS5faWQgfHwgKHRoaXMuaXNBbmNlc3Rvck9mICYmIHRoaXMuaXNBbmNlc3Rvck9mKGNvbXBhcmVTaGFwZSkpKSkge1xuICAgICAgICAgICAgICAgIG9rYXlUb1J1biA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYob2theVRvUnVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZShldmVudFR5cGUsIGV2dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzaW11bGF0ZSBldmVudCBidWJibGluZ1xuICAgICAgICAgICAgICAgIHZhciBzdG9wQnViYmxlID1cbiAgICAgICAgICAgICAgICAgICAgKGV2ZW50VHlwZSA9PT0gTU9VU0VFTlRFUiB8fCBldmVudFR5cGUgPT09IE1PVVNFTEVBVkUpICYmXG4gICAgICAgICAgICAgICAgICAgICgoY29tcGFyZVNoYXBlICYmIGNvbXBhcmVTaGFwZS5pc0FuY2VzdG9yT2YgJiYgY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZih0aGlzKSAmJiAhY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZih0aGlzLnBhcmVudCkpKTtcbiAgICAgICAgICAgICAgICBpZigoZXZ0ICYmICFldnQuY2FuY2VsQnViYmxlIHx8ICFldnQpICYmIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzTGlzdGVuaW5nKCkgJiYgKCFzdG9wQnViYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZVNoYXBlICYmIGNvbXBhcmVTaGFwZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVBbmRCdWJibGUuY2FsbCh0aGlzLnBhcmVudCwgZXZlbnRUeXBlLCBldnQsIGNvbXBhcmVTaGFwZS5wYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZUFuZEJ1YmJsZS5jYWxsKHRoaXMucGFyZW50LCBldmVudFR5cGUsIGV2dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9maXJlOiBmdW5jdGlvbihldmVudFR5cGUsIGV2dCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnNbZXZlbnRUeXBlXSxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBldnQgPSBldnQgfHwge307XG4gICAgICAgICAgICBldnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICBldnQudHlwZSA9IGV2ZW50VHlwZTtcblxuICAgICAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBldmVudHNbaV0uaGFuZGxlci5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhdyBib3RoIHNjZW5lIGFuZCBoaXQgZ3JhcGhzLiAgSWYgdGhlIG5vZGUgYmVpbmcgZHJhd24gaXMgdGhlIHN0YWdlLCBhbGwgb2YgdGhlIGxheWVycyB3aWxsIGJlIGNsZWFyZWQgYW5kIHJlZHJhd25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICAgICAqL1xuICAgICAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NjZW5lKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdIaXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGUgbm9kZSB3aXRoIEpTT04gc3RyaW5nIG9yIGFuIE9iamVjdC4gIERlLXNlcmlhbGl6dGlvbiBkb2VzIG5vdCBnZW5lcmF0ZSBjdXN0b21cbiAgICAgKiAgc2hhcGUgZHJhd2luZyBmdW5jdGlvbnMsIGltYWdlcywgb3IgZXZlbnQgaGFuZGxlcnMgKHRoaXMgd291bGQgbWFrZSB0aGVcbiAgICAgKiAgc2VyaWFsaXplZCBvYmplY3QgaHVnZSkuICBJZiB5b3VyIGFwcCB1c2VzIGN1c3RvbSBzaGFwZXMsIGltYWdlcywgYW5kXG4gICAgICogIGV2ZW50IGhhbmRsZXJzIChpdCBwcm9iYWJseSBkb2VzKSwgdGhlbiB5b3UgbmVlZCB0byBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlXG4gICAgICogIHNoYXBlcyBhZnRlciBsb2FkaW5nIHRoZSBzdGFnZSBhbmQgc2V0IHRoZXNlIHByb3BlcnRpZXMgdmlhIG9uKCksIHNldERyYXdGdW5jKCksXG4gICAgICogIGFuZCBzZXRJbWFnZSgpIG1ldGhvZHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGpzb24gc3RyaW5nIG9yIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gW2NvbnRhaW5lcl0gb3B0aW9uYWwgY29udGFpbmVyIGRvbSBlbGVtZW50IHVzZWQgb25seSBpZiB5b3UncmVcbiAgICAgKiAgY3JlYXRpbmcgYSBzdGFnZSBub2RlXG4gICAgICovXG4gICAgS29udmEuTm9kZS5jcmVhdGUgPSBmdW5jdGlvbihkYXRhLCBjb250YWluZXIpIHtcbiAgICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlTm9kZShkYXRhLCBjb250YWluZXIpO1xuICAgIH07XG4gICAgS29udmEuTm9kZS5fY3JlYXRlTm9kZSA9IGZ1bmN0aW9uKG9iaiwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5nZXRDbGFzc05hbWUuY2FsbChvYmopLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW4sXG4gICAgICAgICAgICBubywgbGVuLCBuO1xuXG4gICAgICAgIC8vIGlmIGNvbnRhaW5lciB3YXMgcGFzc2VkIGluLCBhZGQgaXQgdG8gYXR0cnNcbiAgICAgICAgaWYoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBvYmouYXR0cnMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgbm8gPSBuZXcgS29udmFbY2xhc3NOYW1lXShvYmouYXR0cnMpO1xuICAgICAgICBpZihjaGlsZHJlbikge1xuICAgICAgICAgICAgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBuby5hZGQodGhpcy5fY3JlYXRlTm9kZShjaGlsZHJlbltuXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vO1xuICAgIH07XG5cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PSBhZGQgZ2V0dGVycyBzZXR0ZXJzID09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdwb3NpdGlvbicpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgbm9kZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBwYXJlbnRcbiAgICAgKiBAbmFtZSBwb3NpdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBwb3NpdGlvblxuICAgICAqIHZhciBwb3NpdGlvbiA9IG5vZGUucG9zaXRpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBwb3NpdGlvblxuICAgICAqIG5vZGUucG9zaXRpb24oe1xuICAgICAqICAgeDogNVxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd4JywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHggcG9zaXRpb25cbiAgICAgKiBAbmFtZSB4XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB4XG4gICAgICogdmFyIHggPSBub2RlLngoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB4XG4gICAgICogbm9kZS54KDUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3knLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgeSBwb3NpdGlvblxuICAgICAqIEBuYW1lIHlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB5XG4gICAgICogdmFyIHkgPSBub2RlLnkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB5XG4gICAgICogbm9kZS55KDUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ29wYWNpdHknLCAxKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgb3BhY2l0eS4gIE9wYWNpdHkgdmFsdWVzIHJhbmdlIGZyb20gMCB0byAxLlxuICAgICAqICBBIG5vZGUgd2l0aCBhbiBvcGFjaXR5IG9mIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQsIGFuZCBhIG5vZGVcbiAgICAgKiAgd2l0aCBhbiBvcGFjaXR5IG9mIDEgaXMgZnVsbHkgb3BhcXVlXG4gICAgICogQG5hbWUgb3BhY2l0eVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgb3BhY2l0eVxuICAgICAqIHZhciBvcGFjaXR5ID0gbm9kZS5vcGFjaXR5KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgb3BhY2l0eVxuICAgICAqIG5vZGUub3BhY2l0eSgwLjUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuTm9kZSwgJ25hbWUnKTtcbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ25hbWUnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgbmFtZVxuICAgICAqIEBuYW1lIG5hbWVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IG5hbWVcbiAgICAgKiB2YXIgbmFtZSA9IG5vZGUubmFtZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IG5hbWVcbiAgICAgKiBub2RlLm5hbWUoJ2ZvbycpO1xuICAgICAqXG4gICAgICogLy8gYWxzbyBub2RlIG1heSBoYXZlIG11bHRpcGxlIG5hbWVzIChhcyBjc3MgY2xhc3NlcylcbiAgICAgKiBub2RlLm5hbWUoJ2ZvbyBiYXInKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLk5vZGUsICdpZCcpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnaWQnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgaWQuIElkIGlzIGdsb2JhbCBmb3Igd2hvbGUgcGFnZS5cbiAgICAgKiBAbmFtZSBpZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGlkXG4gICAgICogdmFyIG5hbWUgPSBub2RlLmlkKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgaWRcbiAgICAgKiBub2RlLmlkKCdmb28nKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdyb3RhdGlvbicsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQG5hbWUgcm90YXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogdmFyIHJvdGF0aW9uID0gbm9kZS5yb3RhdGlvbigpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBub2RlLnJvdGF0aW9uKDQ1KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2NhbGUnLCBbJ3gnLCAneSddKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2NhbGVcbiAgICAgKiBAbmFtZSBzY2FsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZS54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlLnlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzY2FsZVxuICAgICAqIHZhciBzY2FsZSA9IG5vZGUuc2NhbGUoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzY2FsZVxuICAgICAqIHNoYXBlLnNjYWxlKHtcbiAgICAgKiAgIHg6IDJcbiAgICAgKiAgIHk6IDNcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzY2FsZVgnLCAxKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2NhbGUgeFxuICAgICAqIEBuYW1lIHNjYWxlWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2NhbGUgeFxuICAgICAqIHZhciBzY2FsZVggPSBub2RlLnNjYWxlWCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNjYWxlIHhcbiAgICAgKiBub2RlLnNjYWxlWCgyKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzY2FsZVknLCAxKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc2NhbGUgeVxuICAgICAqIEBuYW1lIHNjYWxlWVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2NhbGUgeVxuICAgICAqIHZhciBzY2FsZVkgPSBub2RlLnNjYWxlWSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNjYWxlIHlcbiAgICAgKiBub2RlLnNjYWxlWSgyKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2tldycsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBza2V3XG4gICAgICogQG5hbWUgc2tld1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBza2V3XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNrZXcueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBza2V3LnlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBza2V3XG4gICAgICogdmFyIHNrZXcgPSBub2RlLnNrZXcoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBza2V3XG4gICAgICogbm9kZS5za2V3KHtcbiAgICAgKiAgIHg6IDIwXG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NrZXdYJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNrZXcgeFxuICAgICAqIEBuYW1lIHNrZXdYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBza2V3IHhcbiAgICAgKiB2YXIgc2tld1ggPSBub2RlLnNrZXdYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2tldyB4XG4gICAgICogbm9kZS5za2V3WCgzKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdza2V3WScsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBza2V3IHlcbiAgICAgKiBAbmFtZSBza2V3WVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2tldyB5XG4gICAgICogdmFyIHNrZXdZID0gbm9kZS5za2V3WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNrZXcgeVxuICAgICAqIG5vZGUuc2tld1koMyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ29mZnNldCcsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBvZmZzZXQuICBPZmZzZXRzIHRoZSBkZWZhdWx0IHBvc2l0aW9uIGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvZmZzZXRcbiAgICAgKiB2YXIgb2Zmc2V0ID0gbm9kZS5vZmZzZXQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBvZmZzZXRcbiAgICAgKiBub2RlLm9mZnNldCh7XG4gICAgICogICB4OiAyMFxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdvZmZzZXRYJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG9mZnNldCB4XG4gICAgICogQG5hbWUgb2Zmc2V0WFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgb2Zmc2V0IHhcbiAgICAgKiB2YXIgb2Zmc2V0WCA9IG5vZGUub2Zmc2V0WCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IG9mZnNldCB4XG4gICAgICogbm9kZS5vZmZzZXRYKDMpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ29mZnNldFknLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgb2Zmc2V0IHlcbiAgICAgKiBAbmFtZSBvZmZzZXRZXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvZmZzZXQgeVxuICAgICAqIHZhciBvZmZzZXRZID0gbm9kZS5vZmZzZXRZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgb2Zmc2V0IHlcbiAgICAgKiBub2RlLm9mZnNldFkoMyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZFNldHRlcihLb252YS5Ob2RlLCAnZHJhZ0Rpc3RhbmNlJyk7XG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdkcmFnRGlzdGFuY2UnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZHJhZyBkaXN0YW5jZVxuICAgICAqIEBuYW1lIGRyYWdEaXN0YW5jZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGRyYWcgZGlzdGFuY2VcbiAgICAgKiB2YXIgZHJhZ0Rpc3RhbmNlID0gbm9kZS5kcmFnRGlzdGFuY2UoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBkaXN0YW5jZVxuICAgICAqIC8vIG5vZGUgc3RhcnRzIGRyYWdnaW5nIG9ubHkgaWYgcG9pbnRlciBtb3ZlZCBtb3JlIHRoZW4gMyBwaXhlbHNcbiAgICAgKiBub2RlLmRyYWdEaXN0YW5jZSgzKTtcbiAgICAgKiAvLyBvciBzZXQgZ2xvYmFsbHlcbiAgICAgKiBLb252YS5kcmFnRGlzdGFuY2UgPSAzO1xuICAgICAqL1xuXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZFNldHRlcihLb252YS5Ob2RlLCAnd2lkdGgnLCAwKTtcbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3dpZHRoJyk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCB3aWR0aFxuICAgICAqIEBuYW1lIHdpZHRoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgd2lkdGhcbiAgICAgKiB2YXIgd2lkdGggPSBub2RlLndpZHRoKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgd2lkdGhcbiAgICAgKiBub2RlLndpZHRoKDEwMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZFNldHRlcihLb252YS5Ob2RlLCAnaGVpZ2h0JywgMCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdoZWlnaHQnKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGhlaWdodFxuICAgICAqIEBuYW1lIGhlaWdodFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBoZWlnaHRcbiAgICAgKiB2YXIgaGVpZ2h0ID0gbm9kZS5oZWlnaHQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBoZWlnaHRcbiAgICAgKiBub2RlLmhlaWdodCgxMDApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2xpc3RlbmluZycsICdpbmhlcml0Jyk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBsaXN0ZW5pZyBhdHRyLiAgSWYgeW91IG5lZWQgdG8gZGV0ZXJtaW5lIGlmIGEgbm9kZSBpcyBsaXN0ZW5pbmcgb3Igbm90XG4gICAgICogICBieSB0YWtpbmcgaW50byBhY2NvdW50IGl0cyBwYXJlbnRzLCB1c2UgdGhlIGlzTGlzdGVuaW5nKCkgbWV0aG9kXG4gICAgICogQG5hbWUgbGlzdGVuaW5nXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IGxpc3RlbmluZyBDYW4gYmUgXCJpbmhlcml0XCIsIHRydWUsIG9yIGZhbHNlLiAgVGhlIGRlZmF1bHQgaXMgXCJpbmhlcml0XCIuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGxpc3RlbmluZyBhdHRyXG4gICAgICogdmFyIGxpc3RlbmluZyA9IG5vZGUubGlzdGVuaW5nKCk7XG4gICAgICpcbiAgICAgKiAvLyBzdG9wIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogbm9kZS5saXN0ZW5pbmcoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gbGlzdGVuIGZvciBldmVudHNcbiAgICAgKiBub2RlLmxpc3RlbmluZyh0cnVlKTtcbiAgICAgKlxuICAgICAqIC8vIGxpc3RlbiB0byBldmVudHMgYWNjb3JkaW5nIHRvIHRoZSBwYXJlbnRcbiAgICAgKiBub2RlLmxpc3RlbmluZygnaW5oZXJpdCcpO1xuICAgICAqL1xuXG5cblxuICAgICAvKipcbiAgICAgICogZ2V0L3NldCBwcmV2ZW50RGVmYXVsdFxuICAgICAgKiBCeSBkZWZhdWx0IGFsbCBzaGFwZXMgd2lsbCBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3VyXG4gICAgICAqIG9mIGEgYnJvd3NlciBvbiBhIHBvaW50ZXIgbW92ZSBvciB0YXAuXG4gICAgICAqIHRoYXQgd2lsbCBwcmV2ZW50IG5hdGl2ZSBzY3JvbGxpbmcgd2hlbiB5b3UgYXJlIHRyeWluZyB0byBkcmFnJmRyb3AgYSBub2RlXG4gICAgICAqIGJ1dCBzb21ldGltZXMgeW91IG1heSBuZWVkIHRvIGVuYWJsZSBkZWZhdWx0IGFjdGlvbnNcbiAgICAgICogaW4gdGhhdCBjYXNlIHlvdSBjYW4gc2V0IHRoZSBwcm9wZXJ0eSB0byBmYWxzZVxuICAgICAgKiBAbmFtZSBwcmV2ZW50RGVmYXVsdFxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJldmVudERlZmF1bHRcbiAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICogQGV4YW1wbGVcbiAgICAgICogLy8gZ2V0IHByZXZlbnREZWZhdWx0XG4gICAgICAqIHZhciBzaG91bGRQcmV2ZW50ID0gc2hhcGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICpcbiAgICAgICogLy8gc2V0IHByZXZlbnREZWZhdWx0XG4gICAgICAqIHNoYXBlLnByZXZlbnREZWZhdWx0KGZhbHNlKTtcbiAgICAgICovXG5cbiAgICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3ByZXZlbnREZWZhdWx0JywgdHJ1ZSk7XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZmlsdGVycycsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsKSB7dGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTsgcmV0dXJuIHZhbDsgfSk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWx0ZXJzLiAgRmlsdGVycyBhcmUgYXBwbGllZCB0byBjYWNoZWQgY2FudmFzZXNcbiAgICAgKiBAbmFtZSBmaWx0ZXJzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgYXJyYXkgb2YgZmlsdGVyc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWx0ZXJzXG4gICAgICogdmFyIGZpbHRlcnMgPSBub2RlLmZpbHRlcnMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBhIHNpbmdsZSBmaWx0ZXJcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkJsdXJdKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBtdWx0aXBsZSBmaWx0ZXJzXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbXG4gICAgICogICBLb252YS5GaWx0ZXJzLkJsdXIsXG4gICAgICogICBLb252YS5GaWx0ZXJzLlNlcGlhLFxuICAgICAqICAgS29udmEuRmlsdGVycy5JbnZlcnRcbiAgICAgKiBdKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd2aXNpYmxlJywgJ2luaGVyaXQnKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHZpc2libGUgYXR0ci4gIENhbiBiZSBcImluaGVyaXRcIiwgdHJ1ZSwgb3IgZmFsc2UuICBUaGUgZGVmYXVsdCBpcyBcImluaGVyaXRcIi5cbiAgICAgKiAgIElmIHlvdSBuZWVkIHRvIGRldGVybWluZSBpZiBhIG5vZGUgaXMgdmlzaWJsZSBvciBub3RcbiAgICAgKiAgIGJ5IHRha2luZyBpbnRvIGFjY291bnQgaXRzIHBhcmVudHMsIHVzZSB0aGUgaXNWaXNpYmxlKCkgbWV0aG9kXG4gICAgICogQG5hbWUgdmlzaWJsZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSB2aXNpYmxlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW58U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHZpc2libGUgYXR0clxuICAgICAqIHZhciB2aXNpYmxlID0gbm9kZS52aXNpYmxlKCk7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIGludmlzaWJsZVxuICAgICAqIG5vZGUudmlzaWJsZShmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIHZpc2libGVcbiAgICAgKiBub2RlLnZpc2libGUodHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBtYWtlIHZpc2libGUgYWNjb3JkaW5nIHRvIHRoZSBwYXJlbnRcbiAgICAgKiBub2RlLnZpc2libGUoJ2luaGVyaXQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd0cmFuc2Zvcm1zRW5hYmxlZCcsICdhbGwnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgdHJhbnNmb3JtcyB0aGF0IGFyZSBlbmFibGVkLiAgQ2FuIGJlIFwiYWxsXCIsIFwibm9uZVwiLCBvciBcInBvc2l0aW9uXCIuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBcImFsbFwiXG4gICAgICogQG5hbWUgdHJhbnNmb3Jtc0VuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZW5hYmxlIHBvc2l0aW9uIHRyYW5zZm9ybSBvbmx5IHRvIGltcHJvdmUgZHJhdyBwZXJmb3JtYW5jZVxuICAgICAqIG5vZGUudHJhbnNmb3Jtc0VuYWJsZWQoJ3Bvc2l0aW9uJyk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgYWxsIHRyYW5zZm9ybXNcbiAgICAgKiBub2RlLnRyYW5zZm9ybXNFbmFibGVkKCdhbGwnKTtcbiAgICAgKi9cblxuXG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG5vZGUgc2l6ZVxuICAgICAqIEBuYW1lIHNpemVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNpemVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2l6ZS53aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplLmhlaWdodFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgbm9kZSBzaXplXG4gICAgICogdmFyIHNpemUgPSBub2RlLnNpemUoKTtcbiAgICAgKiB2YXIgeCA9IHNpemUueDtcbiAgICAgKiB2YXIgeSA9IHNpemUueTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaXplXG4gICAgICogbm9kZS5zaXplKHtcbiAgICAgKiAgIHdpZHRoOiAxMDAsXG4gICAgICogICBoZWlnaHQ6IDIwMFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2l6ZScpO1xuXG4gICAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLk5vZGUsIHtcbiAgICAgICAgcm90YXRlRGVnOiAncm90YXRlJyxcbiAgICAgICAgc2V0Um90YXRpb25EZWc6ICdzZXRSb3RhdGlvbicsXG4gICAgICAgIGdldFJvdGF0aW9uRGVnOiAnZ2V0Um90YXRpb24nXG4gICAgfSk7XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuTm9kZSk7XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgKiBHcmF5c2NhbGUgRmlsdGVyXHJcbiAgICAqIEBmdW5jdGlvblxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkdyYXlzY2FsZV0pO1xyXG4gICAgKi9cclxuICAgIEtvbnZhLkZpbHRlcnMuR3JheXNjYWxlID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGksIGJyaWdodG5lc3M7XHJcblxyXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIGJyaWdodG5lc3MgPSAwLjM0ICogZGF0YVtpXSArIDAuNSAqIGRhdGFbaSArIDFdICsgMC4xNiAqIGRhdGFbaSArIDJdO1xyXG4gICAgICAgICAgICAvLyByZWRcclxuICAgICAgICAgICAgZGF0YVtpXSA9IGJyaWdodG5lc3M7XHJcbiAgICAgICAgICAgIC8vIGdyZWVuXHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gYnJpZ2h0bmVzcztcclxuICAgICAgICAgICAgLy8gYmx1ZVxyXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGJyaWdodG5lc3M7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkoKTtcclxuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIEJyaWdodGVuIEZpbHRlci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuQnJpZ2h0ZW5dKTtcbiAgICAgKiBub2RlLmJyaWdodG5lc3MoMC44KTtcbiAgICAgKi9cbiAgICBLb252YS5GaWx0ZXJzLkJyaWdodGVuID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBicmlnaHRuZXNzID0gdGhpcy5icmlnaHRuZXNzKCkgKiAyNTUsXG4gICAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgICAgIC8vIHJlZFxuICAgICAgICAgICAgZGF0YVtpXSArPSBicmlnaHRuZXNzO1xuICAgICAgICAgICAgLy8gZ3JlZW5cbiAgICAgICAgICAgIGRhdGFbaSArIDFdICs9IGJyaWdodG5lc3M7XG4gICAgICAgICAgICAvLyBibHVlXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSArPSBicmlnaHRuZXNzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdicmlnaHRuZXNzJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGZpbHRlciBicmlnaHRuZXNzLiAgVGhlIGJyaWdodG5lc3MgaXMgYSBudW1iZXIgYmV0d2VlbiAtMSBhbmQgMS4mbmJzcDsgUG9zaXRpdmUgdmFsdWVzXG4gICAgKiAgYnJpZ2h0ZW4gdGhlIHBpeGVscyBhbmQgbmVnYXRpdmUgdmFsdWVzIGRhcmtlbiB0aGVtLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5CcmlnaHRlbn0gZmlsdGVyLlxuICAgICogQG5hbWUgYnJpZ2h0bmVzc1xuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gYnJpZ2h0bmVzcyB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgKiBJbnZlcnQgRmlsdGVyXHJcbiAgICAqIEBmdW5jdGlvblxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkludmVydF0pO1xyXG4gICAgKi9cclxuICAgIEtvbnZhLkZpbHRlcnMuSW52ZXJ0ID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGk7XHJcblxyXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIC8vIHJlZFxyXG4gICAgICAgICAgICBkYXRhW2ldID0gMjU1IC0gZGF0YVtpXTtcclxuICAgICAgICAgICAgLy8gZ3JlZW5cclxuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSAyNTUgLSBkYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgLy8gYmx1ZVxyXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtIGRhdGFbaSArIDJdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0pKCk7XHJcblxuLypcbiB0aGUgR2F1c3MgZmlsdGVyXG4gbWFzdGVyIHJlcG86IGh0dHBzOi8vZ2l0aHViLmNvbS9wYXZlbHBvd2VyL2tpbmV0aWNqc0dhdXNzRmlsdGVyXG4qL1xuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKlxuXG4gICAgIFN0YWNrQmx1ciAtIGEgZmFzdCBhbG1vc3QgR2F1c3NpYW4gQmx1ciBGb3IgQ2FudmFzXG5cbiAgICAgVmVyc2lvbjogICAwLjVcbiAgICAgQXV0aG9yOiAgICBNYXJpbyBLbGluZ2VtYW5uXG4gICAgIENvbnRhY3Q6ICAgbWFyaW9AcXVhc2ltb25kby5jb21cbiAgICAgV2Vic2l0ZTogICBodHRwOi8vd3d3LnF1YXNpbW9uZG8uY29tL1N0YWNrQmx1ckZvckNhbnZhc1xuICAgICBUd2l0dGVyOiAgIEBxdWFzaW1vbmRvXG5cbiAgICAgSW4gY2FzZSB5b3UgZmluZCB0aGlzIGNsYXNzIHVzZWZ1bCAtIGVzcGVjaWFsbHkgaW4gY29tbWVyY2lhbCBwcm9qZWN0cyAtXG4gICAgIEkgYW0gbm90IHRvdGFsbHkgdW5oYXBweSBmb3IgYSBzbWFsbCBkb25hdGlvbiB0byBteSBQYXlQYWwgYWNjb3VudFxuICAgICBtYXJpb0BxdWFzaW1vbmRvLmRlXG5cbiAgICAgT3Igc3VwcG9ydCBtZSBvbiBmbGF0dHI6XG4gICAgIGh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdFxuXG4gICAgIENvcHlyaWdodCAoYykgMjAxMCBNYXJpbyBLbGluZ2VtYW5uXG5cbiAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAgICAgZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICAgICBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAgICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAgICAgY29uZGl0aW9uczpcblxuICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiAgICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAgICAgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4gICAgIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gICAgIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEJsdXJTdGFjaygpIHtcbiAgICAgICAgdGhpcy5yID0gMDtcbiAgICAgICAgdGhpcy5nID0gMDtcbiAgICAgICAgdGhpcy5iID0gMDtcbiAgICAgICAgdGhpcy5hID0gMDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbXVsX3RhYmxlID0gW1xuICAgICAgICA1MTIsIDUxMiwgNDU2LCA1MTIsIDMyOCwgNDU2LCAzMzUsIDUxMiwgNDA1LCAzMjgsIDI3MSwgNDU2LCAzODgsIDMzNSwgMjkyLCA1MTIsXG4gICAgICAgIDQ1NCwgNDA1LCAzNjQsIDMyOCwgMjk4LCAyNzEsIDQ5NiwgNDU2LCA0MjAsIDM4OCwgMzYwLCAzMzUsIDMxMiwgMjkyLCAyNzMsIDUxMixcbiAgICAgICAgNDgyLCA0NTQsIDQyOCwgNDA1LCAzODMsIDM2NCwgMzQ1LCAzMjgsIDMxMiwgMjk4LCAyODQsIDI3MSwgMjU5LCA0OTYsIDQ3NSwgNDU2LFxuICAgICAgICA0MzcsIDQyMCwgNDA0LCAzODgsIDM3NCwgMzYwLCAzNDcsIDMzNSwgMzIzLCAzMTIsIDMwMiwgMjkyLCAyODIsIDI3MywgMjY1LCA1MTIsXG4gICAgICAgIDQ5NywgNDgyLCA0NjgsIDQ1NCwgNDQxLCA0MjgsIDQxNywgNDA1LCAzOTQsIDM4MywgMzczLCAzNjQsIDM1NCwgMzQ1LCAzMzcsIDMyOCxcbiAgICAgICAgMzIwLCAzMTIsIDMwNSwgMjk4LCAyOTEsIDI4NCwgMjc4LCAyNzEsIDI2NSwgMjU5LCA1MDcsIDQ5NiwgNDg1LCA0NzUsIDQ2NSwgNDU2LFxuICAgICAgICA0NDYsIDQzNywgNDI4LCA0MjAsIDQxMiwgNDA0LCAzOTYsIDM4OCwgMzgxLCAzNzQsIDM2NywgMzYwLCAzNTQsIDM0NywgMzQxLCAzMzUsXG4gICAgICAgIDMyOSwgMzIzLCAzMTgsIDMxMiwgMzA3LCAzMDIsIDI5NywgMjkyLCAyODcsIDI4MiwgMjc4LCAyNzMsIDI2OSwgMjY1LCAyNjEsIDUxMixcbiAgICAgICAgNTA1LCA0OTcsIDQ4OSwgNDgyLCA0NzUsIDQ2OCwgNDYxLCA0NTQsIDQ0NywgNDQxLCA0MzUsIDQyOCwgNDIyLCA0MTcsIDQxMSwgNDA1LFxuICAgICAgICAzOTksIDM5NCwgMzg5LCAzODMsIDM3OCwgMzczLCAzNjgsIDM2NCwgMzU5LCAzNTQsIDM1MCwgMzQ1LCAzNDEsIDMzNywgMzMyLCAzMjgsXG4gICAgICAgIDMyNCwgMzIwLCAzMTYsIDMxMiwgMzA5LCAzMDUsIDMwMSwgMjk4LCAyOTQsIDI5MSwgMjg3LCAyODQsIDI4MSwgMjc4LCAyNzQsIDI3MSxcbiAgICAgICAgMjY4LCAyNjUsIDI2MiwgMjU5LCAyNTcsIDUwNywgNTAxLCA0OTYsIDQ5MSwgNDg1LCA0ODAsIDQ3NSwgNDcwLCA0NjUsIDQ2MCwgNDU2LFxuICAgICAgICA0NTEsIDQ0NiwgNDQyLCA0MzcsIDQzMywgNDI4LCA0MjQsIDQyMCwgNDE2LCA0MTIsIDQwOCwgNDA0LCA0MDAsIDM5NiwgMzkyLCAzODgsXG4gICAgICAgIDM4NSwgMzgxLCAzNzcsIDM3NCwgMzcwLCAzNjcsIDM2MywgMzYwLCAzNTcsIDM1NCwgMzUwLCAzNDcsIDM0NCwgMzQxLCAzMzgsIDMzNSxcbiAgICAgICAgMzMyLCAzMjksIDMyNiwgMzIzLCAzMjAsIDMxOCwgMzE1LCAzMTIsIDMxMCwgMzA3LCAzMDQsIDMwMiwgMjk5LCAyOTcsIDI5NCwgMjkyLFxuICAgICAgICAyODksIDI4NywgMjg1LCAyODIsIDI4MCwgMjc4LCAyNzUsIDI3MywgMjcxLCAyNjksIDI2NywgMjY1LCAyNjMsIDI2MSwgMjU5XG4gICAgXTtcblxuICAgIHZhciBzaGdfdGFibGUgPSBbXG4gICAgICAgIDksIDExLCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxNiwgMTcsXG4gICAgICAgIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE5LFxuICAgICAgICAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCxcbiAgICAgICAgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjEsXG4gICAgICAgIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLFxuICAgICAgICAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcbiAgICAgICAgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsXG4gICAgICAgIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIzLFxuICAgICAgICAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMyxcbiAgICAgICAgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXG4gICAgICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLFxuICAgICAgICAyMywgMjMsIDIzLCAyMywgMjMsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcbiAgICAgICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsXG4gICAgICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgICAgICAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcbiAgICAgICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNFxuICAgIF07XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJHYXVzc0JsdXJSR0JBKCBpbWFnZURhdGEsIHJhZGl1cykge1xuXG4gICAgICAgIHZhciBwaXhlbHMgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDtcblxuICAgICAgICB2YXIgeCwgeSwgaSwgcCwgeXAsIHlpLCB5dywgcl9zdW0sIGdfc3VtLCBiX3N1bSwgYV9zdW0sXG4gICAgICAgICAgICByX291dF9zdW0sIGdfb3V0X3N1bSwgYl9vdXRfc3VtLCBhX291dF9zdW0sXG4gICAgICAgICAgICByX2luX3N1bSwgZ19pbl9zdW0sIGJfaW5fc3VtLCBhX2luX3N1bSxcbiAgICAgICAgICAgIHByLCBwZywgcGIsIHBhLCByYnM7XG5cbiAgICAgICAgdmFyIGRpdiA9IHJhZGl1cyArIHJhZGl1cyArIDEsXG4gICAgICAgICAgICB3aWR0aE1pbnVzMSA9IHdpZHRoIC0gMSxcbiAgICAgICAgICAgIGhlaWdodE1pbnVzMSA9IGhlaWdodCAtIDEsXG4gICAgICAgICAgICByYWRpdXNQbHVzMSA9IHJhZGl1cyArIDEsXG4gICAgICAgICAgICBzdW1GYWN0b3IgPSByYWRpdXNQbHVzMSAqICggcmFkaXVzUGx1czEgKyAxICkgLyAyLFxuICAgICAgICAgICAgc3RhY2tTdGFydCA9IG5ldyBCbHVyU3RhY2soKSxcbiAgICAgICAgICAgIHN0YWNrRW5kID0gbnVsbCxcbiAgICAgICAgICAgIHN0YWNrID0gc3RhY2tTdGFydCxcbiAgICAgICAgICAgIHN0YWNrSW4gPSBudWxsLFxuICAgICAgICAgICAgc3RhY2tPdXQgPSBudWxsLFxuICAgICAgICAgICAgbXVsX3N1bSA9IG11bF90YWJsZVtyYWRpdXNdLFxuICAgICAgICAgICAgc2hnX3N1bSA9IHNoZ190YWJsZVtyYWRpdXNdO1xuXG4gICAgICAgIGZvciAoIGkgPSAxOyBpIDwgZGl2OyBpKysgKSB7XG4gICAgICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQgPSBuZXcgQmx1clN0YWNrKCk7XG4gICAgICAgICAgICBpZiAoIGkgPT09IHJhZGl1c1BsdXMxICl7XG4gICAgICAgICAgICAgICAgc3RhY2tFbmQgPSBzdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YWNrLm5leHQgPSBzdGFja1N0YXJ0O1xuXG4gICAgICAgIHl3ID0geWkgPSAwO1xuXG4gICAgICAgIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKVxuICAgICAgICB7XG4gICAgICAgICAgICByX2luX3N1bSA9IGdfaW5fc3VtID0gYl9pbl9zdW0gPSBhX2luX3N1bSA9IHJfc3VtID0gZ19zdW0gPSBiX3N1bSA9IGFfc3VtID0gMDtcblxuICAgICAgICAgICAgcl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHByID0gcGl4ZWxzW3lpXSApO1xuICAgICAgICAgICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBnID0gcGl4ZWxzW3lpICsgMV0gKTtcbiAgICAgICAgICAgIGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYiA9IHBpeGVsc1t5aSArIDJdICk7XG4gICAgICAgICAgICBhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGEgPSBwaXhlbHNbeWkgKyAzXSApO1xuXG4gICAgICAgICAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcbiAgICAgICAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgICAgICAgICAgYl9zdW0gKz0gc3VtRmFjdG9yICogcGI7XG4gICAgICAgICAgICBhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgICAgICAgICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgICAgICAgICBmb3IoIGkgPSAwOyBpIDwgcmFkaXVzUGx1czE7IGkrKyApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhY2suciA9IHByO1xuICAgICAgICAgICAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgICAgICAgICAgICBzdGFjay5iID0gcGI7XG4gICAgICAgICAgICAgICAgc3RhY2suYSA9IHBhO1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKCBpID0gMTsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHAgPSB5aSArICgoIHdpZHRoTWludXMxIDwgaSA/IHdpZHRoTWludXMxIDogaSApIDw8IDIgKTtcbiAgICAgICAgICAgICAgICByX3N1bSArPSAoIHN0YWNrLnIgPSAoIHByID0gcGl4ZWxzW3BdKSkgKiAoIHJicyA9IHJhZGl1c1BsdXMxIC0gaSApO1xuICAgICAgICAgICAgICAgIGdfc3VtICs9ICggc3RhY2suZyA9ICggcGcgPSBwaXhlbHNbcCArIDFdKSkgKiByYnM7XG4gICAgICAgICAgICAgICAgYl9zdW0gKz0gKCBzdGFjay5iID0gKCBwYiA9IHBpeGVsc1twICsgMl0pKSAqIHJicztcbiAgICAgICAgICAgICAgICBhX3N1bSArPSAoIHN0YWNrLmEgPSAoIHBhID0gcGl4ZWxzW3AgKyAzXSkpICogcmJzO1xuXG4gICAgICAgICAgICAgICAgcl9pbl9zdW0gKz0gcHI7XG4gICAgICAgICAgICAgICAgZ19pbl9zdW0gKz0gcGc7XG4gICAgICAgICAgICAgICAgYl9pbl9zdW0gKz0gcGI7XG4gICAgICAgICAgICAgICAgYV9pbl9zdW0gKz0gcGE7XG5cbiAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG4gICAgICAgICAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuICAgICAgICAgICAgZm9yICggeCA9IDA7IHggPCB3aWR0aDsgeCsrIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwaXhlbHNbeWkgKyAzXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcbiAgICAgICAgICAgICAgICBpZiAoIHBhICE9PSAwIClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1t5aV0gPSAoKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3lpICsgMV0gPSAoKGdfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3lpICsgMl0gPSAoKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbeWldID0gcGl4ZWxzW3lpICsgMV0gPSBwaXhlbHNbeWkgKyAyXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgICAgICAgICAgIGdfc3VtIC09IGdfb3V0X3N1bTtcbiAgICAgICAgICAgICAgICBiX3N1bSAtPSBiX291dF9zdW07XG4gICAgICAgICAgICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xuXG4gICAgICAgICAgICAgICAgcl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcbiAgICAgICAgICAgICAgICBnX291dF9zdW0gLT0gc3RhY2tJbi5nO1xuICAgICAgICAgICAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICAgICAgICAgICAgYV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblxuICAgICAgICAgICAgICAgIHAgPSAoeXcgKyAoICggcCA9IHggKyByYWRpdXMgKyAxICkgPCB3aWR0aE1pbnVzMSA/IHAgOiB3aWR0aE1pbnVzMSApICkgPDwgMjtcblxuICAgICAgICAgICAgICAgIHJfaW5fc3VtICs9ICggc3RhY2tJbi5yID0gcGl4ZWxzW3BdKTtcbiAgICAgICAgICAgICAgICBnX2luX3N1bSArPSAoIHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV0pO1xuICAgICAgICAgICAgICAgIGJfaW5fc3VtICs9ICggc3RhY2tJbi5iID0gcGl4ZWxzW3AgKyAyXSk7XG4gICAgICAgICAgICAgICAgYV9pbl9zdW0gKz0gKCBzdGFja0luLmEgPSBwaXhlbHNbcCArIDNdKTtcblxuICAgICAgICAgICAgICAgIHJfc3VtICs9IHJfaW5fc3VtO1xuICAgICAgICAgICAgICAgIGdfc3VtICs9IGdfaW5fc3VtO1xuICAgICAgICAgICAgICAgIGJfc3VtICs9IGJfaW5fc3VtO1xuICAgICAgICAgICAgICAgIGFfc3VtICs9IGFfaW5fc3VtO1xuXG4gICAgICAgICAgICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgICAgICAgICAgIHJfb3V0X3N1bSArPSAoIHByID0gc3RhY2tPdXQuciApO1xuICAgICAgICAgICAgICAgIGdfb3V0X3N1bSArPSAoIHBnID0gc3RhY2tPdXQuZyApO1xuICAgICAgICAgICAgICAgIGJfb3V0X3N1bSArPSAoIHBiID0gc3RhY2tPdXQuYiApO1xuICAgICAgICAgICAgICAgIGFfb3V0X3N1bSArPSAoIHBhID0gc3RhY2tPdXQuYSApO1xuXG4gICAgICAgICAgICAgICAgcl9pbl9zdW0gLT0gcHI7XG4gICAgICAgICAgICAgICAgZ19pbl9zdW0gLT0gcGc7XG4gICAgICAgICAgICAgICAgYl9pbl9zdW0gLT0gcGI7XG4gICAgICAgICAgICAgICAgYV9pbl9zdW0gLT0gcGE7XG5cbiAgICAgICAgICAgICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cbiAgICAgICAgICAgICAgICB5aSArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeXcgKz0gd2lkdGg7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGZvciAoIHggPSAwOyB4IDwgd2lkdGg7IHgrKyApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdfaW5fc3VtID0gYl9pbl9zdW0gPSBhX2luX3N1bSA9IHJfaW5fc3VtID0gZ19zdW0gPSBiX3N1bSA9IGFfc3VtID0gcl9zdW0gPSAwO1xuXG4gICAgICAgICAgICB5aSA9IHggPDwgMjtcbiAgICAgICAgICAgIHJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwciA9IHBpeGVsc1t5aV0pO1xuICAgICAgICAgICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBnID0gcGl4ZWxzW3lpICsgMV0pO1xuICAgICAgICAgICAgYl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBiID0gcGl4ZWxzW3lpICsgMl0pO1xuICAgICAgICAgICAgYV9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBhID0gcGl4ZWxzW3lpICsgM10pO1xuXG4gICAgICAgICAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcbiAgICAgICAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgICAgICAgICAgYl9zdW0gKz0gc3VtRmFjdG9yICogcGI7XG4gICAgICAgICAgICBhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgICAgICAgICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgICAgICAgICBmb3IoIGkgPSAwOyBpIDwgcmFkaXVzUGx1czE7IGkrKyApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhY2suciA9IHByO1xuICAgICAgICAgICAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgICAgICAgICAgICBzdGFjay5iID0gcGI7XG4gICAgICAgICAgICAgICAgc3RhY2suYSA9IHBhO1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeXAgPSB3aWR0aDtcblxuICAgICAgICAgICAgZm9yKCBpID0gMTsgaSA8PSByYWRpdXM7IGkrKyApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeWkgPSAoIHlwICsgeCApIDw8IDI7XG5cbiAgICAgICAgICAgICAgICByX3N1bSArPSAoIHN0YWNrLnIgPSAoIHByID0gcGl4ZWxzW3lpXSkpICogKCByYnMgPSByYWRpdXNQbHVzMSAtIGkgKTtcbiAgICAgICAgICAgICAgICBnX3N1bSArPSAoIHN0YWNrLmcgPSAoIHBnID0gcGl4ZWxzW3lpICsgMV0pKSAqIHJicztcbiAgICAgICAgICAgICAgICBiX3N1bSArPSAoIHN0YWNrLmIgPSAoIHBiID0gcGl4ZWxzW3lpICsgMl0pKSAqIHJicztcbiAgICAgICAgICAgICAgICBhX3N1bSArPSAoIHN0YWNrLmEgPSAoIHBhID0gcGl4ZWxzW3lpICsgM10pKSAqIHJicztcblxuICAgICAgICAgICAgICAgIHJfaW5fc3VtICs9IHByO1xuICAgICAgICAgICAgICAgIGdfaW5fc3VtICs9IHBnO1xuICAgICAgICAgICAgICAgIGJfaW5fc3VtICs9IHBiO1xuICAgICAgICAgICAgICAgIGFfaW5fc3VtICs9IHBhO1xuXG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuXG4gICAgICAgICAgICAgICAgaWYoIGkgPCBoZWlnaHRNaW51czEgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgeXAgKz0gd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5aSA9IHg7XG4gICAgICAgICAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICAgICAgICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG4gICAgICAgICAgICBmb3IgKCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwID0geWkgPDwgMjtcbiAgICAgICAgICAgICAgICBwaXhlbHNbcCArIDNdID0gcGEgPSAoYV9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtO1xuICAgICAgICAgICAgICAgIGlmICggcGEgPiAwIClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1twXSA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3AgKyAxXSA9ICgoZ19zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxzW3AgKyAyXSA9ICgoYl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNbcF0gPSBwaXhlbHNbcCArIDFdID0gcGl4ZWxzW3AgKyAyXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgICAgICAgICAgIGdfc3VtIC09IGdfb3V0X3N1bTtcbiAgICAgICAgICAgICAgICBiX3N1bSAtPSBiX291dF9zdW07XG4gICAgICAgICAgICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xuXG4gICAgICAgICAgICAgICAgcl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcbiAgICAgICAgICAgICAgICBnX291dF9zdW0gLT0gc3RhY2tJbi5nO1xuICAgICAgICAgICAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICAgICAgICAgICAgYV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblxuICAgICAgICAgICAgICAgIHAgPSAoIHggKyAoKCAoIHAgPSB5ICsgcmFkaXVzUGx1czEpIDwgaGVpZ2h0TWludXMxID8gcCA6IGhlaWdodE1pbnVzMSApICogd2lkdGggKSkgPDwgMjtcblxuICAgICAgICAgICAgICAgIHJfc3VtICs9ICggcl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0pKTtcbiAgICAgICAgICAgICAgICBnX3N1bSArPSAoIGdfaW5fc3VtICs9ICggc3RhY2tJbi5nID0gcGl4ZWxzW3AgKyAxXSkpO1xuICAgICAgICAgICAgICAgIGJfc3VtICs9ICggYl9pbl9zdW0gKz0gKCBzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdKSk7XG4gICAgICAgICAgICAgICAgYV9zdW0gKz0gKCBhX2luX3N1bSArPSAoIHN0YWNrSW4uYSA9IHBpeGVsc1twICsgM10pKTtcblxuICAgICAgICAgICAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cbiAgICAgICAgICAgICAgICByX291dF9zdW0gKz0gKCBwciA9IHN0YWNrT3V0LnIgKTtcbiAgICAgICAgICAgICAgICBnX291dF9zdW0gKz0gKCBwZyA9IHN0YWNrT3V0LmcgKTtcbiAgICAgICAgICAgICAgICBiX291dF9zdW0gKz0gKCBwYiA9IHN0YWNrT3V0LmIgKTtcbiAgICAgICAgICAgICAgICBhX291dF9zdW0gKz0gKCBwYSA9IHN0YWNrT3V0LmEgKTtcblxuICAgICAgICAgICAgICAgIHJfaW5fc3VtIC09IHByO1xuICAgICAgICAgICAgICAgIGdfaW5fc3VtIC09IHBnO1xuICAgICAgICAgICAgICAgIGJfaW5fc3VtIC09IHBiO1xuICAgICAgICAgICAgICAgIGFfaW5fc3VtIC09IHBhO1xuXG4gICAgICAgICAgICAgICAgc3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXG4gICAgICAgICAgICAgICAgeWkgKz0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCbHVyIEZpbHRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIEJsdXJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuQmx1cl0pO1xuICAgICAqIG5vZGUuYmx1clJhZGl1cygxMCk7XG4gICAgICovXG4gICAgS29udmEuRmlsdGVycy5CbHVyID0gZnVuY3Rpb24gQmx1cihpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgucm91bmQodGhpcy5ibHVyUmFkaXVzKCkpO1xuXG4gICAgICAgIGlmIChyYWRpdXMgPiAwKSB7XG4gICAgICAgICAgICBmaWx0ZXJHYXVzc0JsdXJSR0JBKGltYWdlRGF0YSwgcmFkaXVzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnYmx1clJhZGl1cycsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuXG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGJsdXIgcmFkaXVzLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5CbHVyfSBmaWx0ZXJcbiAgICAqIEBuYW1lIGJsdXJSYWRpdXNcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSByYWRpdXNcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlICBtYXgtZGVwdGggKi9cbihmdW5jdGlvbigpIHtcblx0J3VzZSBzdHJpY3QnO1xuXHRmdW5jdGlvbiBwaXhlbEF0KGlkYXRhLCB4LCB5KSB7XG5cdFx0dmFyIGlkeCA9ICh5ICogaWRhdGEud2lkdGggKyB4KSAqIDQ7XG5cdFx0dmFyIGQgPSBbXTtcblx0XHRkLnB1c2goaWRhdGEuZGF0YVtpZHgrK10sIGlkYXRhLmRhdGFbaWR4KytdLCBpZGF0YS5kYXRhW2lkeCsrXSwgaWRhdGEuZGF0YVtpZHgrK10pO1xuXHRcdHJldHVybiBkO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmdiRGlzdGFuY2UocDEsIHAyKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMVswXSAtIHAyWzBdLCAyKSArIE1hdGgucG93KHAxWzFdIC0gcDJbMV0sIDIpICsgTWF0aC5wb3cocDFbMl0gLSBwMlsyXSwgMikpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmdiTWVhbihwVGFiKSB7XG5cdFx0dmFyIG0gPSBbMCwgMCwgMF07XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBUYWIubGVuZ3RoOyBpKyspIHtcblx0XHRcdG1bMF0gKz0gcFRhYltpXVswXTtcblx0XHRcdG1bMV0gKz0gcFRhYltpXVsxXTtcblx0XHRcdG1bMl0gKz0gcFRhYltpXVsyXTtcblx0XHR9XG5cblx0XHRtWzBdIC89IHBUYWIubGVuZ3RoO1xuXHRcdG1bMV0gLz0gcFRhYi5sZW5ndGg7XG5cdFx0bVsyXSAvPSBwVGFiLmxlbmd0aDtcblxuXHRcdHJldHVybiBtO1xuXHR9XG5cblx0ZnVuY3Rpb24gYmFja2dyb3VuZE1hc2soaWRhdGEsIHRocmVzaG9sZCkge1xuXHRcdHZhciByZ2J2X25vID0gcGl4ZWxBdChpZGF0YSwgMCwgMCk7XG5cdFx0dmFyIHJnYnZfbmUgPSBwaXhlbEF0KGlkYXRhLCBpZGF0YS53aWR0aCAtIDEsIDApO1xuXHRcdHZhciByZ2J2X3NvID0gcGl4ZWxBdChpZGF0YSwgMCwgaWRhdGEuaGVpZ2h0IC0gMSk7XG5cdFx0dmFyIHJnYnZfc2UgPSBwaXhlbEF0KGlkYXRhLCBpZGF0YS53aWR0aCAtIDEsIGlkYXRhLmhlaWdodCAtIDEpO1xuXG5cblx0XHR2YXIgdGhyZXMgPSB0aHJlc2hvbGQgfHwgMTA7XG5cdFx0aWYgKHJnYkRpc3RhbmNlKHJnYnZfbm8sIHJnYnZfbmUpIDwgdGhyZXMgJiYgcmdiRGlzdGFuY2Uocmdidl9uZSwgcmdidl9zZSkgPCB0aHJlcyAmJiByZ2JEaXN0YW5jZShyZ2J2X3NlLCByZ2J2X3NvKSA8IHRocmVzICYmIHJnYkRpc3RhbmNlKHJnYnZfc28sIHJnYnZfbm8pIDwgdGhyZXMpIHtcblxuXHRcdFx0Ly8gTWVhbiBjb2xvclxuXHRcdFx0dmFyIG1lYW4gPSByZ2JNZWFuKFtyZ2J2X25lLCByZ2J2X25vLCByZ2J2X3NlLCByZ2J2X3NvXSk7XG5cblx0XHRcdC8vIE1hc2sgYmFzZWQgb24gY29sb3IgZGlzdGFuY2Vcblx0XHRcdHZhciBtYXNrID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGlkYXRhLndpZHRoICogaWRhdGEuaGVpZ2h0OyBpKyspIHtcblx0XHRcdFx0dmFyIGQgPSByZ2JEaXN0YW5jZShtZWFuLCBbaWRhdGEuZGF0YVtpICogNF0sIGlkYXRhLmRhdGFbaSAqIDQgKyAxXSwgaWRhdGEuZGF0YVtpICogNCArIDJdXSk7XG5cdFx0XHRcdG1hc2tbaV0gPSAoZCA8IHRocmVzKSA/IDAgOiAyNTU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXNrO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5TWFzayhpZGF0YSwgbWFzaykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaWRhdGEud2lkdGggKiBpZGF0YS5oZWlnaHQ7IGkrKykge1xuXHRcdFx0aWRhdGEuZGF0YVs0ICogaSArIDNdID0gbWFza1tpXTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBlcm9kZU1hc2sobWFzaywgc3csIHNoKSB7XG5cblx0XHR2YXIgd2VpZ2h0cyA9IFsxLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAxXTtcblx0XHR2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XG5cdFx0dmFyIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMik7XG5cblx0XHR2YXIgbWFza1Jlc3VsdCA9IFtdO1xuXHRcdGZvciAodmFyIHkgPSAwOyB5IDwgc2g7IHkrKykge1xuXHRcdFx0Zm9yICh2YXIgeCA9IDA7IHggPCBzdzsgeCsrKSB7XG5cblx0XHRcdFx0dmFyIHNvID0geSAqIHN3ICsgeDtcblx0XHRcdFx0dmFyIGEgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuXHRcdFx0XHRcdGZvciAodmFyIGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG5cdFx0XHRcdFx0XHR2YXIgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XG5cblx0XHRcdFx0XHRcdGlmIChzY3kgPj0gMCAmJiBzY3kgPCBzaCAmJiBzY3ggPj0gMCAmJiBzY3ggPCBzdykge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzcmNPZmYgPSBzY3kgKiBzdyArIHNjeDtcblx0XHRcdFx0XHRcdFx0dmFyIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cblx0XHRcdFx0XHRcdFx0YSArPSBtYXNrW3NyY09mZl0gKiB3dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtYXNrUmVzdWx0W3NvXSA9IChhID09PSAyNTUgKiA4KSA/IDI1NSA6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc2tSZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBkaWxhdGVNYXNrKG1hc2ssIHN3LCBzaCkge1xuXG5cdFx0dmFyIHdlaWdodHMgPSBbMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMV07XG5cdFx0dmFyIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpO1xuXHRcdHZhciBoYWxmU2lkZSA9IE1hdGguZmxvb3Ioc2lkZSAvIDIpO1xuXG5cdFx0dmFyIG1hc2tSZXN1bHQgPSBbXTtcblx0XHRmb3IgKHZhciB5ID0gMDsgeSA8IHNoOyB5KyspIHtcblx0XHRcdGZvciAodmFyIHggPSAwOyB4IDwgc3c7IHgrKykge1xuXG5cdFx0XHRcdHZhciBzbyA9IHkgKiBzdyArIHg7XG5cdFx0XHRcdHZhciBhID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcblx0XHRcdFx0XHRmb3IgKHZhciBjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xuXHRcdFx0XHRcdFx0dmFyIHNjeSA9IHkgKyBjeSAtIGhhbGZTaWRlO1xuXHRcdFx0XHRcdFx0dmFyIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG5cdFx0XHRcdFx0XHRpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc3JjT2ZmID0gc2N5ICogc3cgKyBzY3g7XG5cdFx0XHRcdFx0XHRcdHZhciB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuXG5cdFx0XHRcdFx0XHRcdGEgKz0gbWFza1tzcmNPZmZdICogd3Q7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWFza1Jlc3VsdFtzb10gPSAoYSA+PSAyNTUgKiA0KSA/IDI1NSA6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc2tSZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzbW9vdGhFZGdlTWFzayhtYXNrLCBzdywgc2gpIHtcblxuXHRcdHZhciB3ZWlnaHRzID0gWzEgLyA5LCAxIC8gOSwgMSAvIDksIDEgLyA5LCAxIC8gOSwgMSAvIDksIDEgLyA5LCAxIC8gOSwgMSAvIDldO1xuXHRcdHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcblx0XHR2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcblxuXHRcdHZhciBtYXNrUmVzdWx0ID0gW107XG5cdFx0Zm9yICh2YXIgeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG5cdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IHN3OyB4KyspIHtcblxuXHRcdFx0XHR2YXIgc28gPSB5ICogc3cgKyB4O1xuXHRcdFx0XHR2YXIgYSA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcblx0XHRcdFx0XHRcdHZhciBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcblx0XHRcdFx0XHRcdHZhciBzY3ggPSB4ICsgY3ggLSBoYWxmU2lkZTtcblxuXHRcdFx0XHRcdFx0aWYgKHNjeSA+PSAwICYmIHNjeSA8IHNoICYmIHNjeCA+PSAwICYmIHNjeCA8IHN3KSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHNyY09mZiA9IHNjeSAqIHN3ICsgc2N4O1xuXHRcdFx0XHRcdFx0XHR2YXIgd3QgPSB3ZWlnaHRzW2N5ICogc2lkZSArIGN4XTtcblxuXHRcdFx0XHRcdFx0XHRhICs9IG1hc2tbc3JjT2ZmXSAqIHd0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hc2tSZXN1bHRbc29dID0gYTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWFza1Jlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBNYXNrIEZpbHRlclxuXHQgKiBAZnVuY3Rpb25cblx0ICogQG5hbWUgTWFza1xuXHQgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG5cdCAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5NYXNrXSk7XG4gICAgICogbm9kZS50aHJlc2hvbGQoMjAwKTtcblx0ICovXG5cdEtvbnZhLkZpbHRlcnMuTWFzayA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuXHRcdC8vIERldGVjdCBwaXhlbHMgY2xvc2UgdG8gdGhlIGJhY2tncm91bmQgY29sb3Jcblx0XHR2YXIgdGhyZXNob2xkID0gdGhpcy50aHJlc2hvbGQoKSxcbiAgICAgICAgbWFzayA9IGJhY2tncm91bmRNYXNrKGltYWdlRGF0YSwgdGhyZXNob2xkKTtcblx0XHRpZiAobWFzaykge1xuXHRcdFx0Ly8gRXJvZGVcblx0XHRcdG1hc2sgPSBlcm9kZU1hc2sobWFzaywgaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcblxuXHRcdFx0Ly8gRGlsYXRlXG5cdFx0XHRtYXNrID0gZGlsYXRlTWFzayhtYXNrLCBpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuXG5cdFx0XHQvLyBHcmFkaWVudFxuXHRcdFx0bWFzayA9IHNtb290aEVkZ2VNYXNrKG1hc2ssIGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XG5cblx0XHRcdC8vIEFwcGx5IG1hc2tcblx0XHRcdGFwcGx5TWFzayhpbWFnZURhdGEsIG1hc2spO1xuXG5cdFx0XHQvLyB0b2RvIDogVXBkYXRlIGhpdCByZWdpb24gZnVuY3Rpb24gYWNjb3JkaW5nIHRvIG1hc2tcblx0XHR9XG5cblx0XHRyZXR1cm4gaW1hZ2VEYXRhO1xuXHR9O1xuXG5cdEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd0aHJlc2hvbGQnLCAwLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbn0pKCk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIFJHQiBGaWx0ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBSR0JcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuUkdCXSk7XG4gICAgICogbm9kZS5ibHVlKDEyMCk7XG4gICAgICogbm9kZS5ncmVlbigyMDApO1xuICAgICAqL1xuICAgIEtvbnZhLkZpbHRlcnMuUkdCID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgICAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgcmVkID0gdGhpcy5yZWQoKSxcbiAgICAgICAgICAgIGdyZWVuID0gdGhpcy5ncmVlbigpLFxuICAgICAgICAgICAgYmx1ZSA9IHRoaXMuYmx1ZSgpLFxuICAgICAgICAgICAgaSwgYnJpZ2h0bmVzcztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XG4gICAgICAgICAgICBicmlnaHRuZXNzID0gKDAuMzQgKiBkYXRhW2ldICsgMC41ICogZGF0YVtpICsgMV0gKyAwLjE2ICogZGF0YVtpICsgMl0pIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpXSA9IGJyaWdodG5lc3MgKiByZWQ7IC8vIHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gYnJpZ2h0bmVzcyAqIGdyZWVuOyAvLyBnXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGJyaWdodG5lc3MgKiBibHVlOyAvLyBiXG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IGRhdGFbaSArIDNdOyAvLyBhbHBoYVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdyZWQnLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICAgICAgcmV0dXJuIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIHJlZCB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSByZWRcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSByZWQgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZ3JlZW4nLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICAgICAgcmV0dXJuIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIGdyZWVuIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0J9IGZpbHRlci5cbiAgICAqIEBuYW1lIGdyZWVuXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZ3JlZW4gdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnYmx1ZScsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50LCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIGJsdWUgdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlJHQn0gZmlsdGVyLlxuICAgICogQG5hbWUgYmx1ZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IGJsdWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBSR0JBIEZpbHRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFJHQkFcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAYXV0aG9yIGNvZGVmb1xuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5SR0JBXSk7XG4gICAgICogbm9kZS5ibHVlKDEyMCk7XG4gICAgICogbm9kZS5ncmVlbigyMDApO1xuICAgICAqIG5vZGUuYWxwaGEoMC4zKTtcbiAgICAgKi9cbiAgICBLb252YS5GaWx0ZXJzLlJHQkEgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICByZWQgPSB0aGlzLnJlZCgpLFxuICAgICAgICAgICAgZ3JlZW4gPSB0aGlzLmdyZWVuKCksXG4gICAgICAgICAgICBibHVlID0gdGhpcy5ibHVlKCksXG4gICAgICAgICAgICBhbHBoYSA9IHRoaXMuYWxwaGEoKSxcbiAgICAgICAgICAgIGksIGlhO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgICAgICAgIGlhID0gMSAtIGFscGhhO1xuXG4gICAgICAgICAgICBkYXRhW2ldID0gcmVkICogYWxwaGEgKyBkYXRhW2ldICogaWE7IC8vIHJcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZ3JlZW4gKiBhbHBoYSArIGRhdGFbaSArIDFdICogaWE7IC8vIGdcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYmx1ZSAqIGFscGhhICsgZGF0YVtpICsgMl0gKiBpYTsgLy8gYlxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdyZWQnLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgICAgICAgcmV0dXJuIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIHJlZCB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICogQG5hbWUgcmVkXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gcmVkIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2dyZWVuJywgMCwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XG4gICAgICAgIGlmICh2YWwgPiAyNTUpIHtcbiAgICAgICAgICAgIHJldHVybiAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGZpbHRlciBncmVlbiB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICogQG5hbWUgZ3JlZW5cbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBncmVlbiB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdibHVlJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBmaWx0ZXIgYmx1ZSB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICogQG5hbWUgYmx1ZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IGJsdWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnYWxwaGEnLCAxLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhbCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsdGVyIGFscGhhIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0JBfSBmaWx0ZXIuXG4gICAgICogQG5hbWUgYWxwaGFcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtGbG9hdH0gYWxwaGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHJldHVybnMge0Zsb2F0fVxuICAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgKiBIU1YgRmlsdGVyLiBBZGp1c3RzIHRoZSBodWUsIHNhdHVyYXRpb24gYW5kIHZhbHVlXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBuYW1lIEhTVlxuICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICogQGV4YW1wbGVcbiAgICAqIGltYWdlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuSFNWXSk7XG4gICAgKiBpbWFnZS52YWx1ZSgyMDApO1xuICAgICovXG5cbiAgICBLb252YS5GaWx0ZXJzLkhTViA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICAgIG5QaXhlbHMgPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHYgPSBNYXRoLnBvdygyLCB0aGlzLnZhbHVlKCkpLFxuICAgICAgICAgICAgcyA9IE1hdGgucG93KDIsIHRoaXMuc2F0dXJhdGlvbigpKSxcbiAgICAgICAgICAgIGggPSBNYXRoLmFicygodGhpcy5odWUoKSkgKyAzNjApICUgMzYwLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBCYXNpcyBmb3IgdGhlIHRlY2huaXF1ZSB1c2VkOlxuICAgICAgICAvLyBodHRwOi8vYmVlc2J1enouYml6L2NvZGUvaHN2X2NvbG9yX3RyYW5zZm9ybXMucGhwXG4gICAgICAgIC8vIFYgaXMgdGhlIHZhbHVlIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxuICAgICAgICAvLyBTIGlzIHRoZSBzYXR1cmF0aW9uIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxuICAgICAgICAvLyBIIGlzIHRoZSBodWUgc2hpZnQgaW4gZGVncmVlcyAoMCB0byAzNjApXG4gICAgICAgIC8vIHZzdSA9IFYqUypjb3MoSCpQSS8xODApO1xuICAgICAgICAvLyB2c3cgPSBWKlMqc2luKEgqUEkvMTgwKTtcbiAgICAgICAgLy9bIC4yOTlWKy43MDF2c3UrLjE2OHZzdyAgICAuNTg3Vi0uNTg3dnN1Ky4zMzB2c3cgICAgLjExNFYtLjExNHZzdS0uNDk3dnN3IF0gW1JdXG4gICAgICAgIC8vWyAuMjk5Vi0uMjk5dnN1LS4zMjh2c3cgICAgLjU4N1YrLjQxM3ZzdSsuMDM1dnN3ICAgIC4xMTRWLS4xMTR2c3UrLjI5MnZzdyBdKltHXVxuICAgICAgICAvL1sgLjI5OVYtLjMwMHZzdSsxLjI1dnN3ICAgIC41ODdWLS41ODh2c3UtMS4wNXZzdyAgICAuMTE0VisuODg2dnN1LS4yMDN2c3cgXSBbQl1cblxuICAgICAgICAvLyBQcmVjb21wdXRlIHRoZSB2YWx1ZXMgaW4gdGhlIG1hdHJpeDpcbiAgICAgICAgdmFyIHZzdSA9IHYgKiBzICogTWF0aC5jb3MoaCAqIE1hdGguUEkgLyAxODApLFxuICAgICAgICAgICAgdnN3ID0gdiAqIHMgKiBNYXRoLnNpbihoICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIC8vIChyZXN1bHQgc3BvdCkoc291cmNlIHNwb3QpXG4gICAgICAgIHZhciByciA9IDAuMjk5ICogdiArIDAuNzAxICogdnN1ICsgMC4xNjcgKiB2c3csXG4gICAgICAgICAgICByZyA9IDAuNTg3ICogdiAtIDAuNTg3ICogdnN1ICsgMC4zMzAgKiB2c3csXG4gICAgICAgICAgICByYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1IC0gMC40OTcgKiB2c3c7XG4gICAgICAgIHZhciBnciA9IDAuMjk5ICogdiAtIDAuMjk5ICogdnN1IC0gMC4zMjggKiB2c3csXG4gICAgICAgICAgICBnZyA9IDAuNTg3ICogdiArIDAuNDEzICogdnN1ICsgMC4wMzUgKiB2c3csXG4gICAgICAgICAgICBnYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1ICsgMC4yOTMgKiB2c3c7XG4gICAgICAgIHZhciBiciA9IDAuMjk5ICogdiAtIDAuMzAwICogdnN1ICsgMS4yNTAgKiB2c3csXG4gICAgICAgICAgICBiZyA9IDAuNTg3ICogdiAtIDAuNTg2ICogdnN1IC0gMS4wNTAgKiB2c3csXG4gICAgICAgICAgICBiYiA9IDAuMTE0ICogdiArIDAuODg2ICogdnN1IC0gMC4yMDAgKiB2c3c7XG5cbiAgICAgICAgdmFyIHIsIGcsIGIsIGE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgICAgICAgciA9IGRhdGFbaSArIDBdO1xuICAgICAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgICAgICAgYSA9IGRhdGFbaSArIDNdO1xuXG4gICAgICAgICAgICBkYXRhW2kgKyAwXSA9IHJyICogciArIHJnICogZyArIHJiICogYjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZ3IgKiByICsgZ2cgKiBnICsgZ2IgKiBiO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiciAqIHIgKyBiZyAqIGcgKyBiYiAqIGI7XG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IGE7IC8vIGFscGhhXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnaHVlJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGhzdiBodWUgaW4gZGVncmVlcy4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cbiAgICAqIEBuYW1lIGh1ZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaHVlIHZhbHVlIGJldHdlZW4gMCBhbmQgMzU5XG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2F0dXJhdGlvbicsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBoc3Ygc2F0dXJhdGlvbi4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cbiAgICAqIEBuYW1lIHNhdHVyYXRpb25cbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb24gMCBpcyBubyBjaGFuZ2UsIC0xLjAgaGFsdmVzIHRoZSBzYXR1cmF0aW9uLCAxLjAgZG91YmxlcywgZXRjLi5cbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd2YWx1ZScsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBoc3YgdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTVn0gZmlsdGVyLlxuICAgICogQG5hbWUgdmFsdWVcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIDAgaXMgbm8gY2hhbmdlLCAtMS4wIGhhbHZlcyB0aGUgdmFsdWUsIDEuMCBkb3VibGVzLCBldGMuLlxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdodWUnLCAwLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcbiAgICAvKipcbiAgICAqIGdldC9zZXQgaHN2IGh1ZSBpbiBkZWdyZWVzLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgICogQG5hbWUgaHVlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBodWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAzNTlcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzYXR1cmF0aW9uJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGhzdiBzYXR1cmF0aW9uLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgICogQG5hbWUgc2F0dXJhdGlvblxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvbiAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHNhdHVyYXRpb24sIDEuMCBkb3VibGVzLCBldGMuLlxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2x1bWluYW5jZScsIDAsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBoc2wgbHVtaW5hbmNlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cbiAgICAqIEBuYW1lIHZhbHVlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHZhbHVlLCAxLjAgZG91YmxlcywgZXRjLi5cbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogSFNMIEZpbHRlci4gQWRqdXN0cyB0aGUgaHVlLCBzYXR1cmF0aW9uIGFuZCBsdW1pbmFuY2UgKG9yIGxpZ2h0bmVzcylcbiAgICAqIEBmdW5jdGlvblxuICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICogQGV4YW1wbGVcbiAgICAqIGltYWdlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuSFNMXSk7XG4gICAgKiBpbWFnZS5sdW1pbmFuY2UoMjAwKTtcbiAgICAqL1xuXG4gICAgS29udmEuRmlsdGVycy5IU0wgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICB2ID0gMSxcbiAgICAgICAgICAgIHMgPSBNYXRoLnBvdygyLCB0aGlzLnNhdHVyYXRpb24oKSksXG4gICAgICAgICAgICBoID0gTWF0aC5hYnMoKHRoaXMuaHVlKCkpICsgMzYwKSAlIDM2MCxcbiAgICAgICAgICAgIGwgPSB0aGlzLmx1bWluYW5jZSgpICogMTI3LFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBCYXNpcyBmb3IgdGhlIHRlY2huaXF1ZSB1c2VkOlxuICAgICAgICAvLyBodHRwOi8vYmVlc2J1enouYml6L2NvZGUvaHN2X2NvbG9yX3RyYW5zZm9ybXMucGhwXG4gICAgICAgIC8vIFYgaXMgdGhlIHZhbHVlIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxuICAgICAgICAvLyBTIGlzIHRoZSBzYXR1cmF0aW9uIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxuICAgICAgICAvLyBIIGlzIHRoZSBodWUgc2hpZnQgaW4gZGVncmVlcyAoMCB0byAzNjApXG4gICAgICAgIC8vIHZzdSA9IFYqUypjb3MoSCpQSS8xODApO1xuICAgICAgICAvLyB2c3cgPSBWKlMqc2luKEgqUEkvMTgwKTtcbiAgICAgICAgLy9bIC4yOTlWKy43MDF2c3UrLjE2OHZzdyAgICAuNTg3Vi0uNTg3dnN1Ky4zMzB2c3cgICAgLjExNFYtLjExNHZzdS0uNDk3dnN3IF0gW1JdXG4gICAgICAgIC8vWyAuMjk5Vi0uMjk5dnN1LS4zMjh2c3cgICAgLjU4N1YrLjQxM3ZzdSsuMDM1dnN3ICAgIC4xMTRWLS4xMTR2c3UrLjI5MnZzdyBdKltHXVxuICAgICAgICAvL1sgLjI5OVYtLjMwMHZzdSsxLjI1dnN3ICAgIC41ODdWLS41ODh2c3UtMS4wNXZzdyAgICAuMTE0VisuODg2dnN1LS4yMDN2c3cgXSBbQl1cblxuICAgICAgICAvLyBQcmVjb21wdXRlIHRoZSB2YWx1ZXMgaW4gdGhlIG1hdHJpeDpcbiAgICAgICAgdmFyIHZzdSA9IHYgKiBzICogTWF0aC5jb3MoaCAqIE1hdGguUEkgLyAxODApLFxuICAgICAgICAgICAgdnN3ID0gdiAqIHMgKiBNYXRoLnNpbihoICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIC8vIChyZXN1bHQgc3BvdCkoc291cmNlIHNwb3QpXG4gICAgICAgIHZhciByciA9IDAuMjk5ICogdiArIDAuNzAxICogdnN1ICsgMC4xNjcgKiB2c3csXG4gICAgICAgICAgICByZyA9IDAuNTg3ICogdiAtIDAuNTg3ICogdnN1ICsgMC4zMzAgKiB2c3csXG4gICAgICAgICAgICByYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1IC0gMC40OTcgKiB2c3c7XG4gICAgICAgIHZhciBnciA9IDAuMjk5ICogdiAtIDAuMjk5ICogdnN1IC0gMC4zMjggKiB2c3csXG4gICAgICAgICAgICBnZyA9IDAuNTg3ICogdiArIDAuNDEzICogdnN1ICsgMC4wMzUgKiB2c3csXG4gICAgICAgICAgICBnYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1ICsgMC4yOTMgKiB2c3c7XG4gICAgICAgIHZhciBiciA9IDAuMjk5ICogdiAtIDAuMzAwICogdnN1ICsgMS4yNTAgKiB2c3csXG4gICAgICAgICAgICBiZyA9IDAuNTg3ICogdiAtIDAuNTg2ICogdnN1IC0gMS4wNTAgKiB2c3csXG4gICAgICAgICAgICBiYiA9IDAuMTE0ICogdiArIDAuODg2ICogdnN1IC0gMC4yMDAgKiB2c3c7XG5cbiAgICAgICAgdmFyIHIsIGcsIGIsIGE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgICAgICAgciA9IGRhdGFbaSArIDBdO1xuICAgICAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgICAgICAgYSA9IGRhdGFbaSArIDNdO1xuXG4gICAgICAgICAgICBkYXRhW2kgKyAwXSA9IHJyICogciArIHJnICogZyArIHJiICogYiArIGw7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGdyICogciArIGdnICogZyArIGdiICogYiArIGw7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGJyICogciArIGJnICogZyArIGJiICogYiArIGw7XG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IGE7IC8vIGFscGhhXG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogRW1ib3NzIEZpbHRlci5cbiAgICAgKiBQaXhhc3RpYyBMaWIgLSBFbWJvc3MgZmlsdGVyIC0gdjAuMS4wXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA4IEphY29iIFNlaWRlbGluLCBqc2VpZGVsaW5AbmloaWxvZ2ljLmRrLCBodHRwOi8vYmxvZy5uaWhpbG9naWMuZGsvXG4gICAgICogTGljZW5zZTogW2h0dHA6Ly93d3cucGl4YXN0aWMuY29tL2xpYi9saWNlbnNlLnR4dF1cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuRW1ib3NzXSk7XG4gICAgICogbm9kZS5lbWJvc3NTdHJlbmd0aCgwLjgpO1xuICAgICAqIG5vZGUuZW1ib3NzV2hpdGVMZXZlbCgwLjMpO1xuICAgICAqIG5vZGUuZW1ib3NzRGlyZWN0aW9uKCdyaWdodCcpO1xuICAgICAqIG5vZGUuZW1ib3NzQmxlbmQodHJ1ZSk7XG4gICAgICovXG4gICAgS29udmEuRmlsdGVycy5FbWJvc3MgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG5cbiAgICAgICAgLy8gcGl4YXN0aWMgc3RyZW5ndGggaXMgYmV0d2VlbiAwIGFuZCAxMC4gIEkgd2FudCBpdCBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgICAgLy8gcGl4YXN0aWMgZ3JleUxldmVsIGlzIGJldHdlZW4gMCBhbmQgMjU1LiAgSSB3YW50IGl0IGJldHdlZW4gMCBhbmQgMS4gIEFsc28sXG4gICAgICAgIC8vIGEgbWF4IHZhbHVlIG9mIGdyZXlMZXZlbCB5aWVsZHMgYSB3aGl0ZSBlbWJvc3MsIGFuZCB0aGUgbWluIHZhbHVlIHlpZWxkcyBhIGJsYWNrXG4gICAgICAgIC8vIGVtYm9zcy4gIFRoZXJlZm9yZSwgSSBjaGFuZ2VkIGdyZXlMZXZlbCB0byB3aGl0ZUxldmVsXG4gICAgICAgIHZhciBzdHJlbmd0aCA9IHRoaXMuZW1ib3NzU3RyZW5ndGgoKSAqIDEwLFxuICAgICAgICAgICAgZ3JleUxldmVsID0gdGhpcy5lbWJvc3NXaGl0ZUxldmVsKCkgKiAyNTUsXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLmVtYm9zc0RpcmVjdGlvbigpLFxuICAgICAgICAgICAgYmxlbmQgPSB0aGlzLmVtYm9zc0JsZW5kKCksXG4gICAgICAgICAgICBkaXJZID0gMCxcbiAgICAgICAgICAgIGRpclggPSAwLFxuICAgICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgICAgdyA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICAgIGggPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgdzQgPSB3ICogNCxcbiAgICAgICAgICAgIHkgPSBoO1xuXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgICAgICAgICAgICAgZGlyWSA9IC0xO1xuICAgICAgICAgICAgICAgIGRpclggPSAtMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgZGlyWSA9IC0xO1xuICAgICAgICAgICAgICAgIGRpclggPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgICAgICAgICBkaXJZID0gLTE7XG4gICAgICAgICAgICAgICAgZGlyWCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgZGlyWSA9IDA7XG4gICAgICAgICAgICAgICAgZGlyWCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICAgICAgICAgIGRpclkgPSAxO1xuICAgICAgICAgICAgICAgIGRpclggPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBkaXJZID0gMTtcbiAgICAgICAgICAgICAgICBkaXJYID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgICAgICAgICBkaXJZID0gMTtcbiAgICAgICAgICAgICAgICBkaXJYID0gLTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBkaXJZID0gMDtcbiAgICAgICAgICAgICAgICBkaXJYID0gLTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwuZXJyb3IoJ1Vua253byBlbWJvc3MgZGlyZWN0aW9uOiAnICsgZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXRZID0gKHkgLSAxKSAqIHc0O1xuXG4gICAgICAgICAgICB2YXIgb3RoZXJZID0gZGlyWTtcbiAgICAgICAgICAgIGlmICh5ICsgb3RoZXJZIDwgMSl7XG4gICAgICAgICAgICAgICAgb3RoZXJZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ICsgb3RoZXJZID4gaCkge1xuICAgICAgICAgICAgICAgIG90aGVyWSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXRZT3RoZXIgPSAoeSAtIDEgKyBvdGhlclkpICogdyAqIDQ7XG5cbiAgICAgICAgICAgIHZhciB4ID0gdztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0WSArICh4IC0gMSkgKiA0O1xuXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyWCA9IGRpclg7XG4gICAgICAgICAgICAgICAgaWYgKHggKyBvdGhlclggPCAxKXtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJYID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggKyBvdGhlclggPiB3KSB7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyWCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldE90aGVyID0gb2Zmc2V0WU90aGVyICsgKHggLSAxICsgb3RoZXJYKSAqIDQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgZFIgPSBkYXRhW29mZnNldF0gLSBkYXRhW29mZnNldE90aGVyXTtcbiAgICAgICAgICAgICAgICB2YXIgZEcgPSBkYXRhW29mZnNldCArIDFdIC0gZGF0YVtvZmZzZXRPdGhlciArIDFdO1xuICAgICAgICAgICAgICAgIHZhciBkQiA9IGRhdGFbb2Zmc2V0ICsgMl0gLSBkYXRhW29mZnNldE90aGVyICsgMl07XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlmID0gZFI7XG4gICAgICAgICAgICAgICAgdmFyIGFic0RpZiA9IGRpZiA+IDAgPyBkaWYgOiAtZGlmO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFic0cgPSBkRyA+IDAgPyBkRyA6IC1kRztcbiAgICAgICAgICAgICAgICB2YXIgYWJzQiA9IGRCID4gMCA/IGRCIDogLWRCO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFic0cgPiBhYnNEaWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmID0gZEc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhYnNCID4gYWJzRGlmKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZiA9IGRCO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpZiAqPSBzdHJlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChibGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGRhdGFbb2Zmc2V0XSArIGRpZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBkYXRhW29mZnNldCArIDFdICsgZGlmO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGRhdGFbb2Zmc2V0ICsgMl0gKyBkaWY7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gKHIgPiAyNTUpID8gMjU1IDogKHIgPCAwID8gMCA6IHIpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDFdID0gKGcgPiAyNTUpID8gMjU1IDogKGcgPCAwID8gMCA6IGcpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDJdID0gKGIgPiAyNTUpID8gMjU1IDogKGIgPCAwID8gMCA6IGIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmV5ID0gZ3JleUxldmVsIC0gZGlmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JleSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyZXkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdyZXkgPiAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyZXkgPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSBkYXRhW29mZnNldCArIDFdID0gZGF0YVtvZmZzZXQgKyAyXSA9IGdyZXk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IHdoaWxlICgtLXgpO1xuICAgICAgICB9IHdoaWxlICgtLXkpO1xuICAgIH07XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZW1ib3NzU3RyZW5ndGgnLCAwLjUsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuICAgIC8qKlxuICAgICogZ2V0L3NldCBlbWJvc3Mgc3RyZW5ndGguIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxuICAgICogQG5hbWUgZW1ib3NzU3RyZW5ndGhcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIGJldHdlZW4gMCBhbmQgMS4gIERlZmF1bHQgaXMgMC41XG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZW1ib3NzV2hpdGVMZXZlbCcsIDAuNSwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGVtYm9zcyB3aGl0ZSBsZXZlbC4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuRW1ib3NzfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBlbWJvc3NXaGl0ZUxldmVsXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbWJvc3NXaGl0ZUxldmVsIGJldHdlZW4gMCBhbmQgMS4gIERlZmF1bHQgaXMgMC41XG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZW1ib3NzRGlyZWN0aW9uJywgJ3RvcC1sZWZ0JywgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGVtYm9zcyBkaXJlY3Rpb24uIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxuICAgICogQG5hbWUgZW1ib3NzRGlyZWN0aW9uXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbWJvc3NEaXJlY3Rpb24gY2FuIGJlIHRvcC1sZWZ0LCB0b3AsIHRvcC1yaWdodCwgcmlnaHQsIGJvdHRvbS1yaWdodCwgYm90dG9tLCBib3R0b20tbGVmdCBvciBsZWZ0XG4gICAgKiAgIFRoZSBkZWZhdWx0IGlzIHRvcC1sZWZ0XG4gICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZW1ib3NzQmxlbmQnLCBmYWxzZSwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGVtYm9zcyBibGVuZC4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuRW1ib3NzfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBlbWJvc3NCbGVuZFxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVtYm9zc0JsZW5kXG4gICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gcmVtYXAoZnJvbVZhbHVlLCBmcm9tTWluLCBmcm9tTWF4LCB0b01pbiwgdG9NYXgpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAgICAgICAgdmFyIGZyb21SYW5nZSA9IGZyb21NYXggLSBmcm9tTWluLFxuICAgICAgICAgIHRvUmFuZ2UgPSB0b01heCAtIHRvTWluLFxuICAgICAgICAgIHRvVmFsdWU7XG5cbiAgICAgICAgLy8gSWYgZWl0aGVyIHJhbmdlIGlzIDAsIHRoZW4gdGhlIHZhbHVlIGNhbiBvbmx5IGJlIG1hcHBlZCB0byAxIHZhbHVlXG4gICAgICAgIGlmIChmcm9tUmFuZ2UgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0b01pbiArIHRvUmFuZ2UgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JhbmdlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9NaW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyAoMSkgdW50cmFuc2xhdGUsICgyKSB1bnNjYWxlLCAoMykgcmVzY2FsZSwgKDQpIHJldHJhbnNsYXRlXG4gICAgICAgIHRvVmFsdWUgPSAoZnJvbVZhbHVlIC0gZnJvbU1pbikgLyBmcm9tUmFuZ2U7XG4gICAgICAgIHRvVmFsdWUgPSAodG9SYW5nZSAqIHRvVmFsdWUpICsgdG9NaW47XG5cbiAgICAgICAgcmV0dXJuIHRvVmFsdWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAqIEVuaGFuY2UgRmlsdGVyLiBBZGp1c3RzIHRoZSBjb2xvcnMgc28gdGhhdCB0aGV5IHNwYW4gdGhlIHdpZGVzdFxuICAgICogIHBvc3NpYmxlIHJhbmdlIChpZSAwLTI1NSkuIFBlcmZvcm1zIHcqaCBwaXhlbCByZWFkcyBhbmQgdypoIHBpeGVsXG4gICAgKiAgd3JpdGVzLlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAbmFtZSBFbmhhbmNlXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICogQGF1dGhvciBpcHBvNjE1XG4gICAgKiBAZXhhbXBsZVxuICAgICogbm9kZS5jYWNoZSgpO1xuICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkVuaGFuY2VdKTtcbiAgICAqIG5vZGUuZW5oYW5jZSgwLjQpO1xuICAgICovXG4gICAgS29udmEuRmlsdGVycy5FbmhhbmNlID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuICAgICAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgICAgblN1YlBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgck1pbiA9IGRhdGFbMF0sIHJNYXggPSByTWluLCByLFxuICAgICAgICAgICAgZ01pbiA9IGRhdGFbMV0sIGdNYXggPSBnTWluLCBnLFxuICAgICAgICAgICAgYk1pbiA9IGRhdGFbMl0sIGJNYXggPSBiTWluLCBiLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGVuaGFuY2luZyBhbnl0aGluZyAtIGRvbid0IGRvIGFueSBjb21wdXRhdGlvblxuICAgICAgICB2YXIgZW5oYW5jZUFtb3VudCA9IHRoaXMuZW5oYW5jZSgpO1xuICAgICAgICBpZiggZW5oYW5jZUFtb3VudCA9PT0gMCApeyByZXR1cm47IH1cblxuICAgICAgICAvLyAxc3QgUGFzcyAtIGZpbmQgdGhlIG1pbiBhbmQgbWF4IGZvciBlYWNoIGNoYW5uZWw6XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuU3ViUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgICAgICAgIHIgPSBkYXRhW2kgKyAwXTtcbiAgICAgICAgICAgIGlmIChyIDwgck1pbikgeyByTWluID0gcjsgfVxuICAgICAgICAgICAgZWxzZSBpZiAociA+IHJNYXgpIHsgck1heCA9IHI7IH1cbiAgICAgICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChnIDwgZ01pbikgeyBnTWluID0gZzsgfSBlbHNlXG4gICAgICAgICAgICBpZiAoZyA+IGdNYXgpIHsgZ01heCA9IGc7IH1cbiAgICAgICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgICAgIGlmIChiIDwgYk1pbikgeyBiTWluID0gYjsgfSBlbHNlXG4gICAgICAgICAgICBpZiAoYiA+IGJNYXgpIHsgYk1heCA9IGI7IH1cbiAgICAgICAgICAgIC8vYSA9IGRhdGFbaSArIDNdO1xuICAgICAgICAgICAgLy9pZiAoYSA8IGFNaW4pIHsgYU1pbiA9IGE7IH0gZWxzZVxuICAgICAgICAgICAgLy9pZiAoYSA+IGFNYXgpIHsgYU1heCA9IGE7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgMSBsZXZlbCAtIGRvbid0IHJlbWFwXG4gICAgICAgIGlmKCByTWF4ID09PSByTWluICl7IHJNYXggPSAyNTU7IHJNaW4gPSAwOyB9XG4gICAgICAgIGlmKCBnTWF4ID09PSBnTWluICl7IGdNYXggPSAyNTU7IGdNaW4gPSAwOyB9XG4gICAgICAgIGlmKCBiTWF4ID09PSBiTWluICl7IGJNYXggPSAyNTU7IGJNaW4gPSAwOyB9XG5cbiAgICAgICAgdmFyIHJNaWQsIHJHb2FsTWF4LCByR29hbE1pbixcbiAgICAgICAgICAgIGdNaWQsIGdHb2FsTWF4LCBnR29hbE1pbixcbiAgICAgICAgICAgIGJNaWQsIGJHb2FsTWF4LCBiR29hbE1pbjtcblxuICAgICAgICAvLyBJZiB0aGUgZW5oYW5jZW1lbnQgaXMgcG9zaXRpdmUgLSBzdHJldGNoIHRoZSBoaXN0b2dyYW1cbiAgICAgICAgaWYgKCBlbmhhbmNlQW1vdW50ID4gMCApe1xuICAgICAgICAgICAgckdvYWxNYXggPSByTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSByTWF4KTtcbiAgICAgICAgICAgIHJHb2FsTWluID0gck1pbiAtIGVuaGFuY2VBbW91bnQgKiAock1pbiAtIDApO1xuICAgICAgICAgICAgZ0dvYWxNYXggPSBnTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSBnTWF4KTtcbiAgICAgICAgICAgIGdHb2FsTWluID0gZ01pbiAtIGVuaGFuY2VBbW91bnQgKiAoZ01pbiAtIDApO1xuICAgICAgICAgICAgYkdvYWxNYXggPSBiTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSBiTWF4KTtcbiAgICAgICAgICAgIGJHb2FsTWluID0gYk1pbiAtIGVuaGFuY2VBbW91bnQgKiAoYk1pbiAtIDApO1xuICAgICAgICAvLyBJZiB0aGUgZW5oYW5jZW1lbnQgaXMgbmVnYXRpdmUgLSAgIGNvbXByZXNzIHRoZSBoaXN0b2dyYW1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJNaWQgPSAock1heCArIHJNaW4pICogMC41O1xuICAgICAgICAgICAgckdvYWxNYXggPSByTWF4ICsgZW5oYW5jZUFtb3VudCAqIChyTWF4IC0gck1pZCk7XG4gICAgICAgICAgICByR29hbE1pbiA9IHJNaW4gKyBlbmhhbmNlQW1vdW50ICogKHJNaW4gLSByTWlkKTtcbiAgICAgICAgICAgIGdNaWQgPSAoZ01heCArIGdNaW4pICogMC41O1xuICAgICAgICAgICAgZ0dvYWxNYXggPSBnTWF4ICsgZW5oYW5jZUFtb3VudCAqIChnTWF4IC0gZ01pZCk7XG4gICAgICAgICAgICBnR29hbE1pbiA9IGdNaW4gKyBlbmhhbmNlQW1vdW50ICogKGdNaW4gLSBnTWlkKTtcbiAgICAgICAgICAgIGJNaWQgPSAoYk1heCArIGJNaW4pICogMC41O1xuICAgICAgICAgICAgYkdvYWxNYXggPSBiTWF4ICsgZW5oYW5jZUFtb3VudCAqIChiTWF4IC0gYk1pZCk7XG4gICAgICAgICAgICBiR29hbE1pbiA9IGJNaW4gKyBlbmhhbmNlQW1vdW50ICogKGJNaW4gLSBiTWlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhc3MgMiAtIHJlbWFwIGV2ZXJ5dGhpbmcsIGV4Y2VwdCB0aGUgYWxwaGFcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5TdWJQaXhlbHM7IGkgKz0gNCkge1xuICAgICAgICAgICAgZGF0YVtpICsgMF0gPSByZW1hcChkYXRhW2kgKyAwXSwgck1pbiwgck1heCwgckdvYWxNaW4sIHJHb2FsTWF4KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gcmVtYXAoZGF0YVtpICsgMV0sIGdNaW4sIGdNYXgsIGdHb2FsTWluLCBnR29hbE1heCk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHJlbWFwKGRhdGFbaSArIDJdLCBiTWluLCBiTWF4LCBiR29hbE1pbiwgYkdvYWxNYXgpO1xuICAgICAgICAgICAgLy9kYXRhW2kgKyAzXSA9IHJlbWFwKGRhdGFbaSArIDNdLCBhTWluLCBhTWF4LCBhR29hbE1pbiwgYUdvYWxNYXgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdlbmhhbmNlJywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG5cbiAgICAvKipcbiAgICAqIGdldC9zZXQgZW5oYW5jZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuRW5oYW5jZX0gZmlsdGVyLlxuICAgICogQG5hbWUgZW5oYW5jZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0Zsb2F0fSBhbW91bnRcbiAgICAqIEByZXR1cm5zIHtGbG9hdH1cbiAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogUG9zdGVyaXplIEZpbHRlci4gQWRqdXN0cyB0aGUgY2hhbm5lbHMgc28gdGhhdCB0aGVyZSBhcmUgbm8gbW9yZVxuICAgICAqICB0aGFuIG4gZGlmZmVyZW50IHZhbHVlcyBmb3IgdGhhdCBjaGFubmVsLiBUaGlzIGlzIGFsc28gYXBwbGllZFxuICAgICAqICB0byB0aGUgYWxwaGEgY2hhbm5lbC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBQb3N0ZXJpemVcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuUG9zdGVyaXplXSk7XG4gICAgICogbm9kZS5sZXZlbHMoMC44KTsgLy8gYmV0d2VlbiAwIGFuZCAxXG4gICAgICovXG5cbiAgICBLb252YS5GaWx0ZXJzLlBvc3Rlcml6ZSA9IGZ1bmN0aW9uIChpbWFnZURhdGEpIHtcbiAgICAgICAgLy8gbGV2ZWwgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDI1NVxuICAgICAgICB2YXIgbGV2ZWxzID0gTWF0aC5yb3VuZCh0aGlzLmxldmVscygpICogMjU0KSArIDEsXG4gICAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHNjYWxlID0gKDI1NSAvIGxldmVscyksXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGguZmxvb3IoZGF0YVtpXSAvIHNjYWxlKSAqIHNjYWxlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdsZXZlbHMnLCAwLjUsIG51bGwsIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXIpO1xuXG4gICAgLyoqXG4gICAgKiBnZXQvc2V0IGxldmVscy4gIE11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLiAgVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUG9zdGVyaXplfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBsZXZlbHNcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIGJldHdlZW4gMCBhbmQgMVxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vaXNlIEZpbHRlci4gUmFuZG9tbHkgYWRkcyBvciBzdWJzdHJhY3RzIHRvIHRoZSBjb2xvciBjaGFubmVsc1xyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBOb2lzZVxyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcclxuICAgICAqIEBhdXRob3IgaXBwbzYxNVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIG5vZGUuY2FjaGUoKTtcclxuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5Ob2lzZV0pO1xyXG4gICAgICogbm9kZS5ub2lzZSgwLjgpO1xyXG4gICAgICovXHJcbiAgICBLb252YS5GaWx0ZXJzLk5vaXNlID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xyXG4gICAgICAgIHZhciBhbW91bnQgPSB0aGlzLm5vaXNlKCkgKiAyNTUsXHJcbiAgICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcclxuICAgICAgICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBoYWxmID0gYW1vdW50IC8gMixcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAwXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAxXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICBkYXRhW2kgKyAyXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ25vaXNlJywgMC4yLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBub2lzZSBhbW91bnQuICBNdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5Ob2lzZX0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBub2lzZVxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gbm9pc2VcclxuICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICovXHJcbn0pKCk7XHJcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIC8qKlxyXG4gICAgICogUGl4ZWxhdGUgRmlsdGVyLiBBdmVyYWdlcyBncm91cHMgb2YgcGl4ZWxzIGFuZCByZWRyYXdzXHJcbiAgICAgKiAgdGhlbSBhcyBsYXJnZXIgcGl4ZWxzXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBuYW1lIFBpeGVsYXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxyXG4gICAgICogQGF1dGhvciBpcHBvNjE1XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogbm9kZS5jYWNoZSgpO1xyXG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLlBpeGVsYXRlXSk7XHJcbiAgICAgKiBub2RlLnBpeGVsU2l6ZSgxMCk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBLb252YS5GaWx0ZXJzLlBpeGVsYXRlID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xyXG5cclxuICAgICAgICB2YXIgcGl4ZWxTaXplID0gTWF0aC5jZWlsKHRoaXMucGl4ZWxTaXplKCkpLFxyXG4gICAgICAgICAgICB3aWR0aCA9IGltYWdlRGF0YS53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCxcclxuICAgICAgICAgICAgeCwgeSwgaSxcclxuICAgICAgICAgICAgLy9waXhlbHNQZXJCaW4gPSBwaXhlbFNpemUgKiBwaXhlbFNpemUsXHJcbiAgICAgICAgICAgIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhLFxyXG4gICAgICAgICAgICBuQmluc1ggPSBNYXRoLmNlaWwod2lkdGggLyBwaXhlbFNpemUpLFxyXG4gICAgICAgICAgICBuQmluc1kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gcGl4ZWxTaXplKSxcclxuICAgICAgICAgICAgeEJpblN0YXJ0LCB4QmluRW5kLCB5QmluU3RhcnQsIHlCaW5FbmQsXHJcbiAgICAgICAgICAgIHhCaW4sIHlCaW4sIHBpeGVsc0luQmluO1xyXG4gICAgICAgIGltYWdlRGF0YSA9IGltYWdlRGF0YS5kYXRhO1xyXG5cclxuICAgICAgICBpZiAocGl4ZWxTaXplIDw9IDApIHtcclxuICAgICAgICAgICAgS29udmEuVXRpbC5lcnJvcigncGl4ZWxTaXplIHZhbHVlIGNhbiBub3QgYmUgPD0gMCcpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHhCaW4gPSAwOyB4QmluIDwgbkJpbnNYOyB4QmluICs9IDEpIHtcclxuICAgICAgICAgICAgZm9yICh5QmluID0gMDsgeUJpbiA8IG5CaW5zWTsgeUJpbiArPSAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgY29sb3IgYWNjdW1sYXRvcnMgdG8gMFxyXG4gICAgICAgICAgICAgICAgcmVkID0gMDtcclxuICAgICAgICAgICAgICAgIGdyZWVuID0gMDtcclxuICAgICAgICAgICAgICAgIGJsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgYWxwaGEgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBwaXhlbHMgYXJlIGluY2x1ZGVkIGluIHRoaXMgYmluXHJcbiAgICAgICAgICAgICAgICB4QmluU3RhcnQgPSB4QmluICogcGl4ZWxTaXplO1xyXG4gICAgICAgICAgICAgICAgeEJpbkVuZCA9IHhCaW5TdGFydCArIHBpeGVsU2l6ZTtcclxuICAgICAgICAgICAgICAgIHlCaW5TdGFydCA9IHlCaW4gKiBwaXhlbFNpemU7XHJcbiAgICAgICAgICAgICAgICB5QmluRW5kID0geUJpblN0YXJ0ICsgcGl4ZWxTaXplO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgb2YgdGhlIHBpeGVscyB0byB0aGlzIGJpbiFcclxuICAgICAgICAgICAgICAgIHBpeGVsc0luQmluID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoeCA9IHhCaW5TdGFydDsgeCA8IHhCaW5FbmQ7IHggKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCB4ID49IHdpZHRoICl7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh5ID0geUJpblN0YXJ0OyB5IDwgeUJpbkVuZDsgeSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCB5ID49IGhlaWdodCApeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gKHdpZHRoICogeSArIHgpICogNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVkICs9IGltYWdlRGF0YVtpICsgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyZWVuICs9IGltYWdlRGF0YVtpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsdWUgKz0gaW1hZ2VEYXRhW2kgKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEgKz0gaW1hZ2VEYXRhW2kgKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzSW5CaW4gKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjaGFubmVscyBhcmUgYmV0d2VlbiAwLTI1NVxyXG4gICAgICAgICAgICAgICAgcmVkID0gcmVkIC8gcGl4ZWxzSW5CaW47XHJcbiAgICAgICAgICAgICAgICBncmVlbiA9IGdyZWVuIC8gcGl4ZWxzSW5CaW47XHJcbiAgICAgICAgICAgICAgICBibHVlID0gYmx1ZSAvIHBpeGVsc0luQmluO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhpcyBiaW5cclxuICAgICAgICAgICAgICAgIGZvciAoeCA9IHhCaW5TdGFydDsgeCA8IHhCaW5FbmQ7IHggKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCB4ID49IHdpZHRoICl7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh5ID0geUJpblN0YXJ0OyB5IDwgeUJpbkVuZDsgeSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCB5ID49IGhlaWdodCApeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gKHdpZHRoICogeSArIHgpICogNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAwXSA9IHJlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAxXSA9IGdyZWVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGFbaSArIDJdID0gYmx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VEYXRhW2kgKyAzXSA9IGFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdwaXhlbFNpemUnLCA4LCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcclxuXHJcbiAgICAvKipcclxuICAgICogZ2V0L3NldCBwaXhlbCBzaXplLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5QaXhlbGF0ZX0gZmlsdGVyLlxyXG4gICAgKiBAbmFtZSBwaXhlbFNpemVcclxuICAgICogQG1ldGhvZFxyXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcclxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBwaXhlbFNpemVcclxuICAgICogQHJldHVybnMge0ludGVnZXJ9XHJcbiAgICAqL1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKipcclxuICAgICAqIFRocmVzaG9sZCBGaWx0ZXIuIFB1c2hlcyBhbnkgdmFsdWUgYWJvdmUgdGhlIG1pZCBwb2ludCB0b1xyXG4gICAgICogIHRoZSBtYXggYW5kIGFueSB2YWx1ZSBiZWxvdyB0aGUgbWlkIHBvaW50IHRvIHRoZSBtaW4uXHJcbiAgICAgKiAgVGhpcyBhZmZlY3RzIHRoZSBhbHBoYSBjaGFubmVsLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBUaHJlc2hvbGRcclxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXHJcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBub2RlLmNhY2hlKCk7XHJcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuVGhyZXNob2xkXSk7XHJcbiAgICAgKiBub2RlLnRocmVzaG9sZCgwLjEpO1xyXG4gICAgICovXHJcblxyXG4gICAgS29udmEuRmlsdGVycy5UaHJlc2hvbGQgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy50aHJlc2hvbGQoKSAqIDI1NSxcclxuICAgICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxyXG4gICAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcclxuICAgICAgICAgICAgaTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGRhdGFbaV0gPSBkYXRhW2ldIDwgbGV2ZWwgPyAwIDogMjU1O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3RocmVzaG9sZCcsIDAuNSwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIGdldC9zZXQgdGhyZXNob2xkLiAgTXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuVGhyZXNob2xkfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5NYXNrfSBmaWx0ZXIuXHJcbiAgICAqIEBuYW1lIHRocmVzaG9sZFxyXG4gICAgKiBAbWV0aG9kXHJcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkXHJcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAqL1xyXG59KSgpO1xyXG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogU2VwaWEgRmlsdGVyXG4gICAgICogQmFzZWQgb246IFBpeGFzdGljIExpYiAtIFNlcGlhIGZpbHRlciAtIHYwLjEuMFxuICAgICAqIENvcHlyaWdodCAoYykgMjAwOCBKYWNvYiBTZWlkZWxpbiwganNlaWRlbGluQG5paGlsb2dpYy5kaywgaHR0cDovL2Jsb2cubmloaWxvZ2ljLmRrL1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFNlcGlhXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAgICogQGF1dGhvciBKYWNvYiBTZWlkZWxpbiA8anNlaWRlbGluQG5paGlsb2dpYy5kaz5cbiAgICAgKiBAbGljZW5zZSBNUEwgdjEuMSBbaHR0cDovL3d3dy5waXhhc3RpYy5jb20vbGliL2xpY2Vuc2UudHh0XVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5TZXBpYV0pO1xuICAgICAqL1xuICAgIEtvbnZhLkZpbHRlcnMuU2VwaWEgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICB3ID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgICAgeSA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgICB3NCA9IHcgKiA0LFxuICAgICAgICAgICAgb2Zmc2V0WSwgeCwgb2Zmc2V0LCBvciwgb2csIG9iLCByLCBnLCBiO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG9mZnNldFkgPSAoeSAtIDEpICogdzQ7XG4gICAgICAgICAgICB4ID0gdztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXRZICsgKHggLSAxKSAqIDQ7XG5cbiAgICAgICAgICAgICAgICBvciA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBvZyA9IGRhdGFbb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICAgICAgb2IgPSBkYXRhW29mZnNldCArIDJdO1xuXG4gICAgICAgICAgICAgICAgciA9IG9yICogMC4zOTMgKyBvZyAqIDAuNzY5ICsgb2IgKiAwLjE4OTtcbiAgICAgICAgICAgICAgICBnID0gb3IgKiAwLjM0OSArIG9nICogMC42ODYgKyBvYiAqIDAuMTY4O1xuICAgICAgICAgICAgICAgIGIgPSBvciAqIDAuMjcyICsgb2cgKiAwLjUzNCArIG9iICogMC4xMzE7XG5cbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSByID4gMjU1ID8gMjU1IDogcjtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDFdID0gZyA+IDI1NSA/IDI1NSA6IGc7XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IGIgPiAyNTUgPyAyNTUgOiBiO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgM10gPSBkYXRhW29mZnNldCArIDNdO1xuICAgICAgICAgICAgfSB3aGlsZSAoLS14KTtcbiAgICAgICAgfSB3aGlsZSAoLS15KTtcbiAgICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogU29sYXJpemUgRmlsdGVyXG4gICAgICogUGl4YXN0aWMgTGliIC0gU29sYXJpemUgZmlsdGVyIC0gdjAuMS4wXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA4IEphY29iIFNlaWRlbGluLCBqc2VpZGVsaW5AbmloaWxvZ2ljLmRrLCBodHRwOi8vYmxvZy5uaWhpbG9naWMuZGsvXG4gICAgICogTGljZW5zZTogW2h0dHA6Ly93d3cucGl4YXN0aWMuY29tL2xpYi9saWNlbnNlLnR4dF1cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBTb2xhcml6ZVxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5Tb2xhcml6ZV0pO1xuICAgICAqL1xuICAgIEtvbnZhLkZpbHRlcnMuU29sYXJpemUgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgICB3ID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgICAgaCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgICB3NCA9IHcgKiA0LFxuICAgICAgICAgICAgeSA9IGg7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIG9mZnNldFkgPSAoeSAtIDEpICogdzQ7XG4gICAgICAgICAgICB2YXIgeCA9IHc7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldFkgKyAoeCAtIDEpICogNDtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IGRhdGFbb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBkYXRhW29mZnNldCArIDJdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHIgPiAxMjcpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IDI1NSAtIHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnID4gMTI3KSB7XG4gICAgICAgICAgICAgICAgICAgIGcgPSAyNTUgLSBnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYiA+IDEyNykge1xuICAgICAgICAgICAgICAgICAgICBiID0gMjU1IC0gYjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldF0gPSByO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMV0gPSBnO1xuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSBiO1xuICAgICAgICAgICAgfSB3aGlsZSAoLS14KTtcbiAgICAgICAgfSB3aGlsZSAoLS15KTtcbiAgICB9O1xufSkoKTtcblxuXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qXG4gICAqIFRvUG9sYXIgRmlsdGVyLiBDb252ZXJ0cyBpbWFnZSBkYXRhIHRvIHBvbGFyIGNvb3JkaW5hdGVzLiBQZXJmb3Jtc1xuICAgKiAgdypoKjQgcGl4ZWwgcmVhZHMgYW5kIHcqaCBwaXhlbCB3cml0ZXMuIFRoZSByIGF4aXMgaXMgcGxhY2VkIGFsb25nXG4gICAqICB3aGF0IHdvdWxkIGJlIHRoZSB5IGF4aXMgYW5kIHRoZSB0aGV0YSBheGlzIGFsb25nIHRoZSB4IGF4aXMuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtJbWFnZURhdGF9IHNyYywgdGhlIHNvdXJjZSBpbWFnZSBkYXRhICh3aGF0IHdpbGwgYmUgdHJhbnNmb3JtZWQpXG4gICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBkc3QsIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBkYXRhICh3aGVyZSBpdCB3aWxsIGJlIHNhdmVkKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyQ2VudGVyWF0gaG9yaXpvbnRhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxuICAgKiAgZGVmYXVsdCBpcyBpbiB0aGUgbWlkZGxlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyQ2VudGVyWV0gdmVydGljYWwgbG9jYXRpb24gZm9yIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSxcbiAgICogIGRlZmF1bHQgaXMgaW4gdGhlIG1pZGRsZVxuICAgKi9cblxuICAgIHZhciBUb1BvbGFyID0gZnVuY3Rpb24oc3JjLCBkc3QsIG9wdCl7XG5cbiAgICAgICAgdmFyIHNyY1BpeGVscyA9IHNyYy5kYXRhLFxuICAgICAgICAgICAgZHN0UGl4ZWxzID0gZHN0LmRhdGEsXG4gICAgICAgICAgICB4U2l6ZSA9IHNyYy53aWR0aCxcbiAgICAgICAgICAgIHlTaXplID0gc3JjLmhlaWdodCxcbiAgICAgICAgICAgIHhNaWQgPSBvcHQucG9sYXJDZW50ZXJYIHx8IHhTaXplIC8gMixcbiAgICAgICAgICAgIHlNaWQgPSBvcHQucG9sYXJDZW50ZXJZIHx8IHlTaXplIC8gMixcbiAgICAgICAgICAgIGksIHgsIHksIHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIGxhcmdlc3QgcmFkaXVzXG4gICAgICAgIHZhciByYWQsIHJNYXggPSBNYXRoLnNxcnQoIHhNaWQgKiB4TWlkICsgeU1pZCAqIHlNaWQgKTtcbiAgICAgICAgeCA9IHhTaXplIC0geE1pZDtcbiAgICAgICAgeSA9IHlTaXplIC0geU1pZDtcbiAgICAgICAgcmFkID0gTWF0aC5zcXJ0KCB4ICogeCArIHkgKiB5ICk7XG4gICAgICAgIHJNYXggPSAocmFkID4gck1heCkgPyByYWQgOiByTWF4O1xuXG4gICAgICAgIC8vIFdlJ2xsIGJlIHVpc25nIHkgYXMgdGhlIHJhZGl1cywgYW5kIHggYXMgdGhlIGFuZ2xlICh0aGV0YT10KVxuICAgICAgICB2YXIgclNpemUgPSB5U2l6ZSxcbiAgICAgICAgICAgIHRTaXplID0geFNpemUsXG4gICAgICAgICAgICByYWRpdXMsIHRoZXRhO1xuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY292ZXIgYWxsIGFuZ2xlcyAoMC0zNjApIGFuZCB3ZSBuZWVkIHRvIGNvbnZlcnQgdG9cbiAgICAgICAgLy8gcmFkaWFucyAoKlBJLzE4MClcbiAgICAgICAgdmFyIGNvbnZlcnNpb24gPSAzNjAgLyB0U2l6ZSAqIE1hdGguUEkgLyAxODAsIHNpbiwgY29zO1xuXG4gICAgICAgIC8vIHZhciB4MSwgeDIsIHgxaSwgeDJpLCB5MSwgeTIsIHkxaSwgeTJpLCBzY2FsZTtcblxuICAgICAgICBmb3IoIHRoZXRhID0gMDsgdGhldGEgPCB0U2l6ZTsgdGhldGEgKz0gMSApe1xuICAgICAgICAgICAgc2luID0gTWF0aC5zaW4odGhldGEgKiBjb252ZXJzaW9uKTtcbiAgICAgICAgICAgIGNvcyA9IE1hdGguY29zKHRoZXRhICogY29udmVyc2lvbik7XG4gICAgICAgICAgICBmb3IoIHJhZGl1cyA9IDA7IHJhZGl1cyA8IHJTaXplOyByYWRpdXMgKz0gMSApe1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKHhNaWQgKyByTWF4ICogcmFkaXVzIC8gclNpemUgKiBjb3MpO1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLmZsb29yKHlNaWQgKyByTWF4ICogcmFkaXVzIC8gclNpemUgKiBzaW4pO1xuICAgICAgICAgICAgICAgIGkgPSAoeSAqIHhTaXplICsgeCkgKiA0O1xuICAgICAgICAgICAgICAgIHIgPSBzcmNQaXhlbHNbaSArIDBdO1xuICAgICAgICAgICAgICAgIGcgPSBzcmNQaXhlbHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGIgPSBzcmNQaXhlbHNbaSArIDJdO1xuICAgICAgICAgICAgICAgIGEgPSBzcmNQaXhlbHNbaSArIDNdO1xuXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgaXRcbiAgICAgICAgICAgICAgICAvL2kgPSAodGhldGEgKiB4U2l6ZSAgKyAgcmFkaXVzKSAqIDQ7XG4gICAgICAgICAgICAgICAgaSA9ICh0aGV0YSArIHJhZGl1cyAqIHhTaXplKSAqIDQ7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAwXSA9IHI7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAxXSA9IGc7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAzXSA9IGE7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEZyb21Qb2xhciBGaWx0ZXIuIENvbnZlcnRzIGltYWdlIGRhdGEgZnJvbSBwb2xhciBjb29yZGluYXRlcyBiYWNrIHRvIHJlY3Rhbmd1bGFyLlxuICAgICAqICBQZXJmb3JtcyB3KmgqNCBwaXhlbCByZWFkcyBhbmQgdypoIHBpeGVsIHdyaXRlcy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBzcmMsIHRoZSBzb3VyY2UgaW1hZ2UgZGF0YSAod2hhdCB3aWxsIGJlIHRyYW5zZm9ybWVkKVxuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBkc3QsIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBkYXRhICh3aGVyZSBpdCB3aWxsIGJlIHNhdmVkKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5wb2xhckNlbnRlclhdIGhvcml6b250YWwgbG9jYXRpb24gZm9yIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSxcbiAgICAgKiAgZGVmYXVsdCBpcyBpbiB0aGUgbWlkZGxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHQucG9sYXJDZW50ZXJZXSB2ZXJ0aWNhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxuICAgICAqICBkZWZhdWx0IGlzIGluIHRoZSBtaWRkbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5wb2xhclJvdGF0aW9uXSBhbW91bnQgdG8gcm90YXRlIHRoZSBpbWFnZSBjb3VudGVyY2xvY2t3aXMsXG4gICAgICogIDAgaXMgbm8gcm90YXRpb24sIDM2MCBkZWdyZWVzIGlzIGEgZnVsbCByb3RhdGlvblxuICAgICAqL1xuXG4gICAgdmFyIEZyb21Qb2xhciA9IGZ1bmN0aW9uKHNyYywgZHN0LCBvcHQpe1xuXG4gICAgICAgIHZhciBzcmNQaXhlbHMgPSBzcmMuZGF0YSxcbiAgICAgICAgICAgIGRzdFBpeGVscyA9IGRzdC5kYXRhLFxuICAgICAgICAgICAgeFNpemUgPSBzcmMud2lkdGgsXG4gICAgICAgICAgICB5U2l6ZSA9IHNyYy5oZWlnaHQsXG4gICAgICAgICAgICB4TWlkID0gb3B0LnBvbGFyQ2VudGVyWCB8fCB4U2l6ZSAvIDIsXG4gICAgICAgICAgICB5TWlkID0gb3B0LnBvbGFyQ2VudGVyWSB8fCB5U2l6ZSAvIDIsXG4gICAgICAgICAgICBpLCB4LCB5LCBkeCwgZHksIHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwO1xuXG5cbiAgICAgICAgLy8gRmluZCB0aGUgbGFyZ2VzdCByYWRpdXNcbiAgICAgICAgdmFyIHJhZCwgck1heCA9IE1hdGguc3FydCggeE1pZCAqIHhNaWQgKyB5TWlkICogeU1pZCApO1xuICAgICAgICB4ID0geFNpemUgLSB4TWlkO1xuICAgICAgICB5ID0geVNpemUgLSB5TWlkO1xuICAgICAgICByYWQgPSBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKTtcbiAgICAgICAgck1heCA9IChyYWQgPiByTWF4KSA/IHJhZCA6IHJNYXg7XG5cbiAgICAgICAgLy8gV2UnbGwgYmUgdWlzbmcgeCBhcyB0aGUgcmFkaXVzLCBhbmQgeSBhcyB0aGUgYW5nbGUgKHRoZXRhPXQpXG4gICAgICAgIHZhciByU2l6ZSA9IHlTaXplLFxuICAgICAgICB0U2l6ZSA9IHhTaXplLFxuICAgICAgICByYWRpdXMsIHRoZXRhLFxuICAgICAgICBwaGFzZVNoaWZ0ID0gb3B0LnBvbGFyUm90YXRpb24gfHwgMDtcblxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQgdG8gZGVncmVlcyBhbmQgd2UgbmVlZCB0byBtYWtlIHN1cmVcbiAgICAgICAgLy8gaXQncyBiZXR3ZWVuICgwLTM2MClcbiAgICAgICAgLy8gdmFyIGNvbnZlcnNpb24gPSB0U2l6ZS8zNjAqMTgwL01hdGguUEk7XG4gICAgICAgIC8vdmFyIGNvbnZlcnNpb24gPSB0U2l6ZS8zNjAqMTgwL01hdGguUEk7XG5cbiAgICAgICAgdmFyIHgxLCB5MTtcblxuICAgICAgICBmb3IoIHggPSAwOyB4IDwgeFNpemU7IHggKz0gMSApe1xuICAgICAgICAgICAgZm9yKCB5ID0gMDsgeSA8IHlTaXplOyB5ICs9IDEgKXtcbiAgICAgICAgICAgICAgICBkeCA9IHggLSB4TWlkO1xuICAgICAgICAgICAgICAgIGR5ID0geSAtIHlNaWQ7XG4gICAgICAgICAgICAgICAgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSAqIHJTaXplIC8gck1heDtcbiAgICAgICAgICAgICAgICB0aGV0YSA9IChNYXRoLmF0YW4yKGR5LCBkeCkgKiAxODAgLyBNYXRoLlBJICsgMzYwICsgcGhhc2VTaGlmdCkgJSAzNjA7XG4gICAgICAgICAgICAgICAgdGhldGEgPSB0aGV0YSAqIHRTaXplIC8gMzYwO1xuICAgICAgICAgICAgICAgIHgxID0gTWF0aC5mbG9vcih0aGV0YSk7XG4gICAgICAgICAgICAgICAgeTEgPSBNYXRoLmZsb29yKHJhZGl1cyk7XG4gICAgICAgICAgICAgICAgaSA9ICh5MSAqIHhTaXplICsgeDEpICogNDtcbiAgICAgICAgICAgICAgICByID0gc3JjUGl4ZWxzW2kgKyAwXTtcbiAgICAgICAgICAgICAgICBnID0gc3JjUGl4ZWxzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBiID0gc3JjUGl4ZWxzW2kgKyAyXTtcbiAgICAgICAgICAgICAgICBhID0gc3JjUGl4ZWxzW2kgKyAzXTtcblxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGl0XG4gICAgICAgICAgICAgICAgaSA9ICh5ICogeFNpemUgKyB4KSAqIDQ7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAwXSA9IHI7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAxXSA9IGc7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxzW2kgKyAzXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvL0tvbnZhLkZpbHRlcnMuVG9Qb2xhciA9IEtvbnZhLlV0aWwuX0ZpbHRlcldyYXBEb3VibGVCdWZmZXIoVG9Qb2xhcik7XG4gICAgLy9Lb252YS5GaWx0ZXJzLkZyb21Qb2xhciA9IEtvbnZhLlV0aWwuX0ZpbHRlcldyYXBEb3VibGVCdWZmZXIoRnJvbVBvbGFyKTtcblxuICAgIC8vIGNyZWF0ZSBhIHRlbXBvcmFyeSBjYW52YXMgZm9yIHdvcmtpbmcgLSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBjYWxsc1xuICAgIHZhciB0ZW1wQ2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG5cbiAgICAvKlxuICAgICAqIEthbGVpZG9zY29wZSBGaWx0ZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgS2FsZWlkb3Njb3BlXG4gICAgICogQGF1dGhvciBpcHBvNjE1XG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuS2FsZWlkb3Njb3BlXSk7XG4gICAgICogbm9kZS5rYWxlaWRvc2NvcGVQb3dlcigzKTtcbiAgICAgKiBub2RlLmthbGVpZG9zY29wZUFuZ2xlKDQ1KTtcbiAgICAgKi9cbiAgICBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSl7XG4gICAgICAgIHZhciB4U2l6ZSA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICAgIHlTaXplID0gaW1hZ2VEYXRhLmhlaWdodDtcblxuICAgICAgICB2YXIgeCwgeSwgeG9mZiwgaSwgciwgZywgYiwgYSwgc3JjUG9zLCBkc3RQb3M7XG4gICAgICAgIHZhciBwb3dlciA9IE1hdGgucm91bmQoIHRoaXMua2FsZWlkb3Njb3BlUG93ZXIoKSApO1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLnJvdW5kKCB0aGlzLmthbGVpZG9zY29wZUFuZ2xlKCkgKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IE1hdGguZmxvb3IoeFNpemUgKiAoYW5nbGUgJSAzNjApIC8gMzYwKTtcblxuICAgICAgICBpZiggcG93ZXIgPCAxICl7cmV0dXJuOyB9XG5cbiAgICAgICAgLy8gV29yayB3aXRoIG91ciBzaGFyZWQgYnVmZmVyIGNhbnZhc1xuICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0geFNpemU7XG4gICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0geVNpemU7XG4gICAgICAgIHZhciBzY3JhdGNoRGF0YSA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgeFNpemUsIHlTaXplKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRoaGUgb3JpZ2luYWwgdG8gcG9sYXIgY29vcmRpbmF0ZXNcbiAgICAgICAgVG9Qb2xhciggaW1hZ2VEYXRhLCBzY3JhdGNoRGF0YSwge1xuICAgICAgICAgICAgcG9sYXJDZW50ZXJYOiB4U2l6ZSAvIDIsXG4gICAgICAgICAgICBwb2xhckNlbnRlclk6IHlTaXplIC8gMlxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgaG93IGJpZyBlYWNoIHNlY3Rpb24gd2lsbCBiZSwgaWYgaXQncyB0b28gc21hbGxcbiAgICAgICAgLy8gbWFrZSBpdCBiaWdnZXJcbiAgICAgICAgdmFyIG1pblNlY3Rpb25TaXplID0geFNpemUgLyBNYXRoLnBvdygyLCBwb3dlcik7XG4gICAgICAgIHdoaWxlKCBtaW5TZWN0aW9uU2l6ZSA8PSA4KXtcbiAgICAgICAgICAgIG1pblNlY3Rpb25TaXplID0gbWluU2VjdGlvblNpemUgKiAyO1xuICAgICAgICAgICAgcG93ZXIgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBtaW5TZWN0aW9uU2l6ZSA9IE1hdGguY2VpbChtaW5TZWN0aW9uU2l6ZSk7XG4gICAgICAgIHZhciBzZWN0aW9uU2l6ZSA9IG1pblNlY3Rpb25TaXplO1xuXG4gICAgICAgIC8vIENvcHkgdGhlIG9mZnNldCByZWdpb24gdG8gMFxuICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgZmlsdGVyIGFuZCBsb2NhdGlvbiBvZiB0aGUgb2Zmc2V0IHdlIG1heSBuZWVkXG4gICAgICAgIC8vIHRvIGNvcHkgdGhlIHNlY3Rpb24gYmFja3dhcmRzIHRvIHByZXZlbnQgaXQgZnJvbSByZXdyaXRpbmcgaXRzZWxmXG4gICAgICAgIHZhciB4U3RhcnQgPSAwLFxuICAgICAgICAgIHhFbmQgPSBzZWN0aW9uU2l6ZSxcbiAgICAgICAgICB4RGVsdGEgPSAxO1xuICAgICAgICBpZiggb2Zmc2V0ICsgbWluU2VjdGlvblNpemUgPiB4U2l6ZSApe1xuICAgICAgICAgICAgeFN0YXJ0ID0gc2VjdGlvblNpemU7XG4gICAgICAgICAgICB4RW5kID0gMDtcbiAgICAgICAgICAgIHhEZWx0YSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGZvciggeSA9IDA7IHkgPCB5U2l6ZTsgeSArPSAxICl7XG4gICAgICAgICAgICBmb3IoIHggPSB4U3RhcnQ7IHggIT09IHhFbmQ7IHggKz0geERlbHRhICl7XG4gICAgICAgICAgICAgICAgeG9mZiA9IE1hdGgucm91bmQoeCArIG9mZnNldCkgJSB4U2l6ZTtcbiAgICAgICAgICAgICAgICBzcmNQb3MgPSAoeFNpemUgKiB5ICsgeG9mZikgKiA0O1xuICAgICAgICAgICAgICAgIHIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDBdO1xuICAgICAgICAgICAgICAgIGcgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDFdO1xuICAgICAgICAgICAgICAgIGIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDJdO1xuICAgICAgICAgICAgICAgIGEgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDNdO1xuICAgICAgICAgICAgICAgIGRzdFBvcyA9ICh4U2l6ZSAqIHkgKyB4KSAqIDQ7XG4gICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAwXSA9IHI7XG4gICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAxXSA9IGc7XG4gICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAzXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSBhY3R1YWwgZWZmZWN0XG4gICAgICAgIGZvciggeSA9IDA7IHkgPCB5U2l6ZTsgeSArPSAxICl7XG4gICAgICAgICAgICBzZWN0aW9uU2l6ZSA9IE1hdGguZmxvb3IoIG1pblNlY3Rpb25TaXplICk7XG4gICAgICAgICAgICBmb3IoIGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gMSApe1xuICAgICAgICAgICAgICAgIGZvciggeCA9IDA7IHggPCBzZWN0aW9uU2l6ZSArIDE7IHggKz0gMSApe1xuICAgICAgICAgICAgICAgICAgICBzcmNQb3MgPSAoeFNpemUgKiB5ICsgeCkgKiA0O1xuICAgICAgICAgICAgICAgICAgICByID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAwXTtcbiAgICAgICAgICAgICAgICAgICAgZyA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDJdO1xuICAgICAgICAgICAgICAgICAgICBhID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgZHN0UG9zID0gKHhTaXplICogeSArIHNlY3Rpb25TaXplICogMiAtIHggLSAxKSAqIDQ7XG4gICAgICAgICAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMF0gPSByO1xuICAgICAgICAgICAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDFdID0gZztcbiAgICAgICAgICAgICAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgM10gPSBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWN0aW9uU2l6ZSAqPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCBiYWNrIGZyb20gcG9sYXIgY29vcmRpbmF0ZXNcbiAgICAgICAgRnJvbVBvbGFyKHNjcmF0Y2hEYXRhLCBpbWFnZURhdGEsIHtwb2xhclJvdGF0aW9uOiAwfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICogZ2V0L3NldCBrYWxlaWRvc2NvcGUgcG93ZXIuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZX0gZmlsdGVyLlxuICAgICogQG5hbWUga2FsZWlkb3Njb3BlUG93ZXJcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtJbnRlZ2VyfSBwb3dlciBvZiBrYWxlaWRvc2NvcGVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2thbGVpZG9zY29wZVBvd2VyJywgMiwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG5cbiAgICAvKipcbiAgICAqIGdldC9zZXQga2FsZWlkb3Njb3BlIGFuZ2xlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5LYWxlaWRvc2NvcGV9IGZpbHRlci5cbiAgICAqIEBuYW1lIGthbGVpZG9zY29wZUFuZ2xlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZGVncmVlc1xuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAna2FsZWlkb3Njb3BlQW5nbGUnLCAwLCBudWxsLCBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyKTtcblxufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBDb250YWluZXIgY29uc3RydWN0b3IuJm5ic3A7IENvbnRhaW5lcnMgYXJlIHVzZWQgdG8gY29udGFpbiBub2RlcyBvciBvdGhlciBjb250YWluZXJzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLk5vZGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNsaXBGdW5jXSBzZXQgY2xpcCBmdW5jXG5cbiAgICAgKi9cbiAgICBLb252YS5Db250YWluZXIgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLkNvbnRhaW5lciwge1xuICAgICAgICBfX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCk7XG4gICAgICAgICAgICBLb252YS5Ob2RlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybnMgYSB7QGxpbmsgS29udmEuQ29sbGVjdGlvbn0gb2YgZGlyZWN0IGRlc2NlbmRhbnQgbm9kZXNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZmlsdGVyRnVuY10gZmlsdGVyIGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Db2xsZWN0aW9ufVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiAvLyBnZXQgYWxsIGNoaWxkcmVuXG4gICAgICAgICAqIHZhciBjaGlsZHJlbiA9IGxheWVyLmdldENoaWxkcmVuKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIGdldCBvbmx5IGNpcmNsZXNcbiAgICAgICAgICogdmFyIGNpcmNsZXMgPSBsYXllci5nZXRDaGlsZHJlbihmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICogICAgcmV0dXJuIG5vZGUuZ2V0Q2xhc3NOYW1lKCkgPT09ICdDaXJjbGUnO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIGdldENoaWxkcmVuOiBmdW5jdGlvbihmaWx0ZXJGdW5jKSB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlckZ1bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgS29udmEuQ29sbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKXtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRnVuYyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZGV0ZXJtaW5lIGlmIG5vZGUgaGFzIGNoaWxkcmVuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBoYXNDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpLmxlbmd0aCA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmUgYWxsIGNoaWxkcmVuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IEtvbnZhLkNvbGxlY3Rpb24udG9Db2xsZWN0aW9uKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgcGFyZW50IHRvIHByZXZlbnQgbWFueSBfc2V0Q2hpbGRyZW5JbmRpY2VzIGNhbGxzXG4gICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcbiAgICAgICAgICAgICAgICBjaGlsZC5pbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZGVzdHJveSBhbGwgY2hpbGRyZW5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gS29udmEuQ29sbGVjdGlvbi50b0NvbGxlY3Rpb24odGhpcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAvLyByZXNldCBwYXJlbnQgdG8gcHJldmVudCBtYW55IF9zZXRDaGlsZHJlbkluZGljZXMgY2FsbHNcbiAgICAgICAgICAgICAgICBkZWxldGUgY2hpbGQucGFyZW50O1xuICAgICAgICAgICAgICAgIGNoaWxkLmluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIG5vZGUgb3Igbm9kZXMgdG8gY29udGFpbmVyLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7Li4uS29udmEuTm9kZX0gY2hpbGRcbiAgICAgICAgICogQHJldHVybnMge0NvbnRhaW5lcn1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogbGF5ZXIuYWRkKHNoYXBlMSwgc2hhcGUyLCBzaGFwZTMpO1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGQuZ2V0UGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5tb3ZlVG8odGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVBZGQoY2hpbGQpO1xuICAgICAgICAgICAgY2hpbGQuaW5kZXggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB0aGlzLl9maXJlKCdhZGQnLCB7XG4gICAgICAgICAgICAgICAgY2hpbGQ6IGNoaWxkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gaWYgbm9kZSB1bmRlciBkcmFnIHdlIG5lZWQgdG8gdXBkYXRlIGRyYWcgYW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAoS29udmEuREQgJiYgY2hpbGQuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgS29udmEuREQuYW5pbS5zZXRMYXllcnMoY2hpbGQuZ2V0TGF5ZXIoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoYWluYWJsZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gZGVzdHJveSBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUNoaWxkcmVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGVuIGRlc3Ryb3kgc2VsZlxuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gYSB7QGxpbmsgS29udmEuQ29sbGVjdGlvbn0gb2Ygbm9kZXMgdGhhdCBtYXRjaCB0aGUgc2VsZWN0b3IuICBVc2UgJyMnIGZvciBpZCBzZWxlY3Rpb25zXG4gICAgICAgICAqIGFuZCAnLicgZm9yIG5hbWUgc2VsZWN0aW9ucy4gIFlvdSBjYW4gYWxzbyBzZWxlY3QgYnkgdHlwZSBvciBjbGFzcyBuYW1lLiBQYXNzIG11bHRpcGxlIHNlbGVjdG9yc1xuICAgICAgICAgKiBzZXBhcmF0ZWQgYnkgYSBzcGFjZS5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAgICAgICAgICogQHJldHVybnMge0NvbGxlY3Rpb259XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIHNlbGVjdCBub2RlIHdpdGggaWQgZm9vXG4gICAgICAgICAqIHZhciBub2RlID0gc3RhZ2UuZmluZCgnI2ZvbycpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBzZWxlY3Qgbm9kZXMgd2l0aCBuYW1lIGJhciBpbnNpZGUgbGF5ZXJcbiAgICAgICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnLmJhcicpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAvLyBzZWxlY3QgYWxsIGdyb3VwcyBpbnNpZGUgbGF5ZXJcbiAgICAgICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnR3JvdXAnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogLy8gc2VsZWN0IGFsbCByZWN0YW5nbGVzIGluc2lkZSBsYXllclxuICAgICAgICAgKiB2YXIgbm9kZXMgPSBsYXllci5maW5kKCdSZWN0Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHNlbGVjdCBub2RlIHdpdGggYW4gaWQgb2YgZm9vIG9yIGEgbmFtZSBvZiBiYXIgaW5zaWRlIGxheWVyXG4gICAgICAgICAqIHZhciBub2RlcyA9IGxheWVyLmZpbmQoJyNmb28sIC5iYXInKTtcbiAgICAgICAgICovXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgcmV0QXJyID0gW10sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JBcnIgPSBzZWxlY3Rvci5yZXBsYWNlKC8gL2csICcnKS5zcGxpdCgnLCcpLFxuICAgICAgICAgICAgICAgIGxlbiA9IHNlbGVjdG9yQXJyLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBuLCBpLCBzZWwsIGFyciwgbm9kZSwgY2hpbGRyZW4sIGNsZW47XG5cbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIHNlbCA9IHNlbGVjdG9yQXJyW25dO1xuICAgICAgICAgICAgICAgIGlmICghS29udmEuVXRpbC5pc1ZhbGlkU2VsZWN0b3Ioc2VsKSkge1xuICAgICAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ1NlbGVjdG9yIFwiJyArIHNlbCArICdcIiBpcyBpbnZhbGlkLiBBbGxvd2VkIHNlbGVjdG9ycyBleGFtcGxlcyBhcmUgXCIjZm9vXCIsIFwiLmJhclwiIG9yIFwiR3JvdXBcIi4nKTtcbiAgICAgICAgICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdJZiB5b3UgaGF2ZSBhIGN1c3RvbSBzaGFwZSB3aXRoIHN1Y2ggY2xhc3NOYW1lLCBwbGVhc2UgY2hhbmdlIGl0IHRvIHN0YXJ0IHdpdGggdXBwZXIgbGV0dGVyIGxpa2UgXCJUcmlhbmdsZVwiLicpO1xuICAgICAgICAgICAgICAgICAgICBLb252YS5VdGlsLndhcm4oJ0tvbnZhIGlzIGF3ZXNvbWUsIHJpZ2h0PycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZCBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGlmKHNlbC5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5fZ2V0Tm9kZUJ5SWQoc2VsLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0QXJyLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc2VsLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyciA9IHRoaXMuX2dldE5vZGVzQnlOYW1lKHNlbC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldEFyciA9IHJldEFyci5jb25jYXQoYXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdW5yZWNvZ25pemVkIHNlbGVjdG9yLCBwYXNzIHRvIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgICAgICBjbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBjbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldEFyciA9IHJldEFyci5jb25jYXQoY2hpbGRyZW5baV0uX2dldChzZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIEtvbnZhLkNvbGxlY3Rpb24udG9Db2xsZWN0aW9uKHJldEFycik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gYSBmaXJzdCBub2RlIGZyb20gYGZpbmRgIG1ldGhvZFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogLy8gc2VsZWN0IG5vZGUgd2l0aCBpZCBmb29cbiAgICAgICAgICogdmFyIG5vZGUgPSBzdGFnZS5maW5kT25lKCcjZm9vJyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIC8vIHNlbGVjdCBub2RlIHdpdGggbmFtZSBiYXIgaW5zaWRlIGxheWVyXG4gICAgICAgICAqIHZhciBub2RlcyA9IGxheWVyLmZpbmRPbmUoJy5iYXInKTtcbiAgICAgICAgICovXG4gICAgICAgIGZpbmRPbmU6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kKHNlbGVjdG9yKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldE5vZGVCeUlkOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gS29udmEuaWRzW2tleV07XG5cbiAgICAgICAgICAgIGlmKG5vZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmlzQW5jZXN0b3JPZihub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXROb2Rlc0J5TmFtZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gS29udmEubmFtZXNba2V5XSB8fCBbXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXREZXNjZW5kYW50cyhhcnIpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0OiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgdmFyIHJldEFyciA9IEtvbnZhLk5vZGUucHJvdG90eXBlLl9nZXQuY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKHZhciBuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgcmV0QXJyID0gcmV0QXJyLmNvbmNhdChjaGlsZHJlbltuXS5fZ2V0KHNlbGVjdG9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBleHRlbmRlcnNcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IEtvbnZhLk5vZGUucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIG9iai5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKHZhciBuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbl07XG4gICAgICAgICAgICAgICAgb2JqLmNoaWxkcmVuLnB1c2goY2hpbGQudG9PYmplY3QoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXREZXNjZW5kYW50czogZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgICB2YXIgcmV0QXJyID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gYXJyW25dO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaXNBbmNlc3Rvck9mKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldEFyci5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBub2RlIGlzIGFuIGFuY2VzdG9yXG4gICAgICAgICAqIG9mIGRlc2NlbmRhbnRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLk5vZGV9IG5vZGVcbiAgICAgICAgICovXG4gICAgICAgIGlzQW5jZXN0b3JPZjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICB3aGlsZShwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZihwYXJlbnQuX2lkID09PSB0aGlzLl9pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgbWV0aG9kXG4gICAgICAgICAgICB2YXIgbm9kZSA9IEtvbnZhLk5vZGUucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcywgb2JqKTtcblxuICAgICAgICAgICAgdGhpcy5nZXRDaGlsZHJlbigpLmVhY2goZnVuY3Rpb24obm8pIHtcbiAgICAgICAgICAgICAgICBub2RlLmFkZChuby5jbG9uZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgYWxsIHNoYXBlcyB0aGF0IGludGVyc2VjdCBhIHBvaW50LiAgTm90ZTogYmVjYXVzZSB0aGlzIG1ldGhvZCBtdXN0IGNsZWFyIGEgdGVtcG9yYXJ5XG4gICAgICAgICAqIGNhbnZhcyBhbmQgcmVkcmF3IGV2ZXJ5IHNoYXBlIGluc2lkZSB0aGUgY29udGFpbmVyLCBpdCBzaG91bGQgb25seSBiZSB1c2VkIGZvciBzcGVjaWFsIHNpdGF0aW9uc1xuICAgICAgICAgKiBiZWNhdXNlIGl0IHBlcmZvcm1zIHZlcnkgcG9vcmx5LiAgUGxlYXNlIHVzZSB0aGUge0BsaW5rIEtvbnZhLlN0YWdlI2dldEludGVyc2VjdGlvbn0gbWV0aG9kIGlmIGF0IGFsbCBwb3NzaWJsZVxuICAgICAgICAgKiBiZWNhdXNlIGl0IHBlcmZvcm1zIG11Y2ggYmV0dGVyXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2Ygc2hhcGVzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRBbGxJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcblxuICAgICAgICAgICAgdGhpcy5maW5kKCdTaGFwZScpLmVhY2goZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgICAgICBpZihzaGFwZS5pc1Zpc2libGUoKSAmJiBzaGFwZS5pbnRlcnNlY3RzKHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0Q2hpbGRyZW5JbmRpY2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZWFjaChmdW5jdGlvbihjaGlsZCwgbikge1xuICAgICAgICAgICAgICAgIGNoaWxkLmluZGV4ID0gbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbiwgdG9wLCBjYWNoaW5nKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5nZXRDYW52YXMoKSksXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgICAgICAgICBjYWNoZWRTY2VuZUNhbnZhcyA9IGNhY2hlZENhbnZhcyAmJiBjYWNoZWRDYW52YXMuc2NlbmU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoaW5nICYmIGNhY2hlZFNjZW5lQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZFNjZW5lQ2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdDaGlsZHJlbihjYW52YXMsICdkcmF3U2NlbmUnLCB0b3AsIGZhbHNlLCBjYWNoaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZHJhd0hpdDogZnVuY3Rpb24oY2FuLCB0b3AsIGNhY2hpbmcpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmhpdENhbnZhcyksXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgICAgICAgICBjYWNoZWRIaXRDYW52YXMgPSBjYWNoZWRDYW52YXMgJiYgY2FjaGVkQ2FudmFzLmhpdDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkRHJhd0hpdChjYW52YXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmNsZWFySGl0Q2FjaGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoaW5nICYmIGNhY2hlZEhpdENhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdDYWNoZWRIaXRDYW52YXMoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NoaWxkcmVuKGNhbnZhcywgJ2RyYXdIaXQnLCB0b3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBfZHJhd0NoaWxkcmVuOiBmdW5jdGlvbihjYW52YXMsIGRyYXdNZXRob2QsIHRvcCwgY2FjaGluZywgc2tpcEJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgICAgICBjbGlwV2lkdGggPSB0aGlzLmdldENsaXBXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGNsaXBIZWlnaHQgPSB0aGlzLmdldENsaXBIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBjbGlwRnVuYyA9IHRoaXMuZ2V0Q2xpcEZ1bmMoKSxcbiAgICAgICAgICAgICAgICBoYXNDbGlwID0gY2xpcFdpZHRoICYmIGNsaXBIZWlnaHQgfHwgY2xpcEZ1bmMsXG4gICAgICAgICAgICAgICAgY2xpcFgsIGNsaXBZO1xuXG4gICAgICAgICAgICBpZiAoaGFzQ2xpcCAmJiBsYXllcikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChjbGlwRnVuYykge1xuICAgICAgICAgICAgICAgICAgY2xpcEZ1bmMuY2FsbCh0aGlzLCBjb250ZXh0LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY2xpcFggPSB0aGlzLmdldENsaXBYKCk7XG4gICAgICAgICAgICAgICAgICBjbGlwWSA9IHRoaXMuZ2V0Q2xpcFkoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVjdChjbGlwWCwgY2xpcFksIGNsaXBXaWR0aCwgY2xpcEhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRbZHJhd01ldGhvZF0oY2FudmFzLCB0b3AsIGNhY2hpbmcsIHNraXBCdWZmZXIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDbGlwKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZERyYXdIaXQ6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XG4gICAgICAgICAgICB2YXIgbGF5ZXJVbmRlckRyYWcgPSBkZCAmJiBLb252YS5pc0RyYWdnaW5nKCkgJiYgKEtvbnZhLkRELmFuaW0uZ2V0TGF5ZXJzKCkuaW5kZXhPZihsYXllcikgIT09IC0xKTtcbiAgICAgICAgICAgIHJldHVybiAoY2FudmFzICYmIGNhbnZhcy5pc0NhY2hlKSB8fCAobGF5ZXIgJiYgbGF5ZXIuaGl0R3JhcGhFbmFibGVkKCkpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5pc1Zpc2libGUoKSAmJiAhbGF5ZXJVbmRlckRyYWc7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENsaWVudFJlY3Q6IGZ1bmN0aW9uKHNraXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuICAgICAgICAgICAgdmFyIHNlbGZSZWN0ID0ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGNoaWxkLmdldENsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgIC8vIHNraXAgaW52aXNpYmxlIGNoaWxkcmVuIChsaWtlIGVtcHR5IGdyb3VwcylcbiAgICAgICAgICAgICAgICAvLyBvciBkb24ndCBza2lwLi4uIGhtbW0uLi5cbiAgICAgICAgICAgICAgICAvLyBpZiAocmVjdC53aWR0aCA9PT0gMCAmJiByZWN0LmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1pblggPT09IHVuZGVmaW5lZCkgeyAvLyBpbml0aWFsIHZhbHVlIGZvciBmaXJzdCBjaGlsZFxuICAgICAgICAgICAgICAgICAgICBtaW5YID0gcmVjdC54O1xuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gcmVjdC55O1xuICAgICAgICAgICAgICAgICAgICBtYXhYID0gcmVjdC54ICsgcmVjdC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCByZWN0LngpO1xuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcmVjdC55KTtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHJlY3QueCArIHJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGZSZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBtaW5YLFxuICAgICAgICAgICAgICAgICAgICB5OiBtaW5ZLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNraXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRSZWN0KHNlbGZSZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxmUmVjdDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQ29udGFpbmVyLCBLb252YS5Ob2RlKTtcbiAgICAvLyBkZXByZWNhdGVkIG1ldGhvZHNcbiAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmdldCA9IEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZmluZDtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuQ29udGFpbmVyLCAnY2xpcCcsIFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsaXBcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG5hbWUgY2xpcFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2xpcC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAueVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjbGlwLndpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAuaGVpZ2h0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbGlwXG4gICAgICogdmFyIGNsaXAgPSBjb250YWluZXIuY2xpcCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNsaXBcbiAgICAgKiBjb250YWluZXIuc2V0Q2xpcCh7XG4gICAgICogICB4OiAyMCxcbiAgICAgKiAgIHk6IDIwLFxuICAgICAqICAgd2lkdGg6IDIwLFxuICAgICAqICAgaGVpZ2h0OiAyMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQ29udGFpbmVyLCAnY2xpcFgnKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsaXAgeFxuICAgICAqIEBuYW1lIGNsaXBYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNsaXAgeFxuICAgICAqIHZhciBjbGlwWCA9IGNvbnRhaW5lci5jbGlwWCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNsaXAgeFxuICAgICAqIGNvbnRhaW5lci5jbGlwWCgxMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwWScpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY2xpcCB5XG4gICAgICogQG5hbWUgY2xpcFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xpcCB5XG4gICAgICogdmFyIGNsaXBZID0gY29udGFpbmVyLmNsaXBZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY2xpcCB5XG4gICAgICogY29udGFpbmVyLmNsaXBZKDEwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBXaWR0aCcpO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY2xpcCB3aWR0aFxuICAgICAqIEBuYW1lIGNsaXBXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xpcCB3aWR0aFxuICAgICAqIHZhciBjbGlwV2lkdGggPSBjb250YWluZXIuY2xpcFdpZHRoKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY2xpcCB3aWR0aFxuICAgICAqIGNvbnRhaW5lci5jbGlwV2lkdGgoMTAwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBIZWlnaHQnKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsaXAgaGVpZ2h0XG4gICAgICogQG5hbWUgY2xpcEhlaWdodFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNsaXAgaGVpZ2h0XG4gICAgICogdmFyIGNsaXBIZWlnaHQgPSBjb250YWluZXIuY2xpcEhlaWdodCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNsaXAgaGVpZ2h0XG4gICAgICogY29udGFpbmVyLmNsaXBIZWlnaHQoMTAwKTtcbiAgICAgKi9cblxuICAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwRnVuYycpO1xuICAgICAvKipcbiAgICAgICogZ2V0L3NldCBjbGlwIGZ1bmN0aW9uXG4gICAgICAqIEBuYW1lIGNsaXBGdW5jXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAgKiBAZXhhbXBsZVxuICAgICAgKiAvLyBnZXQgY2xpcCBmdW5jdGlvblxuICAgICAgKiB2YXIgY2xpcEZ1bmN0aW9uID0gY29udGFpbmVyLmNsaXBGdW5jKCk7XG4gICAgICAqXG4gICAgICAqIC8vIHNldCBjbGlwIGhlaWdodFxuICAgICAgKiBjb250YWluZXIuY2xpcEZ1bmMoZnVuY3Rpb24oY3R4KSB7XG4gICAgICAqICAgY3R4LnJlY3QoMCwgMCwgMTAwLCAxMDApO1xuICAgICAgKiB9KTtcbiAgICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQ29udGFpbmVyKTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgSEFTX1NIQURPVyA9ICdoYXNTaGFkb3cnO1xuICAgIHZhciBTSEFET1dfUkdCQSA9ICdzaGFkb3dSR0JBJztcblxuICAgIGZ1bmN0aW9uIF9maWxsRnVuYyhjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc3Ryb2tlRnVuYyhjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9maWxsRnVuY0hpdChjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc3Ryb2tlRnVuY0hpdChjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsZWFySGFzU2hhZG93Q2FjaGUoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoSEFTX1NIQURPVyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NsZWFyR2V0U2hhZG93UkdCQUNhY2hlKCkge1xuICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFNIQURPV19SR0JBKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaGFwZSBjb25zdHJ1Y3Rvci4gIFNoYXBlcyBhcmUgcHJpbWl0aXZlIG9iamVjdHMgc3VjaCBhcyByZWN0YW5nbGVzLFxuICAgICAqICBjaXJjbGVzLCB0ZXh0LCBsaW5lcywgZXRjLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5Ob2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgY3VzdG9tU2hhcGUgPSBuZXcgS29udmEuU2hhcGUoe1xuICAgICAgICAgKiAgIHg6IDUsXG4gICAgICAgICAqICAgeTogMTAsXG4gICAgICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICAgICAqICAgLy8gYSBLb252YS5DYW52YXMgcmVuZGVyZXIgaXMgcGFzc2VkIGludG8gdGhlIGRyYXdGdW5jIGZ1bmN0aW9uXG4gICAgICAgICAqICAgZHJhd0Z1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICogICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAqICAgICBjb250ZXh0Lm1vdmVUbygyMDAsIDUwKTtcbiAgICAgICAgICogICAgIGNvbnRleHQubGluZVRvKDQyMCwgODApO1xuICAgICAgICAgKiAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKDMwMCwgMTAwLCAyNjAsIDE3MCk7XG4gICAgICAgICAqICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgKiAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKn0pO1xuICAgICAqL1xuICAgIEtvbnZhLlNoYXBlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5TaGFwZSwge1xuICAgICAgICBfX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlVHlwZSA9ICdTaGFwZSc7XG4gICAgICAgICAgICB0aGlzLl9maWxsRnVuYyA9IF9maWxsRnVuYztcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZUZ1bmMgPSBfc3Ryb2tlRnVuYztcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxGdW5jSGl0ID0gX2ZpbGxGdW5jSGl0O1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlRnVuY0hpdCA9IF9zdHJva2VGdW5jSGl0O1xuXG4gICAgICAgICAgICAvLyBzZXQgY29sb3JLZXlcbiAgICAgICAgICAgIHZhciBzaGFwZXMgPSBLb252YS5zaGFwZXM7XG4gICAgICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgICAgICB3aGlsZSh0cnVlKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gS29udmEuVXRpbC5nZXRSYW5kb21Db2xvcigpO1xuICAgICAgICAgICAgICAgIGlmKGtleSAmJiAhKCBrZXkgaW4gc2hhcGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY29sb3JLZXkgPSBrZXk7XG4gICAgICAgICAgICBzaGFwZXNba2V5XSA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLk5vZGUuY2FsbCh0aGlzLCBjb25maWcpO1xuXG4gICAgICAgICAgICB0aGlzLm9uKCdzaGFkb3dDb2xvckNoYW5nZS5rb252YSBzaGFkb3dCbHVyQ2hhbmdlLmtvbnZhIHNoYWRvd09mZnNldENoYW5nZS5rb252YSBzaGFkb3dPcGFjaXR5Q2hhbmdlLmtvbnZhIHNoYWRvd0VuYWJsZWRDaGFuZ2Uua29udmEnLCBfY2xlYXJIYXNTaGFkb3dDYWNoZSk7XG5cbiAgICAgICAgICAgIHRoaXMub24oJ3NoYWRvd0NvbG9yQ2hhbmdlLmtvbnZhIHNoYWRvd09wYWNpdHlDaGFuZ2Uua29udmEgc2hhZG93RW5hYmxlZENoYW5nZS5rb252YScsIF9jbGVhckdldFNoYWRvd1JHQkFDYWNoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGNhbnZhcyBjb250ZXh0IHRpZWQgdG8gdGhlIGxheWVyXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuQ29udGV4dH1cbiAgICAgICAgICovXG4gICAgICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIoKS5nZXRDb250ZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgY2FudmFzIHJlbmRlcmVyIHRpZWQgdG8gdGhlIGxheWVyLiAgTm90ZSB0aGF0IHRoaXMgcmV0dXJucyBhIGNhbnZhcyByZW5kZXJlciwgbm90IGEgY2FudmFzIGVsZW1lbnRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5DYW52YXN9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIoKS5nZXRDYW52YXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybnMgd2hldGhlciBvciBub3QgYSBzaGFkb3cgd2lsbCBiZSByZW5kZXJlZFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEhBU19TSEFET1csIHRoaXMuX2hhc1NoYWRvdyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9oYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hhZG93RW5hYmxlZCgpICYmICh0aGlzLmdldFNoYWRvd09wYWNpdHkoKSAhPT0gMCAmJiAhISh0aGlzLmdldFNoYWRvd0NvbG9yKCkgfHwgdGhpcy5nZXRTaGFkb3dCbHVyKCkgfHwgdGhpcy5nZXRTaGFkb3dPZmZzZXRYKCkgfHwgdGhpcy5nZXRTaGFkb3dPZmZzZXRZKCkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2hhZG93UkdCQTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoU0hBRE9XX1JHQkEsIHRoaXMuX2dldFNoYWRvd1JHQkEpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0U2hhZG93UkdCQTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNTaGFkb3coKSkge1xuICAgICAgICAgICAgICAgIHZhciByZ2JhID0gS29udmEuVXRpbC5jb2xvclRvUkdCQSh0aGlzLnNoYWRvd0NvbG9yKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgcmdiYS5yICsgJywnICsgcmdiYS5nICsgJywnICsgcmdiYS5iICsgJywnICsgKHJnYmEuYSAqICh0aGlzLmdldFNoYWRvd09wYWNpdHkoKSB8fCAxKSkgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzaGFwZSB3aWxsIGJlIGZpbGxlZFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBoYXNGaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhISh0aGlzLmdldEZpbGwoKSB8fCB0aGlzLmdldEZpbGxQYXR0ZXJuSW1hZ2UoKSB8fCB0aGlzLmdldEZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKSB8fCB0aGlzLmdldEZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzaGFwZSB3aWxsIGJlIHN0cm9rZWRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cm9rZUVuYWJsZWQoKSAmJiAhISh0aGlzLnN0cm9rZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZXMgaWYgcG9pbnQgaXMgaW4gdGhlIHNoYXBlLCByZWdhcmRsZXNzIGlmIG90aGVyIHNoYXBlcyBhcmUgb24gdG9wIG9mIGl0LiAgTm90ZTogYmVjYXVzZVxuICAgICAgICAgKiAgdGhpcyBtZXRob2QgY2xlYXJzIGEgdGVtcG9yYXJ5IGNhbnZhcyBhbmQgdGhlbiByZWRyYXdzIHRoZSBzaGFwZSwgaXQgcGVyZm9ybXMgdmVyeSBwb29ybHkgaWYgZXhlY3V0ZWQgbWFueSB0aW1lc1xuICAgICAgICAgKiAgY29uc2VjdXRpdmVseS4gIFBsZWFzZSB1c2UgdGhlIHtAbGluayBLb252YS5TdGFnZSNnZXRJbnRlcnNlY3Rpb259IG1ldGhvZCBpZiBhdCBhbGwgcG9zc2libGVcbiAgICAgICAgICogIGJlY2F1c2UgaXQgcGVyZm9ybXMgbXVjaCBiZXR0ZXJcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9pbnQueFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9pbnQueVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGludGVyc2VjdHM6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCksXG4gICAgICAgICAgICAgICAgYnVmZmVySGl0Q2FudmFzID0gc3RhZ2UuYnVmZmVySGl0Q2FudmFzLFxuICAgICAgICAgICAgICAgIHA7XG5cbiAgICAgICAgICAgIGJ1ZmZlckhpdENhbnZhcy5nZXRDb250ZXh0KCkuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NjZW5lKGJ1ZmZlckhpdENhbnZhcyk7XG4gICAgICAgICAgICBwID0gYnVmZmVySGl0Q2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKE1hdGgucm91bmQocG9pbnQueCksIE1hdGgucm91bmQocG9pbnQueSksIDEsIDEpLmRhdGE7XG4gICAgICAgICAgICByZXR1cm4gcFszXSA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGV4dGVuZHMgTm9kZS5wcm90b3R5cGUuZGVzdHJveVxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBLb252YS5zaGFwZXNbdGhpcy5jb2xvcktleV07XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX3VzZUJ1ZmZlckNhbnZhczogZnVuY3Rpb24oY2FjaGluZykge1xuICAgICAgICAgICAgcmV0dXJuICFjYWNoaW5nICYmICh0aGlzLnBlcmZlY3REcmF3RW5hYmxlZCgpICYmICh0aGlzLmdldEFic29sdXRlT3BhY2l0eSgpICE9PSAxKSAmJiB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpICYmIHRoaXMuZ2V0U3RhZ2UoKSkgfHxcbiAgICAgICAgICAgICAgICAgICAodGhpcy5wZXJmZWN0RHJhd0VuYWJsZWQoKSAmJiB0aGlzLmhhc1NoYWRvdygpICYmICh0aGlzLmdldEFic29sdXRlT3BhY2l0eSgpICE9PSAxKSAmJiB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpICYmIHRoaXMuZ2V0U3RhZ2UoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gc2VsZiByZWN0YW5nbGUgKHgsIHksIHdpZHRoLCBoZWlnaHQpIG9mIHNoYXBlLlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBhcmUgbm90IHRha2VuIGludG8gYWNjb3VudCB0cmFuc2Zvcm1hdGlvbiBhbmQgc3R5bGVzLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gcmVjdCB3aXRoIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBwcm9wZXJ0aWVzXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIHJlY3QuZ2V0U2VsZlJlY3QoKTsgIC8vIHJldHVybiB7eDowLCB5OjAsIHdpZHRoOnJlY3Qud2lkdGgoKSwgaGVpZ2h0OnJlY3QuaGVpZ2h0KCl9XG4gICAgICAgICAqIGNpcmNsZS5nZXRTZWxmUmVjdCgpOyAgLy8gcmV0dXJuIHt4OiAtIGNpcmNsZS53aWR0aCgpIC8gMiwgeTogLSBjaXJjbGUuaGVpZ2h0KCkgLyAyLCB3aWR0aDpjaXJjbGUud2lkdGgoKSwgaGVpZ2h0OmNpcmNsZS5oZWlnaHQoKX1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGdldFNlbGZSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuX2NlbnRyb2lkID8gTWF0aC5yb3VuZCgtc2l6ZS53aWR0aCAvIDIpIDogMCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLl9jZW50cm9pZCA/IE1hdGgucm91bmQoLXNpemUuaGVpZ2h0IC8gMikgOiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldENsaWVudFJlY3Q6IGZ1bmN0aW9uKHNraXBUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZhciBmaWxsUmVjdCA9IHRoaXMuZ2V0U2VsZlJlY3QoKTtcblxuICAgICAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gKHRoaXMuaGFzU3Ryb2tlKCkgJiYgdGhpcy5zdHJva2VXaWR0aCgpKSB8fCAwO1xuICAgICAgICAgICAgdmFyIGZpbGxBbmRTdHJva2VXaWR0aCA9IGZpbGxSZWN0LndpZHRoICsgc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICB2YXIgZmlsbEFuZFN0cm9rZUhlaWdodCA9IGZpbGxSZWN0LmhlaWdodCArIHN0cm9rZVdpZHRoO1xuXG4gICAgICAgICAgICB2YXIgc2hhZG93T2Zmc2V0WCA9IHRoaXMuaGFzU2hhZG93KCkgPyB0aGlzLnNoYWRvd09mZnNldFgoKSA6IDA7XG4gICAgICAgICAgICB2YXIgc2hhZG93T2Zmc2V0WSA9IHRoaXMuaGFzU2hhZG93KCkgPyB0aGlzLnNoYWRvd09mZnNldFkoKSA6IDA7XG5cbiAgICAgICAgICAgIHZhciBwcmVXaWR0aCA9IGZpbGxBbmRTdHJva2VXaWR0aCArIE1hdGguYWJzKHNoYWRvd09mZnNldFgpO1xuICAgICAgICAgICAgdmFyIHByZUhlaWdodCA9IGZpbGxBbmRTdHJva2VIZWlnaHQgKyBNYXRoLmFicyhzaGFkb3dPZmZzZXRZKTtcblxuICAgICAgICAgICAgdmFyIGJsdXJSYWRpdXMgPSAodGhpcy5oYXNTaGFkb3coKSAmJiB0aGlzLnNoYWRvd0JsdXIoKSB8fCAwKTtcblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gcHJlV2lkdGggKyBibHVyUmFkaXVzICogMjtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBwcmVIZWlnaHQgKyBibHVyUmFkaXVzICogMjtcblxuICAgICAgICAgICAgLy8gaWYgc3Ryb2tlLCBmb3IgZXhhbXBsZSA9IDNcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc2V0IHggdG8gMS41LCBidXQgYWZ0ZXIgTWF0aC5yb3VuZCBpdCB3aWxsIGJlIDJcbiAgICAgICAgICAgIC8vIGFzIHdlIGhhdmUgYWRkaXRpb25hbCBvZmZzZXQgd2UgbmVlZCB0byBpbmNyZWFzZSB3aWR0aCBhbmQgaGVpZ2h0IGJ5IDEgcGl4ZWxcbiAgICAgICAgICAgIHZhciByb3VuZGluZ09mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAoTWF0aC5yb3VuZChzdHJva2VXaWR0aCAvIDIpICE9PSBzdHJva2VXaWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICByb3VuZGluZ09mZnNldCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGggKyByb3VuZGluZ09mZnNldCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArIHJvdW5kaW5nT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHg6IC1NYXRoLnJvdW5kKHN0cm9rZVdpZHRoIC8gMiArIGJsdXJSYWRpdXMpICsgTWF0aC5taW4oc2hhZG93T2Zmc2V0WCwgMCkgKyBmaWxsUmVjdC54LFxuICAgICAgICAgICAgICAgIHk6IC1NYXRoLnJvdW5kKHN0cm9rZVdpZHRoIC8gMiArIGJsdXJSYWRpdXMpICsgTWF0aC5taW4oc2hhZG93T2Zmc2V0WSwgMCkgKyBmaWxsUmVjdC55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFza2lwVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybWVkUmVjdChyZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9LFxuICAgICAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbiwgdG9wLCBjYWNoaW5nLCBza2lwQnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IGxheWVyLmdldENhbnZhcygpLFxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgICAgICAgICBkcmF3RnVuYyA9IHRoaXMuc2NlbmVGdW5jKCksXG4gICAgICAgICAgICAgICAgaGFzU2hhZG93ID0gdGhpcy5oYXNTaGFkb3coKSxcbiAgICAgICAgICAgICAgICBoYXNTdHJva2UgPSB0aGlzLmhhc1N0cm9rZSgpLFxuICAgICAgICAgICAgICAgIHN0YWdlLCBidWZmZXJDYW52YXMsIGJ1ZmZlckNvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FjaGVkQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZFNjZW5lQ2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkcmF3RnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAvLyBpZiBidWZmZXIgY2FudmFzIGlzIG5lZWRlZFxuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZUJ1ZmZlckNhbnZhcyhjYWNoaW5nKSAmJiAhc2tpcEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlckNhbnZhcyA9IHN0YWdlLmJ1ZmZlckNhbnZhcztcbiAgICAgICAgICAgICAgICBidWZmZXJDb250ZXh0ID0gYnVmZmVyQ2FudmFzLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBidWZmZXJDb250ZXh0LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyQ29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyQ29udGV4dC5fYXBwbHlMaW5lSm9pbih0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBsYXllciBtaWdodCBiZSB1bmRlZmluZWQgaWYgd2UgYXJlIHVzaW5nIGNhY2hlIGJlZm9yZSBhZGRpbmcgdG8gbGF5ZXJcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgYnVmZmVyQ29udGV4dCwgdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGJ1ZmZlckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlckNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gYnVmZmVyQ2FudmFzLnBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvdyAmJiAhY2FudmFzLmhpdENhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Ll9hcHBseVNoYWRvdyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGJ1ZmZlckNhbnZhcy5fY2FudmFzLCAwLCAwLCBidWZmZXJDYW52YXMud2lkdGggLyByYXRpbywgYnVmZmVyQ2FudmFzLmhlaWdodCAvIHJhdGlvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoYnVmZmVyQ2FudmFzLl9jYW52YXMsIDAsIDAsIGJ1ZmZlckNhbnZhcy53aWR0aCAvIHJhdGlvLCBidWZmZXJDYW52YXMuaGVpZ2h0IC8gcmF0aW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGJ1ZmZlciBjYW52YXMgaXMgbm90IG5lZWRlZFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlMaW5lSm9pbih0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBsYXllciBtaWdodCBiZSB1bmRlZmluZWQgaWYgd2UgYXJlIHVzaW5nIGNhY2hlIGJlZm9yZSBhZGRpbmcgdG8gbGF5ZXJcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2Zvcm0ob1swXSwgb1sxXSwgb1syXSwgb1szXSwgb1s0XSwgb1s1XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93ICYmIGhhc1N0cm9rZSAmJiAhY2FudmFzLmhpdENhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwbHkgc2hhZG93XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5U2hhZG93KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc2hhcGUgaGFzIHN0cm9rZSB3ZSBuZWVkIHRvIHJlZHJhdyBzaGFwZVxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBzZWUgYSBzaGFkb3cgdW5kZXIgc3Ryb2tlIChhbmQgb3ZlciBmaWxsKVxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgSSB0aGluayB0aGlzIGlzIHVuZXhwZWN0ZWQgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuZ2V0U2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNTaGFkb3cgJiYgIWNhbnZhcy5oaXRDYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5U2hhZG93KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdIaXQ6IGZ1bmN0aW9uKGNhbiwgdG9wLCBjYWNoaW5nKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IGxheWVyLmhpdENhbnZhcyxcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgICAgICAgICBkcmF3RnVuYyA9IHRoaXMuaGl0RnVuYygpIHx8IHRoaXMuc2NlbmVGdW5jKCksXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICAgICAgICAgIGNhY2hlZEhpdENhbnZhcyA9IGNhY2hlZENhbnZhcyAmJiBjYWNoZWRDYW52YXMuaGl0O1xuXG4gICAgICAgICAgICBpZighdGhpcy5zaG91bGREcmF3SGl0KGNhbnZhcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgICAgIGxheWVyLmNsZWFySGl0Q2FjaGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWNoZWRIaXRDYW52YXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3Q2FjaGVkSGl0Q2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkcmF3RnVuYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseUxpbmVKb2luKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShvWzBdLCBvWzFdLCBvWzJdLCBvWzNdLCBvWzRdLCBvWzVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogZHJhdyBoaXQgZ3JhcGggdXNpbmcgdGhlIGNhY2hlZCBzY2VuZSBjYW52YXNcbiAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gYWxwaGFUaHJlc2hvbGQgYWxwaGEgY2hhbm5lbCB0aHJlc2hvbGQgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90XG4gICAgICAgICogIGEgcGl4ZWwgc2hvdWxkIGJlIGRyYXduIG9udG8gdGhlIGhpdCBncmFwaC4gIE11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NS5cbiAgICAgICAgKiAgVGhlIGRlZmF1bHQgaXMgMFxuICAgICAgICAqIEByZXR1cm5zIHtLb252YS5TaGFwZX1cbiAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAqIHNoYXBlLmNhY2hlKCk7XG4gICAgICAgICogc2hhcGUuZHJhd0hpdEZyb21DYWNoZSgpO1xuICAgICAgICAqL1xuICAgICAgICBkcmF3SGl0RnJvbUNhY2hlOiBmdW5jdGlvbihhbHBoYVRocmVzaG9sZCkge1xuICAgICAgICAgICAgdmFyIHRocmVzaG9sZCA9IGFscGhhVGhyZXNob2xkIHx8IDAsXG4gICAgICAgICAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICAgICAgICAgIHNjZW5lQ2FudmFzID0gdGhpcy5fZ2V0Q2FjaGVkU2NlbmVDYW52YXMoKSxcbiAgICAgICAgICAgICAgICBoaXRDYW52YXMgPSBjYWNoZWRDYW52YXMuaGl0LFxuICAgICAgICAgICAgICAgIGhpdENvbnRleHQgPSBoaXRDYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICAgICAgICAgIGhpdFdpZHRoID0gaGl0Q2FudmFzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGl0SGVpZ2h0ID0gaGl0Q2FudmFzLmdldEhlaWdodCgpLFxuICAgICAgICAgICAgICAgIGhpdEltYWdlRGF0YSwgaGl0RGF0YSwgbGVuLCByZ2JDb2xvcktleSwgaSwgYWxwaGE7XG5cbiAgICAgICAgICAgIGhpdENvbnRleHQuY2xlYXIoKTtcbiAgICAgICAgICAgIGhpdENvbnRleHQuZHJhd0ltYWdlKHNjZW5lQ2FudmFzLl9jYW52YXMsIDAsIDAsIGhpdFdpZHRoLCBoaXRIZWlnaHQpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhpdEltYWdlRGF0YSA9IGhpdENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGhpdFdpZHRoLCBoaXRIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGhpdERhdGEgPSBoaXRJbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgICAgICBsZW4gPSBoaXREYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZ2JDb2xvcktleSA9IEtvbnZhLlV0aWwuX2hleFRvUmdiKHRoaXMuY29sb3JLZXkpO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBub24gdHJhbnNwYXJlbnQgcGl4ZWxzIHdpdGggY29sb3Iga2V5XG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBoaXREYXRhW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXREYXRhW2ldID0gcmdiQ29sb3JLZXkucjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdERhdGFbaSArIDFdID0gcmdiQ29sb3JLZXkuZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdERhdGFbaSArIDJdID0gcmdiQ29sb3JLZXkuYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdERhdGFbaSArIDNdID0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0RGF0YVtpICsgM10gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhpdENvbnRleHQucHV0SW1hZ2VEYXRhKGhpdEltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC5lcnJvcignVW5hYmxlIHRvIGRyYXcgaGl0IGdyYXBoIGZyb20gY2FjaGVkIHNjZW5lIGNhbnZhcy4gJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU2hhcGUsIEtvbnZhLk5vZGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzdHJva2UgY29sb3JcbiAgICAgKiBAbmFtZSBzdHJva2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc3Ryb2tlIGNvbG9yXG4gICAgICogdmFyIHN0cm9rZSA9IHNoYXBlLnN0cm9rZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIGNvbG9yIHN0cmluZ1xuICAgICAqIHNoYXBlLnN0cm9rZSgnZ3JlZW4nKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzdHJva2UgY29sb3Igd2l0aCBoZXhcbiAgICAgKiBzaGFwZS5zdHJva2UoJyMwMGZmMDAnKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzdHJva2UgY29sb3Igd2l0aCByZ2JcbiAgICAgKiBzaGFwZS5zdHJva2UoJ3JnYigwLDI1NSwwKScpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIHJnYmEgYW5kIG1ha2UgaXQgNTAlIG9wYXF1ZVxuICAgICAqIHNoYXBlLnN0cm9rZSgncmdiYSgwLDI1NSwwLDAuNScpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlUmVkJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZUdyZWVuJywgMCwgS29udmEuVmFsaWRhdG9ycy5SR0JDb21wb25lbnQpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkRGVwcmVjYXRlZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZUJsdWUnLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlQWxwaGEnLCAxLCBLb252YS5WYWxpZGF0b3JzLmFscGhhQ29tcG9uZW50KTtcblxuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2VXaWR0aCcsIDIpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzdHJva2Ugd2lkdGhcbiAgICAgKiBAbmFtZSBzdHJva2VXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0cm9rZVdpZHRoXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzdHJva2Ugd2lkdGhcbiAgICAgKiB2YXIgc3Ryb2tlV2lkdGggPSBzaGFwZS5zdHJva2VXaWR0aCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHN0cm9rZSB3aWR0aFxuICAgICAqIHNoYXBlLnN0cm9rZVdpZHRoKCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZUhpdEVuYWJsZWQnLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgc3Ryb2tlSGl0RW5hYmxlZCBwcm9wZXJ0eS4gVXNlZnVsIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAgICogWW91IG1heSBzZXQgYHNoYXBlLnN0cm9rZUhpdEVuYWJsZWQoZmFsc2UpYC4gSW4gdGhpcyBjYXNlIHN0cm9rZSB3aWxsIGJlIG5vIGRyYXcgb24gaGl0IGNhbnZhcywgc28gaGl0IGFyZWFcbiAgICAgKiBvZiBzaGFwZSB3aWxsIGJlIGRlY3JlYXNlZCAoYnkgbGluZVdpZHRoIC8gMikuIFJlbWVtYmVyIHRoYXQgbm9uIGNsb3NlZCBsaW5lIHdpdGggYHN0cm9rZUhpdEVuYWJsZWQgPSBmYWxzZWBcbiAgICAgKiB3aWxsIGJlIG5vdCBkcmF3biBvbiBoaXQgY2FudmFzLCB0aGF0IGlzIG1lYW4gbGluZSB3aWxsIG5vIHRyaWdnZXIgcG9pbnRlciBldmVudHMgKGxpa2UgbW91c2VvdmVyKVxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBuYW1lIHN0cm9rZUhpdEVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3Ryb2tlSGl0RW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHN0cm9rZUhpdEVuYWJsZWRcbiAgICAgKiB2YXIgc3Ryb2tlSGl0RW5hYmxlZCA9IHNoYXBlLnN0cm9rZUhpdEVuYWJsZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzdHJva2VIaXRFbmFibGVkXG4gICAgICogc2hhcGUuc3Ryb2tlSGl0RW5hYmxlZCgpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdwZXJmZWN0RHJhd0VuYWJsZWQnLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgcGVyZmVjdERyYXdFbmFibGVkLiBJZiBhIHNoYXBlIGhhcyBmaWxsLCBzdHJva2UgYW5kIG9wYWNpdHkgeW91IG1heSBzZXQgYHBlcmZlY3REcmF3RW5hYmxlZGAgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgKiBTZWUgaHR0cDovL2tvbnZhanMuZ2l0aHViLmlvL2RvY3MvcGVyZm9ybWFuY2UvRGlzYWJsZV9QZXJmZWN0X0RyYXcuaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAbmFtZSBwZXJmZWN0RHJhd0VuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVyZmVjdERyYXdFbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcGVyZmVjdERyYXdFbmFibGVkXG4gICAgICogdmFyIHBlcmZlY3REcmF3RW5hYmxlZCA9IHNoYXBlLnBlcmZlY3REcmF3RW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHBlcmZlY3REcmF3RW5hYmxlZFxuICAgICAqIHNoYXBlLnBlcmZlY3REcmF3RW5hYmxlZCgpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dGb3JTdHJva2VFbmFibGVkJywgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvd0ZvclN0cm9rZUVuYWJsZWQuIFVzZWZ1bCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgICAqIFlvdSBtYXkgc2V0IGBzaGFwZS5zaGFkb3dGb3JTdHJva2VFbmFibGVkKGZhbHNlKWAuIEluIHRoaXMgY2FzZSBzdHJva2Ugd2lsbCBiZSBubyBkcmF3IHNoYWRvdyBmb3Igc3Ryb2tlLlxuICAgICAqIFJlbWVtYmVyIGlmIHlvdSBzZXQgYHNoYWRvd0ZvclN0cm9rZUVuYWJsZWQgPSBmYWxzZWAgZm9yIG5vbiBjbG9zZWQgbGluZSAtIHRoYXQgbGluZSB3aXRoIGhhdmUgbm8gc2hhZG93IS5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAbmFtZSBzaGFkb3dGb3JTdHJva2VFbmFibGVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWRvd0ZvclN0cm9rZUVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3dGb3JTdHJva2VFbmFibGVkXG4gICAgICogdmFyIHNoYWRvd0ZvclN0cm9rZUVuYWJsZWQgPSBzaGFwZS5zaGFkb3dGb3JTdHJva2VFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZFxuICAgICAqIHNoYXBlLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnbGluZUpvaW4nKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgbGluZSBqb2luLiAgQ2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGVcbiAgICAgKiAgZGVmYXVsdCBpcyBtaXRlclxuICAgICAqIEBuYW1lIGxpbmVKb2luXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZUpvaW5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGxpbmUgam9pblxuICAgICAqIHZhciBsaW5lSm9pbiA9IHNoYXBlLmxpbmVKb2luKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgbGluZSBqb2luXG4gICAgICogc2hhcGUubGluZUpvaW4oJ3JvdW5kJyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2xpbmVDYXAnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgbGluZSBjYXAuICBDYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxdWFyZVxuICAgICAqIEBuYW1lIGxpbmVDYXBcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lQ2FwXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBsaW5lIGNhcFxuICAgICAqIHZhciBsaW5lQ2FwID0gc2hhcGUubGluZUNhcCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGxpbmUgY2FwXG4gICAgICogc2hhcGUubGluZUNhcCgncm91bmQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2NlbmVGdW5jJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNjZW5lIGRyYXcgZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBzY2VuZUZ1bmNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYXdGdW5jIGRyYXdpbmcgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2NlbmUgZHJhdyBmdW5jdGlvblxuICAgICAqIHZhciBzY2VuZUZ1bmMgPSBzaGFwZS5zY2VuZUZ1bmMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzY2VuZSBkcmF3IGZ1bmN0aW9uXG4gICAgICogc2hhcGUuc2NlbmVGdW5jKGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgKiAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICogICBjb250ZXh0LnJlY3QoMCwgMCwgdGhpcy53aWR0aCgpLCB0aGlzLmhlaWdodCgpKTtcbiAgICAgKiAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICogICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnaGl0RnVuYycpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBoaXQgZHJhdyBmdW5jdGlvblxuICAgICAqIEBuYW1lIGhpdEZ1bmNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYXdGdW5jIGRyYXdpbmcgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaGl0IGRyYXcgZnVuY3Rpb25cbiAgICAgKiB2YXIgaGl0RnVuYyA9IHNoYXBlLmhpdEZ1bmMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBoaXQgZHJhdyBmdW5jdGlvblxuICAgICAqIHNoYXBlLmhpdEZ1bmMoZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAqICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgKiAgIGNvbnRleHQucmVjdCgwLCAwLCB0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpO1xuICAgICAqICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgKiAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdkYXNoJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGRhc2ggYXJyYXkgZm9yIHN0cm9rZS5cbiAgICAgKiBAbmFtZSBkYXNoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXNoXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogIC8vIGFwcGx5IGRhc2hlZCBzdHJva2UgdGhhdCBpcyAxMHB4IGxvbmcgYW5kIDUgcGl4ZWxzIGFwYXJ0XG4gICAgICogIGxpbmUuZGFzaChbMTAsIDVdKTtcbiAgICAgKiAgLy8gYXBwbHkgZGFzaGVkIHN0cm9rZSB0aGF0IGlzIG1hZGUgdXAgb2YgYWx0ZXJuYXRpbmcgZGFzaGVkXG4gICAgICogIC8vIGxpbmVzIHRoYXQgYXJlIDEwcHggbG9uZyBhbmQgMjBweCBhcGFydCwgYW5kIGRvdHMgdGhhdCBoYXZlXG4gICAgICogIC8vIGEgcmFkaXVzIG9mIDVweCBhbmQgYXJlIDIwcHggYXBhcnRcbiAgICAgKiAgbGluZS5kYXNoKFsxMCwgMjAsIDAuMDAxLCAyMF0pO1xuICAgICAqL1xuXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd0NvbG9yJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBjb2xvclxuICAgICAqIEBuYW1lIHNoYWRvd0NvbG9yXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvdyBjb2xvclxuICAgICAqIHZhciBzaGFkb3cgPSBzaGFwZS5zaGFkb3dDb2xvcigpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIGNvbG9yIHN0cmluZ1xuICAgICAqIHNoYXBlLnNoYWRvd0NvbG9yKCdncmVlbicpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIGhleFxuICAgICAqIHNoYXBlLnNoYWRvd0NvbG9yKCcjMDBmZjAwJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IGNvbG9yIHdpdGggcmdiXG4gICAgICogc2hhcGUuc2hhZG93Q29sb3IoJ3JnYigwLDI1NSwwKScpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIHJnYmEgYW5kIG1ha2UgaXQgNTAlIG9wYXF1ZVxuICAgICAqIHNoYXBlLnNoYWRvd0NvbG9yKCdyZ2JhKDAsMjU1LDAsMC41Jyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dSZWQnLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93R3JlZW4nLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93Qmx1ZScsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dBbHBoYScsIDEsIEtvbnZhLlZhbGlkYXRvcnMuYWxwaGFDb21wb25lbnQpO1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dCbHVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBibHVyXG4gICAgICogQG5hbWUgc2hhZG93Qmx1clxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJsdXJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHNoYWRvdyBibHVyXG4gICAgICogdmFyIHNoYWRvd0JsdXIgPSBzaGFwZS5zaGFkb3dCbHVyKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IGJsdXJcbiAgICAgKiBzaGFwZS5zaGFkb3dCbHVyKDEwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93T3BhY2l0eScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzaGFkb3cgb3BhY2l0eS4gIG11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAbmFtZSBzaGFkb3dPcGFjaXR5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2hhZG93IG9wYWNpdHlcbiAgICAgKiB2YXIgc2hhZG93T3BhY2l0eSA9IHNoYXBlLnNoYWRvd09wYWNpdHkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaGFkb3cgb3BhY2l0eVxuICAgICAqIHNoYXBlLnNoYWRvd09wYWNpdHkoMC41KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd09mZnNldCcsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzaGFkb3cgb2Zmc2V0XG4gICAgICogQG5hbWUgc2hhZG93T2Zmc2V0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3cgb2Zmc2V0XG4gICAgICogdmFyIHNoYWRvd09mZnNldCA9IHNoYXBlLnNoYWRvd09mZnNldCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHNoYWRvdyBvZmZzZXRcbiAgICAgKiBzaGFwZS5zaGFkb3dPZmZzZXQoe1xuICAgICAqICAgeDogMjBcbiAgICAgKiAgIHk6IDEwXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd09mZnNldFgnLCAwKTtcblxuICAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBvZmZzZXQgeFxuICAgICAqIEBuYW1lIHNoYWRvd09mZnNldFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3cgb2Zmc2V0IHhcbiAgICAgKiB2YXIgc2hhZG93T2Zmc2V0WCA9IHNoYXBlLnNoYWRvd09mZnNldFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBzaGFkb3cgb2Zmc2V0IHhcbiAgICAgKiBzaGFwZS5zaGFkb3dPZmZzZXRYKDUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dPZmZzZXRZJywgMCk7XG5cbiAgICAgLyoqXG4gICAgICogZ2V0L3NldCBzaGFkb3cgb2Zmc2V0IHlcbiAgICAgKiBAbmFtZSBzaGFkb3dPZmZzZXRZXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc2hhZG93IG9mZnNldCB5XG4gICAgICogdmFyIHNoYWRvd09mZnNldFkgPSBzaGFwZS5zaGFkb3dPZmZzZXRZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgc2hhZG93IG9mZnNldCB5XG4gICAgICogc2hhcGUuc2hhZG93T2Zmc2V0WSg1KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5JbWFnZScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVybkltYWdlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2V9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogdmFyIGZpbGxQYXR0ZXJuSW1hZ2UgPSBzaGFwZS5maWxsUGF0dGVybkltYWdlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogdmFyIGltYWdlT2JqID0gbmV3IEltYWdlKCk7XG4gICAgICogaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICogICBzaGFwZS5maWxsUGF0dGVybkltYWdlKGltYWdlT2JqKTtcbiAgICAgKiB9O1xuICAgICAqIGltYWdlT2JqLnNyYyA9ICdwYXRoL3RvL2ltYWdlL2pwZyc7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGwnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBjb2xvclxuICAgICAqIEBuYW1lIGZpbGxcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBjb2xvclxuICAgICAqIHZhciBmaWxsID0gc2hhcGUuZmlsbCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgY29sb3Igd2l0aCBjb2xvciBzdHJpbmdcbiAgICAgKiBzaGFwZS5maWxsKCdncmVlbicpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgY29sb3Igd2l0aCBoZXhcbiAgICAgKiBzaGFwZS5maWxsKCcjMDBmZjAwJyk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBjb2xvciB3aXRoIHJnYlxuICAgICAqIHNoYXBlLmZpbGwoJ3JnYigwLDI1NSwwKScpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgY29sb3Igd2l0aCByZ2JhIGFuZCBtYWtlIGl0IDUwJSBvcGFxdWVcbiAgICAgKiBzaGFwZS5maWxsKCdyZ2JhKDAsMjU1LDAsMC41Jyk7XG4gICAgICpcbiAgICAgKiAvLyBzaGFwZSB3aXRob3V0IGZpbGxcbiAgICAgKiBzaGFwZS5maWxsKG51bGwpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJlZCcsIDAsIEtvbnZhLlZhbGlkYXRvcnMuUkdCQ29tcG9uZW50KTtcbiAgICBLb252YS5GYWN0b3J5LmFkZERlcHJlY2F0ZWRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsR3JlZW4nLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbEJsdWUnLCAwLCBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCk7XG4gICAgS29udmEuRmFjdG9yeS5hZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbEFscGhhJywgMSwgS29udmEuVmFsaWRhdG9ycy5hbHBoYUNvbXBvbmVudCk7XG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuWCcsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4geFxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuWFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiB4XG4gICAgICogdmFyIGZpbGxQYXR0ZXJuWCA9IHNoYXBlLmZpbGxQYXR0ZXJuWCgpO1xuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4geFxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuWCgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuWScsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4geVxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuWVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiB5XG4gICAgICogdmFyIGZpbGxQYXR0ZXJuWSA9IHNoYXBlLmZpbGxQYXR0ZXJuWSgpO1xuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4geVxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuWSgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgY29sb3Igc3RvcHNcbiAgICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb2xvclN0b3BzXG4gICAgICogQHJldHVybnMge0FycmF5fSBjb2xvclN0b3BzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgY29sb3Igc3RvcHNcbiAgICAgKiB2YXIgY29sb3JTdG9wcyA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKTtcbiAgICAgKlxuICAgICAqIC8vIGNyZWF0ZSBhIGxpbmVhciBncmFkaWVudCB0aGF0IHN0YXJ0cyB3aXRoIHJlZCwgY2hhbmdlcyB0byBibHVlXG4gICAgICogLy8gaGFsZndheSB0aHJvdWdoLCBhbmQgdGhlbiBjaGFuZ2VzIHRvIGdyZWVuXG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcygwLCAncmVkJywgMC41LCAnYmx1ZScsIDEsICdncmVlbicpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1cycsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCByYWRpdXNcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHJhZGl1c1xuICAgICAqIHZhciBzdGFydFJhZGl1cyA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHJhZGl1c1xuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzKDApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHJhZGl1c1xuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaWFsIGdyYWRpZW50IGVuZCByYWRpdXNcbiAgICAgKiB2YXIgZW5kUmFkaXVzID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcmFkaWFsIGdyYWRpZW50IGVuZCByYWRpdXNcbiAgICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMoMTAwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wcycpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBjb2xvciBzdG9wc1xuICAgICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xvclN0b3BzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGNvbG9yIHN0b3BzXG4gICAgICogdmFyIGNvbG9yU3RvcHMgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAgICpcbiAgICAgKiAvLyBjcmVhdGUgYSByYWRpYWwgZ3JhZGllbnQgdGhhdCBzdGFydHMgd2l0aCByZWQsIGNoYW5nZXMgdG8gYmx1ZVxuICAgICAqIC8vIGhhbGZ3YXkgdGhyb3VnaCwgYW5kIHRoZW4gY2hhbmdlcyB0byBncmVlblxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoMCwgJ3JlZCcsIDAuNSwgJ2JsdWUnLCAxLCAnZ3JlZW4nKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5SZXBlYXQnLCAncmVwZWF0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiByZXBlYXQuICBDYW4gYmUgJ3JlcGVhdCcsICdyZXBlYXQteCcsICdyZXBlYXQteScsIG9yICduby1yZXBlYXQnLiAgVGhlIGRlZmF1bHQgaXMgJ3JlcGVhdCdcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVyblJlcGVhdFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcGVhdFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHJlcGVhdFxuICAgICAqIHZhciByZXBlYXQgPSBzaGFwZS5maWxsUGF0dGVyblJlcGVhdCgpO1xuICAgICAqXG4gICAgICogLy8gcmVwZWF0IHBhdHRlcm4gaW4geCBkaXJlY3Rpb24gb25seVxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuUmVwZWF0KCdyZXBlYXQteCcpO1xuICAgICAqXG4gICAgICogLy8gZG8gbm90IHJlcGVhdCB0aGUgcGF0dGVyblxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuUmVwZWF0KCdubyByZXBlYXQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbEVuYWJsZWQnLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBlbmFibGVkIGZsYWdcbiAgICAgKiBAbmFtZSBmaWxsRW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBlbmFibGVkIGZsYWdcbiAgICAgKiB2YXIgZmlsbEVuYWJsZWQgPSBzaGFwZS5maWxsRW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gZGlzYWJsZSBmaWxsXG4gICAgICogc2hhcGUuZmlsbEVuYWJsZWQoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZW5hYmxlIGZpbGxcbiAgICAgKiBzaGFwZS5maWxsRW5hYmxlZCh0cnVlKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlRW5hYmxlZCcsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzdHJva2UgZW5hYmxlZCBmbGFnXG4gICAgICogQG5hbWUgc3Ryb2tlRW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgc3Ryb2tlIGVuYWJsZWQgZmxhZ1xuICAgICAqIHZhciBzdHJva2VFbmFibGVkID0gc2hhcGUuc3Ryb2tlRW5hYmxlZCgpO1xuICAgICAqXG4gICAgICogLy8gZGlzYWJsZSBzdHJva2VcbiAgICAgKiBzaGFwZS5zdHJva2VFbmFibGVkKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGVuYWJsZSBzdHJva2VcbiAgICAgKiBzaGFwZS5zdHJva2VFbmFibGVkKHRydWUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dFbmFibGVkJywgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHNoYWRvdyBlbmFibGVkIGZsYWdcbiAgICAgKiBAbmFtZSBzaGFkb3dFbmFibGVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBzaGFkb3cgZW5hYmxlZCBmbGFnXG4gICAgICogdmFyIHNoYWRvd0VuYWJsZWQgPSBzaGFwZS5zaGFkb3dFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIHNoYWRvd1xuICAgICAqIHNoYXBlLnNoYWRvd0VuYWJsZWQoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZW5hYmxlIHNoYWRvd1xuICAgICAqIHNoYXBlLnNoYWRvd0VuYWJsZWQodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2Rhc2hFbmFibGVkJywgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGRhc2ggZW5hYmxlZCBmbGFnXG4gICAgICogQG5hbWUgZGFzaEVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGRhc2ggZW5hYmxlZCBmbGFnXG4gICAgICogdmFyIGRhc2hFbmFibGVkID0gc2hhcGUuZGFzaEVuYWJsZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2FibGUgZGFzaFxuICAgICAqIHNoYXBlLmRhc2hFbmFibGVkKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGVuYWJsZSBkYXNoXG4gICAgICogc2hhcGUuZGFzaEVuYWJsZWQodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZVNjYWxlRW5hYmxlZCcsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBzdHJva2VTY2FsZSBlbmFibGVkIGZsYWdcbiAgICAgKiBAbmFtZSBzdHJva2VTY2FsZUVuYWJsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHN0cm9rZSBzY2FsZSBlbmFibGVkIGZsYWdcbiAgICAgKiB2YXIgc3Ryb2tlU2NhbGVFbmFibGVkID0gc2hhcGUuc3Ryb2tlU2NhbGVFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIHN0cm9rZSBzY2FsZVxuICAgICAqIHNoYXBlLnN0cm9rZVNjYWxlRW5hYmxlZChmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgc3Ryb2tlIHNjYWxlXG4gICAgICogc2hhcGUuc3Ryb2tlU2NhbGVFbmFibGVkKHRydWUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUHJpb3JpdHknLCAnY29sb3InKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBwcmlvcml0eS4gIGNhbiBiZSBjb2xvciwgcGF0dGVybiwgbGluZWFyLWdyYWRpZW50LCBvciByYWRpYWwtZ3JhZGllbnQuICBUaGUgZGVmYXVsdCBpcyBjb2xvci5cbiAgICAgKiAgIFRoaXMgaXMgaGFuZHkgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuXG4gICAgICogQG5hbWUgZmlsbFByaW9yaXR5XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJpb3JpdHlcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcHJpb3JpdHlcbiAgICAgKiB2YXIgZmlsbFByaW9yaXR5ID0gc2hhcGUuZmlsbFByaW9yaXR5KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwcmlvcml0eVxuICAgICAqIHNoYXBlLmZpbGxQcmlvcml0eSgnbGluZWFyLWdyYWRpZW50Jyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVybk9mZnNldCcsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gb2Zmc2V0XG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5PZmZzZXRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBvZmZzZXRcbiAgICAgKiB2YXIgcGF0dGVybk9mZnNldCA9IHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIG9mZnNldFxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0KHtcbiAgICAgKiAgIHg6IDIwXG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuT2Zmc2V0WCcsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB4XG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5PZmZzZXRYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB4XG4gICAgICogdmFyIHBhdHRlcm5PZmZzZXRYID0gc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXRYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB4XG4gICAgICogc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXRYKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5PZmZzZXRZJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHlcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVybk9mZnNldFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHlcbiAgICAgKiB2YXIgcGF0dGVybk9mZnNldFkgPSBzaGFwZS5maWxsUGF0dGVybk9mZnNldFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHlcbiAgICAgKiBzaGFwZS5maWxsUGF0dGVybk9mZnNldFkoMTApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5TY2FsZScsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gc2NhbGVcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVyblNjYWxlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZS55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gc2NhbGVcbiAgICAgKiB2YXIgcGF0dGVyblNjYWxlID0gc2hhcGUuZmlsbFBhdHRlcm5TY2FsZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBzY2FsZVxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGUoe1xuICAgICAqICAgeDogMlxuICAgICAqICAgeTogMlxuICAgICAqIH0pO1xuICAgICAqL1xuXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuU2NhbGVYJywgMSk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gc2NhbGUgeFxuICAgICAqIEBuYW1lIGZpbGxQYXR0ZXJuU2NhbGVYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHNjYWxlIHhcbiAgICAgKiB2YXIgcGF0dGVyblNjYWxlWCA9IHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGVYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIHNjYWxlIHhcbiAgICAgKiBzaGFwZS5maWxsUGF0dGVyblNjYWxlWCgyKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5TY2FsZVknLCAxKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBzY2FsZSB5XG4gICAgICogQG5hbWUgZmlsbFBhdHRlcm5TY2FsZVlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gc2NhbGUgeVxuICAgICAqIHZhciBwYXR0ZXJuU2NhbGVZID0gc2hhcGUuZmlsbFBhdHRlcm5TY2FsZVkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gc2NhbGUgeVxuICAgICAqIHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGVZKDIpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCcsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludFxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFydFBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvaW50LnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAgICogdmFyIHN0YXJ0UG9pbnQgPSBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50KHtcbiAgICAgKiAgIHg6IDIwXG4gICAgICogICB5OiAxMFxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WCcsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIHZhciBzdGFydFBvaW50WCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgICAqIHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFknLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICAgKiB2YXIgc3RhcnRQb2ludFkgPSBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WSgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludCcsIFsneCcsICd5J10pO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVuZFBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFBvaW50LnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAgICogdmFyIGVuZFBvaW50ID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludCh7XG4gICAgICogICB4OiAyMFxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAgICogdmFyIGVuZFBvaW50WCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgICAqIEBuYW1lIGZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAgICogdmFyIGVuZFBvaW50WSA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQnLCBbJ3gnLCAneSddKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhcnRQb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvaW50LnhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb2ludC55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludFxuICAgICAqIHZhciBzdGFydFBvaW50ID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludCh7XG4gICAgICogICB4OiAyMFxuICAgICAqICAgeTogMTBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFgnLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcbiAgICAgKiB2YXIgc3RhcnRQb2ludFggPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcbiAgICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogdmFyIHN0YXJ0UG9pbnRZID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFkoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQnLCBbJ3gnLCAneSddKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbmRQb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRQb2ludC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFBvaW50LnlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludFxuICAgICAqIHZhciBlbmRQb2ludCA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQoe1xuICAgICAqICAgeDogMjBcbiAgICAgKiAgIHk6IDEwXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WCcsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgICAqIHZhciBlbmRQb2ludFggPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WCgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WScsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50IHlcbiAgICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgICAqIHZhciBlbmRQb2ludFkgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WSgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuUm90YXRpb24nLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAbmFtZSBmaWxsUGF0dGVyblJvdGF0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cbiAgICAgKiBAcmV0dXJucyB7S29udmEuU2hhcGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHJvdGF0aW9uXG4gICAgICogdmFyIHBhdHRlcm5Sb3RhdGlvbiA9IHNoYXBlLmZpbGxQYXR0ZXJuUm90YXRpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gcm90YXRpb25cbiAgICAgKiBzaGFwZS5maWxsUGF0dGVyblJvdGF0aW9uKDIwKTtcbiAgICAgKi9cblxuXG4gICAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLlNoYXBlLCB7XG4gICAgICAgIGRhc2hBcnJheTogJ2Rhc2gnLFxuICAgICAgICBnZXREYXNoQXJyYXk6ICdnZXREYXNoJyxcbiAgICAgICAgc2V0RGFzaEFycmF5OiAnZ2V0RGFzaCcsXG5cbiAgICAgICAgZHJhd0Z1bmM6ICdzY2VuZUZ1bmMnLFxuICAgICAgICBnZXREcmF3RnVuYzogJ2dldFNjZW5lRnVuYycsXG4gICAgICAgIHNldERyYXdGdW5jOiAnc2V0U2NlbmVGdW5jJyxcblxuICAgICAgICBkcmF3SGl0RnVuYzogJ2hpdEZ1bmMnLFxuICAgICAgICBnZXREcmF3SGl0RnVuYzogJ2dldEhpdEZ1bmMnLFxuICAgICAgICBzZXREcmF3SGl0RnVuYzogJ3NldEhpdEZ1bmMnXG4gICAgfSk7XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuU2hhcGUpO1xufSkoS29udmEpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIENPTlNUQU5UU1xuICAgIHZhciBTVEFHRSA9ICdTdGFnZScsXG4gICAgICAgIFNUUklORyA9ICdzdHJpbmcnLFxuICAgICAgICBQWCA9ICdweCcsXG5cbiAgICAgICAgTU9VU0VPVVQgPSAnbW91c2VvdXQnLFxuICAgICAgICBNT1VTRUxFQVZFID0gJ21vdXNlbGVhdmUnLFxuICAgICAgICBNT1VTRU9WRVIgPSAnbW91c2VvdmVyJyxcbiAgICAgICAgTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJyxcbiAgICAgICAgTU9VU0VNT1ZFID0gJ21vdXNlbW92ZScsXG4gICAgICAgIE1PVVNFRE9XTiA9ICdtb3VzZWRvd24nLFxuICAgICAgICBNT1VTRVVQID0gJ21vdXNldXAnLFxuICAgICAgICBDTElDSyA9ICdjbGljaycsXG4gICAgICAgIERCTF9DTElDSyA9ICdkYmxjbGljaycsXG4gICAgICAgIFRPVUNIU1RBUlQgPSAndG91Y2hzdGFydCcsXG4gICAgICAgIFRPVUNIRU5EID0gJ3RvdWNoZW5kJyxcbiAgICAgICAgVEFQID0gJ3RhcCcsXG4gICAgICAgIERCTF9UQVAgPSAnZGJsdGFwJyxcbiAgICAgICAgVE9VQ0hNT1ZFID0gJ3RvdWNobW92ZScsXG4gICAgICAgIERPTU1PVVNFU0NST0xMID0gJ0RPTU1vdXNlU2Nyb2xsJyxcbiAgICAgICAgTU9VU0VXSEVFTCA9ICdtb3VzZXdoZWVsJyxcbiAgICAgICAgV0hFRUwgPSAnd2hlZWwnLFxuXG4gICAgICAgIENPTlRFTlRfTU9VU0VPVVQgPSAnY29udGVudE1vdXNlb3V0JyxcbiAgICAgICAgQ09OVEVOVF9NT1VTRU9WRVIgPSAnY29udGVudE1vdXNlb3ZlcicsXG4gICAgICAgIENPTlRFTlRfTU9VU0VNT1ZFID0gJ2NvbnRlbnRNb3VzZW1vdmUnLFxuICAgICAgICBDT05URU5UX01PVVNFRE9XTiA9ICdjb250ZW50TW91c2Vkb3duJyxcbiAgICAgICAgQ09OVEVOVF9NT1VTRVVQID0gJ2NvbnRlbnRNb3VzZXVwJyxcbiAgICAgICAgQ09OVEVOVF9DTElDSyA9ICdjb250ZW50Q2xpY2snLFxuICAgICAgICBDT05URU5UX0RCTF9DTElDSyA9ICdjb250ZW50RGJsY2xpY2snLFxuICAgICAgICBDT05URU5UX1RPVUNIU1RBUlQgPSAnY29udGVudFRvdWNoc3RhcnQnLFxuICAgICAgICBDT05URU5UX1RPVUNIRU5EID0gJ2NvbnRlbnRUb3VjaGVuZCcsXG4gICAgICAgIENPTlRFTlRfREJMX1RBUCA9ICdjb250ZW50RGJsdGFwJyxcbiAgICAgICAgQ09OVEVOVF9UQVAgPSAnY29udGVudFRhcCcsXG4gICAgICAgIENPTlRFTlRfVE9VQ0hNT1ZFID0gJ2NvbnRlbnRUb3VjaG1vdmUnLFxuICAgICAgICBDT05URU5UX1dIRUVMID0gJ2NvbnRlbnRXaGVlbCcsXG5cbiAgICAgICAgRElWID0gJ2RpdicsXG4gICAgICAgIFJFTEFUSVZFID0gJ3JlbGF0aXZlJyxcbiAgICAgICAgS09OVkFfQ09OVEVOVCA9ICdrb252YWpzLWNvbnRlbnQnLFxuICAgICAgICBTUEFDRSA9ICcgJyxcbiAgICAgICAgVU5ERVJTQ09SRSA9ICdfJyxcbiAgICAgICAgQ09OVEFJTkVSID0gJ2NvbnRhaW5lcicsXG4gICAgICAgIEVNUFRZX1NUUklORyA9ICcnLFxuICAgICAgICBFVkVOVFMgPSBbTU9VU0VET1dOLCBNT1VTRU1PVkUsIE1PVVNFVVAsIE1PVVNFT1VULCBUT1VDSFNUQVJULCBUT1VDSE1PVkUsIFRPVUNIRU5ELCBNT1VTRU9WRVIsIERPTU1PVVNFU0NST0xMLCBNT1VTRVdIRUVMLCBXSEVFTF0sXG5cbiAgICAgICAgLy8gY2FjaGVkIHZhcmlhYmxlc1xuICAgICAgICBldmVudHNMZW5ndGggPSBFVkVOVFMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gYWRkRXZlbnQoY3R4LCBldmVudE5hbWUpIHtcbiAgICAgICAgY3R4LmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgY3R4W1VOREVSU0NPUkUgKyBldmVudE5hbWVdKGV2dCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFnZSBjb25zdHJ1Y3Rvci4gIEEgc3RhZ2UgaXMgdXNlZCB0byBjb250YWluIG11bHRpcGxlIGxheWVyc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5Db250YWluZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gY29uZmlnLmNvbnRhaW5lciBDb250YWluZXIgc2VsZWN0b3Igb3IgRE9NIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHN0YWdlID0gbmV3IEtvbnZhLlN0YWdlKHtcbiAgICAgICAgICogICB3aWR0aDogNTAwLFxuICAgICAgICAgKiAgIGhlaWdodDogODAwLFxuICAgICAgICAgKiAgIGNvbnRhaW5lcjogJ2NvbnRhaW5lcklkJyAvLyBvciBcIiNjb250YWluZXJJZFwiIG9yIFwiLmNvbnRhaW5lckNsYXNzXCJcbiAgICAgICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuU3RhZ2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5TdGFnZSwge1xuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPSBTVEFHRTtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLl9pZCA9IEtvbnZhLmlkQ291bnRlcisrO1xuICAgICAgICAgICAgdGhpcy5fYnVpbGRET00oKTtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRDb250ZW50RXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVOZXN0ZWRUcmFuc2Zvcm1zID0gZmFsc2U7XG4gICAgICAgICAgICBLb252YS5zdGFnZXMucHVzaCh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3ZhbGlkYXRlQWRkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLmdldFR5cGUoKSAhPT0gJ0xheWVyJykge1xuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwudGhyb3coJ1lvdSBtYXkgb25seSBhZGQgbGF5ZXJzIHRvIHRoZSBzdGFnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBjb250YWluZXIgZG9tIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgdGhlIHN0YWdlIHdyYXBwZXIgZGl2IGVsZW1lbnRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gY29udGFpbmVyIGNhbiBwYXNzIGluIGEgZG9tIGVsZW1lbnQgb3IgaWQgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBzZXRDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGFpbmVyID09PSBTVFJJTkcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjb250YWluZXIuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IEtvbnZhLmRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lKVswXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIuY2hhckF0KDApICE9PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBjb250YWluZXIuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gS29udmEuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnQ2FuIG5vdCBmaW5kIGNvbnRhaW5lciBpbiBkb2N1bWVudCB3aXRoIGlkICcgKyBpZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyKENPTlRBSU5FUiwgY29udGFpbmVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBzaG91bGREcmF3SGl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLmRyYXcuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhdyBsYXllciBzY2VuZSBncmFwaHNcbiAgICAgICAgICogQG5hbWUgZHJhd1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRyYXcgbGF5ZXIgaGl0IGdyYXBoc1xuICAgICAgICAgKiBAbmFtZSBkcmF3SGl0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IGhlaWdodFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVET00oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHdpZHRoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgICAgICovXG4gICAgICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVET00oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogY2xlYXIgYWxsIGxheWVyc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsYXllcnMgPSB0aGlzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGxlbiA9IGxheWVycy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbjtcblxuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBsYXllcnNbbl0uY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqLmNvbnRhaW5lciA9IEtvbnZhLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoRElWKTtcbiAgICAgICAgICAgIHJldHVybiBLb252YS5Db250YWluZXIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcywgb2JqKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlc3Ryb3kgc3RhZ2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICAgICAgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIGlmKGNvbnRlbnQgJiYgS29udmEuVXRpbC5faXNJbkRvY3VtZW50KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5yZW1vdmVDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleCA9IEtvbnZhLnN0YWdlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBLb252YS5zdGFnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHBvaW50ZXIgcG9zaXRpb24gd2hpY2ggY2FuIGJlIGEgdG91Y2ggcG9zaXRpb24gb3IgbW91c2UgcG9zaXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRQb2ludGVyUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRlclBvcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgc3RhZ2UgY29udGVudCBkaXYgZWxlbWVudCB3aGljaCBoYXMgdGhlXG4gICAgICAgICAqICB0aGUgY2xhc3MgbmFtZSBcImtvbnZhanMtY29udGVudFwiXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBkYXRhIFVSTFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNhbGxiYWNrXSBmdW5jdGlvbiBleGVjdXRlZCB3aGVuIHRoZSBjb21wb3NpdGUgaGFzIGNvbXBsZXRlZC4gRGVwcmVjYXRlZCBhcyBtZXRob2QgaXMgc3luYyBub3cuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm1pbWVUeXBlXSBjYW4gYmUgXCJpbWFnZS9wbmdcIiBvciBcImltYWdlL2pwZWdcIi5cbiAgICAgICAgICogIFwiaW1hZ2UvcG5nXCIgaXMgdGhlIGRlZmF1bHRcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF0geCBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XSB5IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSB3aWR0aCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdIGhlaWdodCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5xdWFsaXR5XSBqcGVnIHF1YWxpdHkuICBJZiB1c2luZyBhbiBcImltYWdlL2pwZWdcIiBtaW1lVHlwZSxcbiAgICAgICAgICogIHlvdSBjYW4gc3BlY2lmeSB0aGUgcXVhbGl0eSBmcm9tIDAgdG8gMSwgd2hlcmUgMCBpcyB2ZXJ5IHBvb3IgcXVhbGl0eSBhbmQgMVxuICAgICAgICAgKiAgaXMgdmVyeSBoaWdoIHF1YWxpdHlcbiAgICAgICAgICovXG4gICAgICAgIHRvRGF0YVVSTDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICAgICAgICAgIHZhciBtaW1lVHlwZSA9IGNvbmZpZy5taW1lVHlwZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHF1YWxpdHkgPSBjb25maWcucXVhbGl0eSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHggPSBjb25maWcueCB8fCAwLFxuICAgICAgICAgICAgICAgIHkgPSBjb25maWcueSB8fCAwLFxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IG5ldyBLb252YS5TY2VuZUNhbnZhcyh7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb25maWcud2lkdGggfHwgdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNvbmZpZy5oZWlnaHQgfHwgdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxSYXRpbzogY29uZmlnLnBpeGVsUmF0aW9cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBfY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCkuX2NvbnRleHQsXG4gICAgICAgICAgICAgICAgbGF5ZXJzID0gdGhpcy5jaGlsZHJlbjtcblxuICAgICAgICAgICAgaWYoeCB8fCB5KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQudHJhbnNsYXRlKC0xICogeCwgLTEgKiB5KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBsYXllcnMuZWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGxheWVyLmdldENhbnZhcygpLmdldFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGxheWVyLmdldENhbnZhcygpLmdldEhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IGxheWVyLmdldENhbnZhcygpLmdldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5kcmF3SW1hZ2UobGF5ZXIuZ2V0Q2FudmFzKCkuX2NhbnZhcywgMCwgMCwgd2lkdGggLyByYXRpbywgaGVpZ2h0IC8gcmF0aW8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgc3JjID0gY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcuY2FsbGJhY2soc3JjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbnZlcnRzIHN0YWdlIGludG8gYW4gaW1hZ2UuXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5jYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCB3aGVuIHRoZSBjb21wb3NpdGUgaGFzIGNvbXBsZXRlZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5taW1lVHlwZV0gY2FuIGJlIFwiaW1hZ2UvcG5nXCIgb3IgXCJpbWFnZS9qcGVnXCIuXG4gICAgICAgICAqICBcImltYWdlL3BuZ1wiIGlzIHRoZSBkZWZhdWx0XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdIHggcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV0geSBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF0gd2lkdGggb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XSBoZWlnaHQgb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucXVhbGl0eV0ganBlZyBxdWFsaXR5LiAgSWYgdXNpbmcgYW4gXCJpbWFnZS9qcGVnXCIgbWltZVR5cGUsXG4gICAgICAgICAqICB5b3UgY2FuIHNwZWNpZnkgdGhlIHF1YWxpdHkgZnJvbSAwIHRvIDEsIHdoZXJlIDAgaXMgdmVyeSBwb29yIHF1YWxpdHkgYW5kIDFcbiAgICAgICAgICogIGlzIHZlcnkgaGlnaCBxdWFsaXR5XG4gICAgICAgICAqL1xuICAgICAgICB0b0ltYWdlOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBjYiA9IGNvbmZpZy5jYWxsYmFjaztcblxuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrID0gZnVuY3Rpb24oZGF0YVVybCkge1xuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwuX2dldEltYWdlKGRhdGFVcmwsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgICAgICAgICBjYihpbWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudG9EYXRhVVJMKGNvbmZpZyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdmlzaWJsZSBpbnRlcnNlY3Rpb24gc2hhcGUuIFRoaXMgaXMgdGhlIHByZWZlcnJlZFxuICAgICAgICAgKiAgbWV0aG9kIGZvciBkZXRlcm1pbmluZyBpZiBhIHBvaW50IGludGVyc2VjdHMgYSBzaGFwZSBvciBub3RcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yXVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIHNoYXBlID0gc3RhZ2UuZ2V0SW50ZXJzZWN0aW9uKHt4OiA1MCwgeTogNTB9KTtcbiAgICAgICAgICogLy8gb3IgaWYgeW91IGludGVyZXN0ZWQgaW4gc2hhcGUgcGFyZW50OlxuICAgICAgICAgKiB2YXIgZ3JvdXAgPSBzdGFnZS5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0sICdHcm91cCcpO1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbihwb3MsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5nZXRDaGlsZHJlbigpLFxuICAgICAgICAgICAgICAgIGxlbiA9IGxheWVycy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZW5kID0gbGVuIC0gMSxcbiAgICAgICAgICAgICAgICBuLCBzaGFwZTtcblxuICAgICAgICAgICAgZm9yKG4gPSBlbmQ7IG4gPj0gMDsgbi0tKSB7XG4gICAgICAgICAgICAgICAgc2hhcGUgPSBsYXllcnNbbl0uZ2V0SW50ZXJzZWN0aW9uKHBvcywgc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgX3Jlc2l6ZURPTTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgIGxheWVycyA9IHRoaXMuZ2V0Q2hpbGRyZW4oKSxcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gbGF5ZXJzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgbiwgbGF5ZXI7XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgY29udGVudCBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyBQWDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgUFg7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlckNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVySGl0Q2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgbGF5ZXIgZGltZW5zaW9uc1xuICAgICAgICAgICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyID0gbGF5ZXJzW25dO1xuICAgICAgICAgICAgICAgICAgICBsYXllci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBsYXllci5kcmF3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogYWRkIGxheWVyIG9yIGxheWVycyB0byBzdGFnZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHsuLi5Lb252YS5MYXllcn0gbGF5ZXJcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogc3RhZ2UuYWRkKGxheWVyMSwgbGF5ZXIyLCBsYXllcjMpO1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIGxheWVyKTtcbiAgICAgICAgICAgIGxheWVyLl9zZXRDYW52YXNTaXplKHRoaXMud2lkdGgoKSwgdGhpcy5oZWlnaHQoKSk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgbGF5ZXIgYW5kIGFwcGVuZCBjYW52YXMgdG8gY29udGFpbmVyXG4gICAgICAgICAgICBsYXllci5kcmF3KCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQobGF5ZXIuY2FudmFzLl9jYW52YXMpO1xuXG4gICAgICAgICAgICAvLyBjaGFpbmFibGVcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldExheWVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJucyBhIHtAbGluayBLb252YS5Db2xsZWN0aW9ufSBvZiBsYXllcnNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2JpbmRDb250ZW50RXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZXZlbnRzTGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICBhZGRFdmVudCh0aGlzLCBFVkVOVFNbbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfbW91c2VvdmVyOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIGlmICghS29udmEuVUEubW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX01PVVNFT1ZFUiwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9tb3VzZW91dDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICBpZiAoIUtvbnZhLlVBLm1vYmlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IHRoaXMudGFyZ2V0U2hhcGU7XG5cbiAgICAgICAgICAgICAgICBpZih0YXJnZXRTaGFwZSAmJiAhS29udmEuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFT1VULCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VMRUFWRSwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJQb3MgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VPVVQsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfbW91c2Vtb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxuICAgICAgICAgICAgaWYgKEtvbnZhLlVBLmllTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNobW92ZShldnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmYWtlIG1vdXNlbW92ZSBldmVudCBpbiBjaHJvbWUgYnJvd3NlciBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTYxNDY0XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBldnQubW92ZW1lbnRYICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZXZ0Lm1vdmVtZW50WSAhPT0gJ3VuZGVmaW5lZCcpICYmIGV2dC5tb3ZlbWVudFkgPT09IDAgJiYgZXZ0Lm1vdmVtZW50WCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEtvbnZhLlVBLm1vYmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICB2YXIgc2hhcGU7XG5cbiAgICAgICAgICAgIGlmICghS29udmEuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcbiAgICAgICAgICAgICAgICBpZihzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFLb252YS5pc0RyYWdnaW5nKCkgJiYgKCF0aGlzLnRhcmdldFNoYXBlIHx8IHRoaXMudGFyZ2V0U2hhcGUuX2lkICE9PSBzaGFwZS5faWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnRhcmdldFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRU9VVCwge2V2dDogZXZ0fSwgc2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VMRUFWRSwge2V2dDogZXZ0fSwgc2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVkVSLCB7ZXZ0OiBldnR9LCB0aGlzLnRhcmdldFNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFRU5URVIsIHtldnQ6IGV2dH0sIHRoaXMudGFyZ2V0U2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZSA9IHNoYXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VNT1ZFLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGlmIG5vIHNoYXBlIHdhcyBkZXRlY3RlZCwgY2xlYXIgdGFyZ2V0IHNoYXBlIGFuZCB0cnlcbiAgICAgICAgICAgICAgICAgKiB0byBydW4gbW91c2VvdXQgZnJvbSBwcmV2aW91cyB0YXJnZXQgc2hhcGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy50YXJnZXRTaGFwZSAmJiAhS29udmEuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFT1VULCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VMRUFWRSwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29udGVudCBldmVudFxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRU1PVkUsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhbHdheXMgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3IgZGVza3RvcCBldmVudHMgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyB0cnkgdG8gZHJhZyBhbmQgZHJvcCB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX21vdXNlZG93bjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBtb2JpbGUgSUUgdG8gZm9yY2UgdG91Y2ggZXZlbnQgd2hlbiB1bmhhbmRsZWQgcG9pbnRlciBldmVudCBlbGV2YXRlcyBpbnRvIGEgbW91c2UgZXZlbnRcbiAgICAgICAgICAgIGlmIChLb252YS5VQS5pZU1vYmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3VjaHN0YXJ0KGV2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUtvbnZhLlVBLm1vYmlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xuXG4gICAgICAgICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlja1N0YXJ0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VET1dOLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjb250ZW50IGV2ZW50XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX01PVVNFRE9XTiwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsd2F5cyBjYWxsIHByZXZlbnREZWZhdWx0IGZvciBkZXNrdG9wIGV2ZW50cyBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIHRyeSB0byBkcmFnIGFuZCBkcm9wIHRoZSBjYW52YXMgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfbW91c2V1cDogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxuICAgICAgICAgICAgaWYgKEtvbnZhLlVBLmllTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvdWNoZW5kKGV2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUtvbnZhLlVBLm1vYmlsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpLFxuICAgICAgICAgICAgICAgICAgICBjbGlja1N0YXJ0U2hhcGUgPSB0aGlzLmNsaWNrU3RhcnRTaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgZmlyZURibENsaWNrID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRkID0gS29udmEuREQ7XG5cbiAgICAgICAgICAgICAgICBpZihLb252YS5pbkRibENsaWNrV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVEYmxDbGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc2V0IGluRGJsQ2xpY2tXaW5kb3cgYWZ0ZXIgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZGQgfHwgIWRkLmp1c3REcmFnZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGQuanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBLb252YS5pbkRibENsaWNrV2luZG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgS29udmEuZGJsQ2xpY2tXaW5kb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VVUCwge2V2dDogZXZ0fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZWN0IGlmIGNsaWNrIG9yIGRvdWJsZSBjbGljayBvY2N1cnJlZFxuICAgICAgICAgICAgICAgICAgICBpZihLb252YS5saXN0ZW5DbGlja1RhcCAmJiBjbGlja1N0YXJ0U2hhcGUgJiYgY2xpY2tTdGFydFNoYXBlLl9pZCA9PT0gc2hhcGUuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShDTElDSywge2V2dDogZXZ0fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZpcmVEYmxDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKERCTF9DTElDSywge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY29udGVudCBldmVudHNcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VVUCwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgaWYgKEtvbnZhLmxpc3RlbkNsaWNrVGFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9DTElDSywge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGZpcmVEYmxDbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX0RCTF9DTElDSywge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBLb252YS5saXN0ZW5DbGlja1RhcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhbHdheXMgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3IgZGVza3RvcCBldmVudHMgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyB0cnkgdG8gZHJhZyBhbmQgZHJvcCB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3RvdWNoc3RhcnQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcblxuICAgICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFwU3RhcnRTaGFwZSA9IHNoYXBlO1xuICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKFRPVUNIU1RBUlQsIHtldnQ6IGV2dH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gb25seSBjYWxsIHByZXZlbnREZWZhdWx0IGlmIHRoZSBzaGFwZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZS5pc0xpc3RlbmluZygpICYmIHNoYXBlLnByZXZlbnREZWZhdWx0KCkgJiYgZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnRlbnQgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9UT1VDSFNUQVJULCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgfSxcbiAgICAgICAgX3RvdWNoZW5kOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSksXG4gICAgICAgICAgICAgICAgZmlyZURibENsaWNrID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmKEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICBmaXJlRGJsQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIEtvbnZhLmRibENsaWNrV2luZG93KTtcblxuICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShUT1VDSEVORCwge2V2dDogZXZ0fSk7XG5cbiAgICAgICAgICAgICAgICAvLyBkZXRlY3QgaWYgdGFwIG9yIGRvdWJsZSB0YXAgb2NjdXJyZWRcbiAgICAgICAgICAgICAgICBpZihLb252YS5saXN0ZW5DbGlja1RhcCAmJiB0aGlzLnRhcFN0YXJ0U2hhcGUgJiYgc2hhcGUuX2lkID09PSB0aGlzLnRhcFN0YXJ0U2hhcGUuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKFRBUCwge2V2dDogZXZ0fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoZmlyZURibENsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShEQkxfVEFQLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNhbGwgcHJldmVudERlZmF1bHQgaWYgdGhlIHNoYXBlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlLmlzTGlzdGVuaW5nKCkgJiYgc2hhcGUucHJldmVudERlZmF1bHQoKSAmJiBldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udGVudCBldmVudHNcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9UT1VDSEVORCwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICBpZiAoS29udmEubGlzdGVuQ2xpY2tUYXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfVEFQLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgICAgICAgICBpZihmaXJlRGJsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX0RCTF9UQVAsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgX3RvdWNobW92ZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgICAgIHZhciBkZCA9IEtvbnZhLkRELFxuICAgICAgICAgICAgICAgIHNoYXBlO1xuICAgICAgICAgICAgaWYgKCFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKFRPVUNITU9WRSwge2V2dDogZXZ0fSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgY2FsbCBwcmV2ZW50RGVmYXVsdCBpZiB0aGUgc2hhcGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlLmlzTGlzdGVuaW5nKCkgJiYgc2hhcGUucHJldmVudERlZmF1bHQoKSAmJiBldnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9UT1VDSE1PVkUsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoS29udmEuaXNEcmFnZ2luZygpICYmIEtvbnZhLkRELm5vZGUucHJldmVudERlZmF1bHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9ET01Nb3VzZVNjcm9sbDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB0aGlzLl9tb3VzZXdoZWVsKGV2dCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9tb3VzZXdoZWVsOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XG5cbiAgICAgICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoV0hFRUwsIHtldnQ6IGV2dH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX1dIRUVMLCB7ZXZ0OiBldnR9KTtcbiAgICAgICAgfSxcbiAgICAgICAgX3doZWVsOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHRoaXMuX21vdXNld2hlZWwoZXZ0KTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldFBvaW50ZXJQb3NpdGlvbjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB2YXIgY29udGVudFBvc2l0aW9uID0gdGhpcy5fZ2V0Q29udGVudFBvc2l0aW9uKCksXG4gICAgICAgICAgICAgICAgeCA9IG51bGwsXG4gICAgICAgICAgICAgICAgeSA9IG51bGw7XG4gICAgICAgICAgICBldnQgPSBldnQgPyBldnQgOiB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgICAgIC8vIHRvdWNoIGV2ZW50c1xuICAgICAgICAgICAgaWYoZXZ0LnRvdWNoZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseSwgb25seSBoYW5kbGUgb25lIGZpbmdlclxuICAgICAgICAgICAgICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZ0LnRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5mb3JtYXRpb24gZm9yIGZpbmdlciAjMVxuICAgICAgICAgICAgICAgICAgICB4ID0gdG91Y2guY2xpZW50WCAtIGNvbnRlbnRQb3NpdGlvbi5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICB5ID0gdG91Y2guY2xpZW50WSAtIGNvbnRlbnRQb3NpdGlvbi50b3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW91c2UgZXZlbnRzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gZXZ0LmNsaWVudFggLSBjb250ZW50UG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgICAgICB5ID0gZXZ0LmNsaWVudFkgLSBjb250ZW50UG9zaXRpb24udG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggIT09IG51bGwgJiYgeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRDb250ZW50UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gdGhpcy5jb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogeyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIF9idWlsZERPTTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKEtvbnZhLlV0aWwuaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1N0YWdlIGhhcyBubyBjb250YWluZXIuIEEgY29udGFpbmVyIGlzIHJlcXVpcmVkLic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBjcmVhdGUgZWxlbWVudCBmb3IganNkb20gaW4gbm9kZWpzIGVudlxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSBLb252YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KERJVik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xlYXIgY29udGVudCBpbnNpZGUgY29udGFpbmVyXG4gICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gRU1QVFlfU1RSSU5HO1xuXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBLb252YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KERJVik7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUucG9zaXRpb24gPSBSRUxBVElWRTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5jbGFzc05hbWUgPSBLT05WQV9DT05URU5UO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xuXG4gICAgICAgICAgICAvLyB0aGUgYnVmZmVyIGNhbnZhcyBwaXhlbCByYXRpbyBtdXN0IGJlIDEgYmVjYXVzZSBpdCBpcyB1c2VkIGFzIGFuXG4gICAgICAgICAgICAvLyBpbnRlcm1lZGlhdGUgY2FudmFzIGJlZm9yZSBjb3B5aW5nIHRoZSByZXN1bHQgb250byBhIHNjZW5lIGNhbnZhcy5cbiAgICAgICAgICAgIC8vIG5vdCBzZXR0aW5nIGl0IHRvIDEgd2lsbCByZXN1bHQgaW4gYW4gb3ZlciBjb21wZW5zYXRpb25cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckhpdENhbnZhcyA9IG5ldyBLb252YS5IaXRDYW52YXMoe3BpeGVsUmF0aW86IDF9KTtcblxuICAgICAgICAgICAgdGhpcy5fcmVzaXplRE9NKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9vbkNvbnRlbnQ6IGZ1bmN0aW9uKHR5cGVzU3RyLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgdHlwZXMgPSB0eXBlc1N0ci5zcGxpdChTUEFDRSksXG4gICAgICAgICAgICAgICAgbGVuID0gdHlwZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG4sIGJhc2VFdmVudDtcblxuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBiYXNlRXZlbnQgPSB0eXBlc1tuXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlRXZlbnQsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gY3VycmVudGx5IGNhY2hlIGZ1bmN0aW9uIGlzIG5vdyB3b3JraW5nIGZvciBzdGFnZSwgYmVjYXVzZSBzdGFnZSBoYXMgbm8gaXRzIG93biBjYW52YXMgZWxlbWVudFxuICAgICAgICAvLyBUT0RPOiBtYXkgYmUgaXQgaXMgYmV0dGVyIHRvIGNhY2hlIGFsbCBjaGlsZHJlbiBsYXllcnM/XG4gICAgICAgIGNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEtvbnZhLlV0aWwud2FybignQ2FjaGUgZnVuY3Rpb24gaXMgbm90IGFsbG93ZWQgZm9yIHN0YWdlLiBZb3UgbWF5IHVzZSBjYWNoZSBvbmx5IGZvciBsYXllcnMsIGdyb3VwcyBhbmQgc2hhcGVzLicpO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlN0YWdlLCBLb252YS5Db250YWluZXIpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5TdGFnZSwgJ2NvbnRhaW5lcicpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5TdGFnZSwgJ2NvbnRhaW5lcicpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGNvbnRhaW5lciBET00gZWxlbWVudFxuICAgICAqIEBuYW1lIGNvbnRhaW5lclxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0RvbUVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNvbnRhaW5lclxuICAgICAqIHZhciBjb250YWluZXIgPSBzdGFnZS5jb250YWluZXIoKTtcbiAgICAgKiAvLyBzZXQgY29udGFpbmVyXG4gICAgICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAqIGJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgKiBzdGFnZS5jb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgKi9cblxufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBCYXNlTGF5ZXIgY29uc3RydWN0b3IuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLkNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xlYXJCZWZvcmVEcmF3XSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudFxuICAgICAqIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggbGF5ZXIgZHJhdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNsaXBGdW5jXSBzZXQgY2xpcCBmdW5jXG5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsYXllciA9IG5ldyBLb252YS5MYXllcigpO1xuICAgICAqL1xuICAgIEtvbnZhLkJhc2VMYXllciA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLkJhc2VMYXllciwge1xuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPSAnTGF5ZXInO1xuICAgICAgICAgICAgS29udmEuQ29udGFpbmVyLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlUE5HU3RyZWFtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5fY2FudmFzLmNyZWF0ZVBOR1N0cmVhbSgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGxheWVyIGNhbnZhc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGxheWVyIGhpdCBjYW52YXNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGl0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpdENhbnZhcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBsYXllciBjYW52YXMgY29udGV4dFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENhbnZhcygpLmdldENvbnRleHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsZWFyIHNjZW5lIGFuZCBoaXQgY2FudmFzIGNvbnRleHRzIHRpZWQgdG8gdGhlIGxheWVyXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtib3VuZHNdXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLnhdXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLnldXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLndpZHRoXVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy5oZWlnaHRdXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGxheWVyLmNsZWFyKCk7XG4gICAgICAgICAqIGxheWVyLmNsZWFyKHtcbiAgICAgICAgICogICB4IDogMCxcbiAgICAgICAgICogICB5IDogMCxcbiAgICAgICAgICogICB3aWR0aCA6IDEwMCxcbiAgICAgICAgICogICBoZWlnaHQgOiAxMDBcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgICAgICAgICB0aGlzLmdldENvbnRleHQoKS5jbGVhcihib3VuZHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFySGl0Q2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUuc2V0WkluZGV4XG4gICAgICAgIHNldFpJbmRleDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFpJbmRleC5jYWxsKHRoaXMsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgIGlmKHN0YWdlKSB7XG4gICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuXG4gICAgICAgICAgICAgICAgaWYoaW5kZXggPCBzdGFnZS5nZXRDaGlsZHJlbigpLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5pbnNlcnRCZWZvcmUodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLCBzdGFnZS5nZXRDaGlsZHJlbigpW2luZGV4ICsgMV0uZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5tb3ZlVG9Ub3BcbiAgICAgICAgbW92ZVRvVG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLm1vdmVUb1RvcC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICAgICAgaWYoc3RhZ2UpIHtcbiAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgICAgICAgc3RhZ2UuY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5tb3ZlVXBcbiAgICAgICAgbW92ZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBtb3ZlZCA9IEtvbnZhLk5vZGUucHJvdG90eXBlLm1vdmVVcC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlZCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgICAgICBpZighc3RhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcblxuICAgICAgICAgICAgaWYodGhpcy5pbmRleCA8IHN0YWdlLmdldENoaWxkcmVuKCkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcywgc3RhZ2UuZ2V0Q2hpbGRyZW4oKVt0aGlzLmluZGV4ICsgMV0uZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUubW92ZURvd25cbiAgICAgICAgbW92ZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYoS29udmEuTm9kZS5wcm90b3R5cGUubW92ZURvd24uY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgICAgICBpZihzdGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBzdGFnZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcywgY2hpbGRyZW5bdGhpcy5pbmRleCArIDFdLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUubW92ZVRvQm90dG9tXG4gICAgICAgIG1vdmVUb0JvdHRvbTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZihLb252YS5Ob2RlLnByb3RvdHlwZS5tb3ZlVG9Cb3R0b20uY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgICAgICAgICBpZihzdGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBzdGFnZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWdlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcywgY2hpbGRyZW5bMV0uZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGdldExheWVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9jYW52YXMgPSB0aGlzLmdldENhbnZhcygpLl9jYW52YXM7XG5cbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICBpZihfY2FudmFzICYmIF9jYW52YXMucGFyZW50Tm9kZSAmJiBLb252YS5VdGlsLl9pc0luRG9jdW1lbnQoX2NhbnZhcykpIHtcbiAgICAgICAgICAgICAgICBfY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX2NhbnZhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQvc2V0IHdpZHRoIG9mIGxheWVyLmdldHRlciByZXR1cm4gd2lkdGggb2Ygc3RhZ2UuIHNldHRlciBkb2luZyBub3RoaW5nLlxuICAgICAgICAgKiBpZiB5b3Ugd2FudCBjaGFuZ2Ugd2lkdGggdXNlIGBzdGFnZS53aWR0aCh2YWx1ZSk7YFxuICAgICAgICAgKiBAbmFtZSB3aWR0aFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIHZhciB3aWR0aCA9IGxheWVyLndpZHRoKCk7XG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdDYW4gbm90IGNoYW5nZSB3aWR0aCBvZiBsYXllci4gVXNlIFwic3RhZ2Uud2lkdGgodmFsdWUpXCIgZnVuY3Rpb24gaW5zdGVhZC4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldC9zZXQgaGVpZ2h0IG9mIGxheWVyLmdldHRlciByZXR1cm4gaGVpZ2h0IG9mIHN0YWdlLiBzZXR0ZXIgZG9pbmcgbm90aGluZy5cbiAgICAgICAgICogaWYgeW91IHdhbnQgY2hhbmdlIGhlaWdodCB1c2UgYHN0YWdlLmhlaWdodCh2YWx1ZSk7YFxuICAgICAgICAgKiBAbmFtZSBoZWlnaHRcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgaGVpZ2h0ID0gbGF5ZXIuaGVpZ2h0KCk7XG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgS29udmEuVXRpbC53YXJuKCdDYW4gbm90IGNoYW5nZSBoZWlnaHQgb2YgbGF5ZXIuIFVzZSBcInN0YWdlLmhlaWdodCh2YWx1ZSlcIiBmdW5jdGlvbiBpbnN0ZWFkLicpO1xuICAgICAgICB9LFxuICAgICAgICAvLyB0aGUgYXBwbHkgdHJhbnNmb3JtIG1ldGhvZCBpcyBoYW5kbGVkIGJ5IHRoZSBMYXllciBhbmQgRmFzdExheWVyIGNsYXNzXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgaXMgdXAgdG8gdGhlIGxheWVyIHRvIGRlY2lkZSBpZiBhbiBhYnNvbHV0ZSBvciByZWxhdGl2ZSB0cmFuc2Zvcm1cbiAgICAgICAgLy8gc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgX2FwcGx5VHJhbnNmb3JtOiBmdW5jdGlvbihzaGFwZSwgY29udGV4dCwgdG9wKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHNoYXBlLmdldEFic29sdXRlVHJhbnNmb3JtKHRvcCkuZ2V0TWF0cml4KCk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkJhc2VMYXllciwgS29udmEuQ29udGFpbmVyKTtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQmFzZUxheWVyLCAnY2xlYXJCZWZvcmVEcmF3JywgdHJ1ZSk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBjbGVhckJlZm9yZURyYXcgZmxhZyB3aGljaCBkZXRlcm1pbmVzIGlmIHRoZSBsYXllciBpcyBjbGVhcmVkIG9yIG5vdFxuICAgICAqICBiZWZvcmUgZHJhd2luZ1xuICAgICAqIEBuYW1lIGNsZWFyQmVmb3JlRHJhd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXJCZWZvcmVEcmF3XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xlYXJCZWZvcmVEcmF3IGZsYWdcbiAgICAgKiB2YXIgY2xlYXJCZWZvcmVEcmF3ID0gbGF5ZXIuY2xlYXJCZWZvcmVEcmF3KCk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIGNsZWFyIGJlZm9yZSBkcmF3XG4gICAgICogbGF5ZXIuY2xlYXJCZWZvcmVEcmF3KGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGVuYWJsZSBjbGVhciBiZWZvcmUgZHJhd1xuICAgICAqIGxheWVyLmNsZWFyQmVmb3JlRHJhdyh0cnVlKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5CYXNlTGF5ZXIpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBjb25zdGFudHNcbiAgICB2YXIgSEFTSCA9ICcjJyxcbiAgICAgICAgQkVGT1JFX0RSQVcgPSAnYmVmb3JlRHJhdycsXG4gICAgICAgIERSQVcgPSAnZHJhdycsXG5cbiAgICAgICAgLypcbiAgICAgICAgICogMiAtIDMgLSA0XG4gICAgICAgICAqIHwgICAgICAgfFxuICAgICAgICAgKiAxIC0gMCAgIDVcbiAgICAgICAgICogICAgICAgICB8XG4gICAgICAgICAqIDggLSA3IC0gNlxuICAgICAgICAgKi9cbiAgICAgICAgSU5URVJTRUNUSU9OX09GRlNFVFMgPSBbXG4gICAgICAgICAgICB7eDogMCwgeTogMH0sICAvLyAwXG4gICAgICAgICAgICB7eDogLTEsIHk6IDB9LCAvLyAxXG4gICAgICAgICAgICB7eDogLTEsIHk6IC0xfSwgLy8gMlxuICAgICAgICAgICAge3g6IDAsIHk6IC0xfSwgLy8gM1xuICAgICAgICAgICAge3g6IDEsIHk6IC0xfSwgLy8gNFxuICAgICAgICAgICAge3g6IDEsIHk6IDB9LCAvLyA1XG4gICAgICAgICAgICB7eDogMSwgeTogMX0sIC8vIDZcbiAgICAgICAgICAgIHt4OiAwLCB5OiAxfSwgLy8gN1xuICAgICAgICAgICAge3g6IC0xLCB5OiAxfSAgLy8gOFxuICAgICAgICBdLFxuICAgICAgICBJTlRFUlNFQ1RJT05fT0ZGU0VUU19MRU4gPSBJTlRFUlNFQ1RJT05fT0ZGU0VUUy5sZW5ndGg7XG5cbiAgICAvKipcbiAgICAgKiBMYXllciBjb25zdHJ1Y3Rvci4gIExheWVycyBhcmUgdGllZCB0byB0aGVpciBvd24gY2FudmFzIGVsZW1lbnQgYW5kIGFyZSB1c2VkXG4gICAgICogdG8gY29udGFpbiBncm91cHMgb3Igc2hhcGVzLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5CYXNlTGF5ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsZWFyQmVmb3JlRHJhd10gc2V0IHRoaXMgcHJvcGVydHkgdG8gZmFsc2UgaWYgeW91IGRvbid0IHdhbnRcbiAgICAgKiB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBlYWNoIGxheWVyIGRyYXcuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5jbGlwXSBzZXQgY2xpcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBYXSBzZXQgY2xpcCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFldIHNldCBjbGlwIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwV2lkdGhdIHNldCBjbGlwIHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcEhlaWdodF0gc2V0IGNsaXAgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5jbGlwRnVuY10gc2V0IGNsaXAgZnVuY1xuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbGF5ZXIgPSBuZXcgS29udmEuTGF5ZXIoKTtcbiAgICAgKi9cbiAgICBLb252YS5MYXllciA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5MYXllciwge1xuICAgICAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVUeXBlID0gJ0xheWVyJztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKCk7XG4gICAgICAgICAgICB0aGlzLmhpdENhbnZhcyA9IG5ldyBLb252YS5IaXRDYW52YXMoe1xuICAgICAgICAgICAgICAgIHBpeGVsUmF0aW86IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuQmFzZUxheWVyLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldENhbnZhc1NpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmhpdENhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGNoaWxkLmdldFR5cGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAnR3JvdXAnICYmIHR5cGUgIT09ICdTaGFwZScpIHtcbiAgICAgICAgICAgICAgICBLb252YS5VdGlsLnRocm93KCdZb3UgbWF5IG9ubHkgYWRkIGdyb3VwcyBhbmQgc2hhcGVzIHRvIGEgbGF5ZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdmlzaWJsZSBpbnRlcnNlY3Rpb24gc2hhcGUuIFRoaXMgaXMgdGhlIHByZWZlcnJlZFxuICAgICAgICAgKiBtZXRob2QgZm9yIGRldGVybWluaW5nIGlmIGEgcG9pbnQgaW50ZXJzZWN0cyBhIHNoYXBlIG9yIG5vdFxuICAgICAgICAgKiBhbHNvIHlvdSBtYXkgcGFzcyBvcHRpb25hbCBzZWxlY3RvciBwYXJhbWV0ciB0byByZXR1cm4gYW5jZXN0b3Igb2YgaW50ZXJzZWN0ZWQgc2hhcGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy54XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yXVxuICAgICAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogdmFyIHNoYXBlID0gbGF5ZXIuZ2V0SW50ZXJzZWN0aW9uKHt4OiA1MCwgeTogNTB9KTtcbiAgICAgICAgICogLy8gb3IgaWYgeW91IGludGVyZXN0ZWQgaW4gc2hhcGUgcGFyZW50OlxuICAgICAgICAgKiB2YXIgZ3JvdXAgPSBsYXllci5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0sICdHcm91cCcpO1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbihwb3MsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgb2JqLCBpLCBpbnRlcnNlY3Rpb25PZmZzZXQsIHNoYXBlO1xuXG4gICAgICAgICAgICBpZighdGhpcy5oaXRHcmFwaEVuYWJsZWQoKSB8fCAhdGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW4gc29tZSBjYXNlcyBhbnRpYWxpYXNlZCBhcmVhIG1heSBiZSBiaWdnZXIgdGhhbiAxcHhcbiAgICAgICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIGlmIHdlIHdpbGwgY2FjaGUgbm9kZSwgdGhlbiBzY2FsZSBpdCBhIGxvdFxuICAgICAgICAgICAgLy8gVE9ETzogY2hlY2sgeyAwOyAwIH0gcG9pbnQgYmVmb3JlIGxvb3AsIGFuZCByZW1vdmUgaXQgZnJvbSBJTlRFUlNFQ1RJT05fT0ZGU0VUUy5cbiAgICAgICAgICAgIHZhciBzcGlyYWxTZWFyY2hEaXN0YW5jZSA9IDE7XG4gICAgICAgICAgICB2YXIgY29udGludWVTZWFyY2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IElOVEVSU0VDVElPTl9PRkZTRVRTX0xFTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbk9mZnNldCA9IElOVEVSU0VDVElPTl9PRkZTRVRTW2ldO1xuICAgICAgICAgICAgICAgICAgICBvYmogPSB0aGlzLl9nZXRJbnRlcnNlY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcG9zLnggKyBpbnRlcnNlY3Rpb25PZmZzZXQueCAqIHNwaXJhbFNlYXJjaERpc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcG9zLnkgKyBpbnRlcnNlY3Rpb25PZmZzZXQueSAqIHNwaXJhbFNlYXJjaERpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzaGFwZSA9IG9iai5zaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlICYmIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGUuZmluZEFuY2VzdG9yKHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBjb250aW51ZSBzZWFyY2ggaWYgd2UgZm91bmQgYW50aWFsaWFzZWQgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBtZWFucyBvdXIgbm9kZSBzb21ld2hlcmUgdmVyeSBjbG9zZVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVNlYXJjaCA9ICEhb2JqLmFudGlhbGlhc2VkO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHNlYXJjaCBpZiBmb3VuZCBlbXB0eSBwaXhlbFxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9iai5hbnRpYWxpYXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gc2hhcGUsIGFuZCBubyBhbnRpYWxpYXNlZCBwaXhlbCwgd2Ugc2hvdWxkIGVuZCBzZWFyY2hpbmdcbiAgICAgICAgICAgICAgICBpZiAoY29udGludWVTZWFyY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BpcmFsU2VhcmNoRGlzdGFuY2UgKz0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRJbWFnZURhdGE6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuaGl0Q2FudmFzLndpZHRoIHx8IDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oaXRDYW52YXMuaGVpZ2h0IHx8IDEsXG4gICAgICAgICAgICAgICAgaW5kZXggPSAoTWF0aC5yb3VuZCh5KSAqIHdpZHRoICkgKyBNYXRoLnJvdW5kKHgpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hpdEltYWdlRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YSA9IHRoaXMuaGl0Q2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YS5kYXRhWzQgKiBpbmRleCArIDBdLCAvLyBSZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEuZGF0YVs0ICogaW5kZXggKyAxXSwgLy8gR3JlZW5cbiAgICAgICAgICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEuZGF0YVs0ICogaW5kZXggKyAyXSwgLy8gQmx1ZVxuICAgICAgICAgICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YS5kYXRhWzQgKiBpbmRleCArIDNdIC8vIEFscGhhXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IHRoaXMuaGl0Q2FudmFzLnBpeGVsUmF0aW87XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuaGl0Q2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKE1hdGgucm91bmQocG9zLnggKiByYXRpbyksIE1hdGgucm91bmQocG9zLnkgKiByYXRpbyksIDEsIDEpLmRhdGEsXG4gICAgICAgICAgICAgICAgcDMgPSBwWzNdLFxuICAgICAgICAgICAgICAgIGNvbG9yS2V5LCBzaGFwZTtcbiAgICAgICAgICAgIC8vIGZ1bGx5IG9wYXF1ZSBwaXhlbFxuICAgICAgICAgICAgaWYocDMgPT09IDI1NSkge1xuICAgICAgICAgICAgICAgIGNvbG9yS2V5ID0gS29udmEuVXRpbC5fcmdiVG9IZXgocFswXSwgcFsxXSwgcFsyXSk7XG4gICAgICAgICAgICAgICAgc2hhcGUgPSBLb252YS5zaGFwZXNbSEFTSCArIGNvbG9yS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiBzaGFwZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhbnRpYWxpYXNlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbnRpYWxpYXNlZCBwaXhlbFxuICAgICAgICAgICAgZWxzZSBpZihwMyA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhbnRpYWxpYXNlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbXB0eSBwaXhlbFxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9LFxuICAgICAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbiwgdG9wKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgICAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5nZXRDYW52YXMoKSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoQkVGT1JFX0RSQVcsIHtcbiAgICAgICAgICAgICAgICBub2RlOiB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYodGhpcy5nZXRDbGVhckJlZm9yZURyYXcoKSkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCkuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5kcmF3U2NlbmUuY2FsbCh0aGlzLCBjYW52YXMsIHRvcCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoRFJBVywge1xuICAgICAgICAgICAgICAgIG5vZGU6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZHJhd0hpdDogZnVuY3Rpb24oY2FuLCB0b3ApIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgICAgICAgICBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmhpdENhbnZhcyk7XG5cbiAgICAgICAgICAgIGlmKGxheWVyICYmIGxheWVyLmdldENsZWFyQmVmb3JlRHJhdygpKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZ2V0SGl0Q2FudmFzKCkuZ2V0Q29udGV4dCgpLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZHJhd0hpdC5jYWxsKHRoaXMsIGNhbnZhcywgdG9wKTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VEYXRhID0gbnVsbDsgLy8gQ2xlYXIgaW1hZ2VEYXRhIGNhY2hlXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgICAgICAgICAgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZS5jbGVhci5jYWxsKHRoaXMsIGJvdW5kcyk7XG4gICAgICAgICAgICB0aGlzLmdldEhpdENhbnZhcygpLmdldENvbnRleHQoKS5jbGVhcihib3VuZHMpO1xuICAgICAgICAgICAgdGhpcy5pbWFnZURhdGEgPSBudWxsOyAvLyBDbGVhciBnZXRJbWFnZURhdGEgY2FjaGVcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZVxuICAgICAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRWaXNpYmxlLmNhbGwodGhpcywgdmlzaWJsZSk7XG4gICAgICAgICAgICBpZih2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIHRoaXMuaGl0Q2FudmFzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLmhpdENhbnZhcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGVuYWJsZSBoaXQgZ3JhcGhcbiAgICAgICAgICogQG5hbWUgZW5hYmxlSGl0R3JhcGhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtMYXllcn1cbiAgICAgICAgICovXG4gICAgICAgIGVuYWJsZUhpdEdyYXBoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGl0R3JhcGhFbmFibGVkKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkaXNhYmxlIGhpdCBncmFwaFxuICAgICAgICAgKiBAbmFtZSBkaXNhYmxlSGl0R3JhcGhcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuTGF5ZXIucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtMYXllcn1cbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVIaXRHcmFwaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhpdEdyYXBoRW5hYmxlZChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZS5zZXRTaXplLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmhpdENhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5MYXllciwgS29udmEuQmFzZUxheWVyKTtcblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxheWVyLCAnaGl0R3JhcGhFbmFibGVkJywgdHJ1ZSk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBoaXRHcmFwaEVuYWJsZWQgZmxhZy4gIERpc2FibGluZyB0aGUgaGl0IGdyYXBoIHdpbGwgZ3JlYXRseSBpbmNyZWFzZVxuICAgICAqICBkcmF3IHBlcmZvcm1hbmNlIGJlY2F1c2UgdGhlIGhpdCBncmFwaCB3aWxsIG5vdCBiZSByZWRyYXduIGVhY2ggdGltZSB0aGUgbGF5ZXIgaXNcbiAgICAgKiAgZHJhd24uICBUaGlzLCBob3dldmVyLCBhbHNvIGRpc2FibGVzIG1vdXNlL3RvdWNoIGV2ZW50IGRldGVjdGlvblxuICAgICAqIEBuYW1lIGhpdEdyYXBoRW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTGF5ZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaGl0R3JhcGhFbmFibGVkIGZsYWdcbiAgICAgKiB2YXIgaGl0R3JhcGhFbmFibGVkID0gbGF5ZXIuaGl0R3JhcGhFbmFibGVkKCk7XG4gICAgICpcbiAgICAgKiAvLyBkaXNhYmxlIGhpdCBncmFwaFxuICAgICAqIGxheWVyLmhpdEdyYXBoRW5hYmxlZChmYWxzZSk7XG4gICAgICpcbiAgICAgKiAvLyBlbmFibGUgaGl0IGdyYXBoXG4gICAgICogbGF5ZXIuaGl0R3JhcGhFbmFibGVkKHRydWUpO1xuICAgICAqL1xuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5MYXllcik7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIEZhc3RMYXllciBjb25zdHJ1Y3Rvci4gTGF5ZXJzIGFyZSB0aWVkIHRvIHRoZWlyIG93biBjYW52YXMgZWxlbWVudCBhbmQgYXJlIHVzZWRcbiAgICAgKiB0byBjb250YWluIHNoYXBlcyBvbmx5LiAgSWYgeW91IGRvbid0IG5lZWQgbm9kZSBuZXN0aW5nLCBtb3VzZSBhbmQgdG91Y2ggaW50ZXJhY3Rpb25zLFxuICAgICAqIG9yIGV2ZW50IHB1Yi9zdWIsIHlvdSBzaG91bGQgdXNlIEZhc3RMYXllciBpbnN0ZWFkIG9mIExheWVyIHRvIGNyZWF0ZSB5b3VyIGxheWVycy5cbiAgICAgKiBJdCByZW5kZXJzIGFib3V0IDJ4IGZhc3RlciB0aGFuIG5vcm1hbCBsYXllcnMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLkJhc2VMYXllclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xlYXJCZWZvcmVEcmF3XSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudFxuICAgICAqIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggbGF5ZXIgZHJhdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5jbGlwXSBzZXQgY2xpcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBYXSBzZXQgY2xpcCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFldIHNldCBjbGlwIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwV2lkdGhdIHNldCBjbGlwIHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcEhlaWdodF0gc2V0IGNsaXAgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5jbGlwRnVuY10gc2V0IGNsaXAgZnVuY1xuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbGF5ZXIgPSBuZXcgS29udmEuRmFzdExheWVyKCk7XG4gICAgICovXG4gICAgS29udmEuRmFzdExheWVyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLkZhc3RMYXllciwge1xuICAgICAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVUeXBlID0gJ0xheWVyJztcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKCk7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5CYXNlTGF5ZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICB9LFxuICAgICAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGNoaWxkLmdldFR5cGUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSAnU2hhcGUnKSB7XG4gICAgICAgICAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBzaGFwZXMgdG8gYSBmYXN0IGxheWVyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfc2V0Q2FudmFzU2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgaGl0R3JhcGhFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbikge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICAgICAgICAgIGNhbnZhcyA9IGNhbiB8fCAobGF5ZXIgJiYgbGF5ZXIuZ2V0Q2FudmFzKCkpO1xuXG4gICAgICAgICAgICBpZih0aGlzLmdldENsZWFyQmVmb3JlRHJhdygpKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoKS5jbGVhcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmRyYXdTY2VuZS5jYWxsKHRoaXMsIGNhbnZhcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1NjZW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLnNldFZpc2libGVcbiAgICAgICAgc2V0VmlzaWJsZTogZnVuY3Rpb24odmlzaWJsZSkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZS5jYWxsKHRoaXMsIHZpc2libGUpO1xuICAgICAgICAgICAgaWYodmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5GYXN0TGF5ZXIsIEtvbnZhLkJhc2VMYXllcik7XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuRmFzdExheWVyKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogR3JvdXAgY29uc3RydWN0b3IuICBHcm91cHMgYXJlIHVzZWQgdG8gY29udGFpbiBzaGFwZXMgb3Igb3RoZXIgZ3JvdXBzLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5Db250YWluZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNsaXBGdW5jXSBzZXQgY2xpcCBmdW5jXG5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBncm91cCA9IG5ldyBLb252YS5Hcm91cCgpO1xuICAgICAqL1xuICAgIEtvbnZhLkdyb3VwID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuR3JvdXAsIHtcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVUeXBlID0gJ0dyb3VwJztcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLkNvbnRhaW5lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH0sXG4gICAgICAgIF92YWxpZGF0ZUFkZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gY2hpbGQuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdHcm91cCcgJiYgdHlwZSAhPT0gJ1NoYXBlJykge1xuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwudGhyb3coJ1lvdSBtYXkgb25seSBhZGQgZ3JvdXBzIGFuZCBzaGFwZXMgdG8gZ3JvdXBzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuR3JvdXAsIEtvbnZhLkNvbnRhaW5lcik7XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuR3JvdXApO1xufSkoKTtcblxuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5vdyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKEtvbnZhLmdsb2JhbC5wZXJmb3JtYW5jZSAmJiBLb252YS5nbG9iYWwucGVyZm9ybWFuY2Uubm93KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEtvbnZhLmdsb2JhbC5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIGZ1bmN0aW9uIEZSQUYoY2FsbGJhY2spIHtcbiAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICB9XG5cbiAgICB2YXIgUkFGID0gKGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBLb252YS5nbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICB8fCBLb252YS5nbG9iYWwud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICB8fCBLb252YS5nbG9iYWwubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICB8fCBLb252YS5nbG9iYWwub1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgfHwgS29udmEuZ2xvYmFsLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICB8fCBGUkFGO1xuICAgIH0pKCk7XG5cblxuXG4gICAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFJBRi5hcHBseShLb252YS5nbG9iYWwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0aW9uIGNvbnN0cnVjdG9yLiAgQSBzdGFnZSBpcyB1c2VkIHRvIGNvbnRhaW4gbXVsdGlwbGUgbGF5ZXJzIGFuZCBoYW5kbGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIGZ1bmN0aW9uIGV4ZWN1dGVkIG9uIGVhY2ggYW5pbWF0aW9uIGZyYW1lLiAgVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGZyYW1lIG9iamVjdCwgd2hpY2ggY29udGFpbnNcbiAgICAgKiAgdGltZURpZmYsIGxhc3RUaW1lLCB0aW1lLCBhbmQgZnJhbWVSYXRlIHByb3BlcnRpZXMuICBUaGUgdGltZURpZmYgcHJvcGVydHkgaXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIHBhc3NlZFxuICAgICAqICBzaW5jZSB0aGUgbGFzdCBhbmltYXRpb24gZnJhbWUuICBUaGUgbGFzdFRpbWUgcHJvcGVydHkgaXMgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCBlbGFwc2VkIGZyb20gdGhlIG1vbWVudCB0aGUgYW5pbWF0aW9uIHN0YXJ0ZWRcbiAgICAgKiAgdG8gdGhlIGxhc3QgYW5pbWF0aW9uIGZyYW1lLiAgVGhlIHRpbWUgcHJvcGVydHkgaXMgdGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRoYXQgZWxsYXBzZWQgZnJvbSB0aGUgbW9tZW50IHRoZSBhbmltYXRpb24gc3RhcnRlZFxuICAgICAqICB0byB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWUuICBUaGUgZnJhbWVSYXRlIHByb3BlcnR5IGlzIHRoZSBjdXJyZW50IGZyYW1lIHJhdGUgaW4gZnJhbWVzIC8gc2Vjb25kLiBSZXR1cm4gZmFsc2UgZnJvbSBmdW5jdGlvbixcbiAgICAgKiAgaWYgeW91IGRvbid0IG5lZWQgdG8gcmVkcmF3IGxheWVyL2xheWVycyBvbiBzb21lIGZyYW1lcy5cbiAgICAgKiBAcGFyYW0ge0tvbnZhLkxheWVyfEFycmF5fSBbbGF5ZXJzXSBsYXllcihzKSB0byBiZSByZWRyYXduIG9uIGVhY2ggYW5pbWF0aW9uIGZyYW1lLiBDYW4gYmUgYSBsYXllciwgYW4gYXJyYXkgb2YgbGF5ZXJzLCBvciBudWxsLlxuICAgICAqICBOb3Qgc3BlY2lmeWluZyBhIG5vZGUgd2lsbCByZXN1bHQgaW4gbm8gcmVkcmF3LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbW92ZSBhIG5vZGUgdG8gdGhlIHJpZ2h0IGF0IDUwIHBpeGVscyAvIHNlY29uZFxuICAgICAqIHZhciB2ZWxvY2l0eSA9IDUwO1xuICAgICAqXG4gICAgICogdmFyIGFuaW0gPSBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICogICB2YXIgZGlzdCA9IHZlbG9jaXR5ICogKGZyYW1lLnRpbWVEaWZmIC8gMTAwMCk7XG4gICAgICogICBub2RlLm1vdmUoZGlzdCwgMCk7XG4gICAgICogfSwgbGF5ZXIpO1xuICAgICAqXG4gICAgICogYW5pbS5zdGFydCgpO1xuICAgICAqL1xuICAgIEtvbnZhLkFuaW1hdGlvbiA9IGZ1bmN0aW9uKGZ1bmMsIGxheWVycykge1xuICAgICAgICB2YXIgQW5pbSA9IEtvbnZhLkFuaW1hdGlvbjtcbiAgICAgICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICAgICAgdGhpcy5zZXRMYXllcnMobGF5ZXJzKTtcbiAgICAgICAgdGhpcy5pZCA9IEFuaW0uYW5pbUlkQ291bnRlcisrO1xuICAgICAgICB0aGlzLmZyYW1lID0ge1xuICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgIHRpbWVEaWZmOiAwLFxuICAgICAgICAgICAgbGFzdFRpbWU6IG5vdygpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKlxuICAgICAqIEFuaW1hdGlvbiBtZXRob2RzXG4gICAgICovXG4gICAgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBsYXllcnMgdG8gYmUgcmVkcmF3biBvbiBlYWNoIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuTGF5ZXJ8QXJyYXl9IFtsYXllcnNdIGxheWVyKHMpIHRvIGJlIHJlZHJhd24uJm5ic3A7IENhbiBiZSBhIGxheWVyLCBhbiBhcnJheSBvZiBsYXllcnMsIG9yIG51bGwuICBOb3Qgc3BlY2lmeWluZyBhIG5vZGUgd2lsbCByZXN1bHQgaW4gbm8gcmVkcmF3LlxuICAgICAgICAgKiBAcmV0dXJuIHtLb252YS5BbmltYXRpb259IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHNldExheWVyczogZnVuY3Rpb24obGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbGF5cyA9IFtdO1xuICAgICAgICAgICAgLy8gaWYgcGFzc2luZyBpbiBubyBsYXllcnNcbiAgICAgICAgICAgIGlmICghbGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGF5cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgcGFzc2luZyBpbiBhbiBhcnJheSBvZiBMYXllcnNcbiAgICAgICAgICAgIC8vIE5PVEU6IGxheWVycyBjb3VsZCBiZSBhbiBhcnJheSBvciBLb252YS5Db2xsZWN0aW9uLiAgZm9yIHNpbXBsaWNpdHksIEknbSBqdXN0IGluc3BlY3RpbmdcbiAgICAgICAgICAgIC8vIHRoZSBsZW5ndGggcHJvcGVydHkgdG8gY2hlY2sgZm9yIGJvdGggY2FzZXNcbiAgICAgICAgICAgIGVsc2UgaWYgKGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGF5cyA9IGxheWVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHBhc3NpbmcgaW4gYSBMYXllclxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGF5cyA9IFtsYXllcnNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxheWVycyA9IGxheXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBsYXllcnNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgS29udmEuTGF5ZXJcbiAgICAgICAgICovXG4gICAgICAgIGdldExheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXllcnM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhZGQgbGF5ZXIuICBSZXR1cm5zIHRydWUgaWYgdGhlIGxheWVyIHdhcyBhZGRlZCwgYW5kIGZhbHNlIGlmIGl0IHdhcyBub3RcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLkxheWVyfSBsYXllciB0byBhZGRcbiAgICAgICAgICogQHJldHVybiB7Qm9vbH0gdHJ1ZSBpZiBsYXllciBpcyBhZGRlZCB0byBhbmltYXRpb24sIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkTGF5ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnMsXG4gICAgICAgICAgICAgICAgbGVuID0gbGF5ZXJzLmxlbmd0aCwgbjtcblxuICAgICAgICAgICAgLy8gZG9uJ3QgYWRkIHRoZSBsYXllciBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyc1tuXS5faWQgPT09IGxheWVyLl9pZCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXRlcm1pbmUgaWYgYW5pbWF0aW9uIGlzIHJ1bm5pbmcgb3Igbm90LiAgcmV0dXJucyB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybiB7Qm9vbH0gaXMgYW5pbWF0aW9uIHJ1bm5pbmc/XG4gICAgICAgICAqL1xuICAgICAgICBpc1J1bm5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSBLb252YS5BbmltYXRpb24sXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucyA9IGEuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICBsZW4gPSBhbmltYXRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBuO1xuXG4gICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uc1tuXS5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdGFydCBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtLb252YS5BbmltYXRpb259IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBBbmltID0gS29udmEuQW5pbWF0aW9uO1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lLnRpbWVEaWZmID0gMDtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUubGFzdFRpbWUgPSBub3coKTtcbiAgICAgICAgICAgIEFuaW0uX2FkZEFuaW1hdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc3RvcCBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtLb252YS5BbmltYXRpb259IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgS29udmEuQW5pbWF0aW9uLl9yZW1vdmVBbmltYXRpb24odGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgX3VwZGF0ZUZyYW1lT2JqZWN0OiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmZyYW1lLnRpbWVEaWZmID0gdGltZSAtIHRoaXMuZnJhbWUubGFzdFRpbWU7XG4gICAgICAgICAgICB0aGlzLmZyYW1lLmxhc3RUaW1lID0gdGltZTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUudGltZSArPSB0aGlzLmZyYW1lLnRpbWVEaWZmO1xuICAgICAgICAgICAgdGhpcy5mcmFtZS5mcmFtZVJhdGUgPSAxMDAwIC8gdGhpcy5mcmFtZS50aW1lRGlmZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuQW5pbWF0aW9uLmFuaW1hdGlvbnMgPSBbXTtcbiAgICBLb252YS5BbmltYXRpb24uYW5pbUlkQ291bnRlciA9IDA7XG4gICAgS29udmEuQW5pbWF0aW9uLmFuaW1SdW5uaW5nID0gZmFsc2U7XG5cbiAgICBLb252YS5BbmltYXRpb24uX2FkZEFuaW1hdGlvbiA9IGZ1bmN0aW9uKGFuaW0pIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLnB1c2goYW5pbSk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUFuaW1hdGlvbigpO1xuICAgIH07XG4gICAgS29udmEuQW5pbWF0aW9uLl9yZW1vdmVBbmltYXRpb24gPSBmdW5jdGlvbihhbmltKSB7XG4gICAgICAgIHZhciBpZCA9IGFuaW0uaWQsXG4gICAgICAgICAgICBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zLFxuICAgICAgICAgICAgbGVuID0gYW5pbWF0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICBuO1xuXG4gICAgICAgIGZvcihuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgICBpZihhbmltYXRpb25zW25dLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UobiwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuQW5pbWF0aW9uLl9ydW5GcmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxheWVySGFzaCA9IHt9LFxuICAgICAgICAgICAgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgIGFuaW0sIGxheWVycywgZnVuYywgbiwgaSwgbGF5ZXJzTGVuLCBsYXllciwga2V5LCBuZWVkUmVkcmF3O1xuICAgICAgICAvKlxuICAgICAgICAgKiBsb29wIHRocm91Z2ggYWxsIGFuaW1hdGlvbnMgYW5kIGV4ZWN1dGUgYW5pbWF0aW9uXG4gICAgICAgICAqICBmdW5jdGlvbi4gIGlmIHRoZSBhbmltYXRpb24gb2JqZWN0IGhhcyBzcGVjaWZpZWQgbm9kZSxcbiAgICAgICAgICogIHdlIGNhbiBhZGQgdGhlIG5vZGUgdG8gdGhlIG5vZGVzIGhhc2ggdG8gZWxpbWluYXRlXG4gICAgICAgICAqICBkcmF3aW5nIHRoZSBzYW1lIG5vZGUgbXVsdGlwbGUgdGltZXMuICBUaGUgbm9kZSBwcm9wZXJ0eVxuICAgICAgICAgKiAgY2FuIGJlIHRoZSBzdGFnZSBpdHNlbGYgb3IgYSBsYXllclxuICAgICAgICAgKi9cbiAgICAgICAgLypcbiAgICAgICAgICogV0FSTklORzogZG9uJ3QgY2FjaGUgYW5pbWF0aW9ucy5sZW5ndGggYmVjYXVzZSBpdCBjb3VsZCBjaGFuZ2Ugd2hpbGVcbiAgICAgICAgICogdGhlIGZvciBsb29wIGlzIHJ1bm5pbmcsIGNhdXNpbmcgYSBKUyBlcnJvclxuICAgICAgICAgKi9cblxuICAgICAgICBmb3IobiA9IDA7IG4gPCBhbmltYXRpb25zLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBhbmltID0gYW5pbWF0aW9uc1tuXTtcbiAgICAgICAgICAgIGxheWVycyA9IGFuaW0ubGF5ZXJzO1xuICAgICAgICAgICAgZnVuYyA9IGFuaW0uZnVuYztcblxuXG4gICAgICAgICAgICBhbmltLl91cGRhdGVGcmFtZU9iamVjdChub3coKSk7XG4gICAgICAgICAgICBsYXllcnNMZW4gPSBsYXllcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBpZiBhbmltYXRpb24gb2JqZWN0IGhhcyBhIGZ1bmN0aW9uLCBleGVjdXRlIGl0XG4gICAgICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IGFuaW0gYnlwYXNzaW5nIGRyYXdpbmdcbiAgICAgICAgICAgICAgICBuZWVkUmVkcmF3ID0gKGZ1bmMuY2FsbChhbmltLCBhbmltLmZyYW1lKSAhPT0gZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWVkUmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmVlZFJlZHJhdykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxheWVyc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJIYXNoW2xheWVyLl9pZF0gPSBsYXllcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiBsYXllckhhc2gpIHtcbiAgICAgICAgICAgIGlmICghbGF5ZXJIYXNoLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVySGFzaFtrZXldLmRyYXcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuQW5pbWF0aW9uLl9hbmltYXRpb25Mb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBBbmltID0gS29udmEuQW5pbWF0aW9uO1xuICAgICAgICBpZihBbmltLmFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBBbmltLl9ydW5GcmFtZXMoKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltRnJhbWUoQW5pbS5fYW5pbWF0aW9uTG9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBBbmltLmFuaW1SdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLkFuaW1hdGlvbi5faGFuZGxlQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKCF0aGlzLmFuaW1SdW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1SdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltRnJhbWUodGhpcy5fYW5pbWF0aW9uTG9vcCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYmF0Y2ggZHJhdy4gdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCBkbyBpbW1lZGlhdGUgZHJhd1xuICAgICAqIGJ1dCBpdCB3aWxsIHNjaGVkdWxlIGRyYXdpbmcgdG8gbmV4dCB0aWNrIChyZXF1ZXN0QW5pbUZyYW1lKVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHtLb252YS5MYXllcn0gdGhpc1xuICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGUuYmF0Y2hEcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIEFuaW0gPSBLb252YS5BbmltYXRpb247XG5cbiAgICAgICAgaWYgKCF0aGlzLmJhdGNoQW5pbSkge1xuICAgICAgICAgICAgdGhpcy5iYXRjaEFuaW0gPSBuZXcgQW5pbShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBzdG9wIGFuaW1hdGlvbiBhZnRlciBmaXJzdCB0aWNrXG4gICAgICAgICAgICAgICAgdGhhdC5iYXRjaEFuaW0uc3RvcCgpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3RCYXRjaERyYXdUaW1lID0gbm93KCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmJhdGNoQW5pbS5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5iYXRjaEFuaW0uc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYmF0Y2ggZHJhd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHtLb252YS5TdGFnZX0gdGhpc1xuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBLb252YS5TdGFnZS5wcm90b3R5cGUuYmF0Y2hEcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgICBsYXllci5iYXRjaERyYXcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGJsYWNrbGlzdCA9IHtcbiAgICAgICAgbm9kZTogMSxcbiAgICAgICAgZHVyYXRpb246IDEsXG4gICAgICAgIGVhc2luZzogMSxcbiAgICAgICAgb25GaW5pc2g6IDEsXG4gICAgICAgIHlveW86IDFcbiAgICB9LFxuXG4gICAgUEFVU0VEID0gMSxcbiAgICBQTEFZSU5HID0gMixcbiAgICBSRVZFUlNJTkcgPSAzLFxuXG4gICAgaWRDb3VudGVyID0gMCxcbiAgICBjb2xvckF0dHJzID0gWydmaWxsJywgJ3N0cm9rZScsICdzaGFkb3dDb2xvciddO1xuXG4gICAgdmFyIFR3ZWVuID0gZnVuY3Rpb24ocHJvcCwgcHJvcEZ1bmMsIGZ1bmMsIGJlZ2luLCBmaW5pc2gsIGR1cmF0aW9uLCB5b3lvKSB7XG4gICAgICAgIHRoaXMucHJvcCA9IHByb3A7XG4gICAgICAgIHRoaXMucHJvcEZ1bmMgPSBwcm9wRnVuYztcbiAgICAgICAgdGhpcy5iZWdpbiA9IGJlZ2luO1xuICAgICAgICB0aGlzLl9wb3MgPSBiZWdpbjtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSAwO1xuICAgICAgICB0aGlzLnByZXZQb3MgPSAwO1xuICAgICAgICB0aGlzLnlveW8gPSB5b3lvO1xuICAgICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLl9maW5pc2ggPSAwO1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICB0aGlzLl9jaGFuZ2UgPSBmaW5pc2ggLSB0aGlzLmJlZ2luO1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIFR3ZWVuIG1ldGhvZHNcbiAgICAgKi9cbiAgICBUd2Vlbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzW3N0cl07XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0VGltZTogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgaWYodCA+IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnlveW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy55b3lvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lID0gdDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2UG9zID0gdGhpcy5fcG9zO1xuICAgICAgICAgICAgdGhpcy5wcm9wRnVuYyhwKTtcbiAgICAgICAgICAgIHRoaXMuX3BvcyA9IHA7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZih0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0ID0gdGhpcy5fdGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmModCwgdGhpcy5iZWdpbiwgdGhpcy5fY2hhbmdlLCB0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gUExBWUlORztcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuZ2V0VGltZXIoKSAtIHRoaXMuX3RpbWU7XG4gICAgICAgICAgICB0aGlzLm9uRW50ZXJGcmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdvblBsYXknKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmV2ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gUkVWRVJTSU5HO1xuICAgICAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb24gLSB0aGlzLl90aW1lO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGhpcy5nZXRUaW1lcigpIC0gdGhpcy5fdGltZTtcbiAgICAgICAgICAgIHRoaXMub25FbnRlckZyYW1lKCk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uUmV2ZXJzZScpO1xuICAgICAgICB9LFxuICAgICAgICBzZWVrOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uU2VlaycpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ29uUmVzZXQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluaXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnb25GaW5pc2gnKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24odGhpcy5nZXRQb3NpdGlvbih0aGlzLl90aW1lKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRW50ZXJGcmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0VGltZXIoKSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhdGUgPT09IFBMQVlJTkcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWUodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBSRVZFUlNJTkcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWUodGhpcy5kdXJhdGlvbiAtIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gUEFVU0VEO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdvblBhdXNlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRpbWVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUd2VlbiBjb25zdHJ1Y3Rvci4gIFR3ZWVucyBlbmFibGUgeW91IHRvIGFuaW1hdGUgYSBub2RlIGJldHdlZW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGEgbmV3IHN0YXRlLlxuICAgICAqICBZb3UgY2FuIHBsYXksIHBhdXNlLCByZXZlcnNlLCBzZWVrLCByZXNldCwgYW5kIGZpbmlzaCB0d2VlbnMuICBCeSBkZWZhdWx0LCB0d2VlbnMgYXJlIGFuaW1hdGVkIHVzaW5nXG4gICAgICogIGEgbGluZWFyIGVhc2luZy4gIEZvciBtb3JlIHR3ZWVuaW5nIG9wdGlvbnMsIGNoZWNrIG91dCB7QGxpbmsgS29udmEuRWFzaW5nc31cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGluc3RhbnRpYXRlIG5ldyB0d2VlbiB3aGljaCBmdWxseSByb3RhdGVzIGEgbm9kZSBpbiAxIHNlY29uZFxuICAgICAqIHZhciB0d2VlbiA9IG5ldyBLb252YS5Ud2Vlbih7XG4gICAgICogICBub2RlOiBub2RlLFxuICAgICAqICAgcm90YXRpb25EZWc6IDM2MCxcbiAgICAgKiAgIGR1cmF0aW9uOiAxLFxuICAgICAqICAgZWFzaW5nOiBLb252YS5FYXNpbmdzLkVhc2VJbk91dFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gcGxheSB0d2VlblxuICAgICAqIHR3ZWVuLnBsYXkoKTtcbiAgICAgKlxuICAgICAqIC8vIHBhdXNlIHR3ZWVuXG4gICAgICogdHdlZW4ucGF1c2UoKTtcbiAgICAgKi9cbiAgICBLb252YS5Ud2VlbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBub2RlID0gY29uZmlnLm5vZGUsXG4gICAgICAgICAgICBub2RlSWQgPSBub2RlLl9pZCxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgZWFzaW5nID0gY29uZmlnLmVhc2luZyB8fCBLb252YS5FYXNpbmdzLkxpbmVhcixcbiAgICAgICAgICAgIHlveW8gPSAhIWNvbmZpZy55b3lvLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnLmR1cmF0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5kdXJhdGlvbiA9PT0gMCkgeyAgLy8gemVybyBpcyBiYWQgdmFsdWUgZm9yIGR1cmF0aW9uXG4gICAgICAgICAgICBkdXJhdGlvbiA9IDAuMDAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBjb25maWcuZHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5faWQgPSBpZENvdW50ZXIrKztcblxuICAgICAgICB2YXIgbGF5ZXJzID0gbm9kZS5nZXRMYXllcigpIHx8ICgobm9kZSBpbnN0YW5jZW9mIEtvbnZhLlN0YWdlKSA/IG5vZGUuZ2V0TGF5ZXJzKCkgOiBudWxsKTtcbiAgICAgICAgaWYgKCFsYXllcnMpIHtcbiAgICAgICAgICAgIEtvbnZhLlV0aWwuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1R3ZWVuIGNvbnN0cnVjdG9yIGhhdmUgYG5vZGVgIHRoYXQgaXMgbm90IGluIGEgbGF5ZXIuIFBsZWFzZSBhZGQgbm9kZSBpbnRvIGxheWVyIGZpcnN0LidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltID0gbmV3IEtvbnZhLkFuaW1hdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoYXQudHdlZW4ub25FbnRlckZyYW1lKCk7XG4gICAgICAgIH0sIGxheWVycyk7XG5cbiAgICAgICAgdGhpcy50d2VlbiA9IG5ldyBUd2VlbihrZXksIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHRoYXQuX3R3ZWVuRnVuYyhpKTtcbiAgICAgICAgfSwgZWFzaW5nLCAwLCAxLCBkdXJhdGlvbiAqIDEwMDAsIHlveW8pO1xuXG4gICAgICAgIHRoaXMuX2FkZExpc3RlbmVycygpO1xuXG4gICAgICAgIC8vIGluaXQgYXR0cnMgbWFwXG4gICAgICAgIGlmICghS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXSkge1xuICAgICAgICAgICAgS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXVt0aGlzLl9pZF0pIHtcbiAgICAgICAgICAgIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdGhpcy5faWRdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5pdCB0d2VlbnMgbWFwXG4gICAgICAgIGlmICghS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF0pIHtcbiAgICAgICAgICAgIEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChibGFja2xpc3Rba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQXR0cihrZXksIGNvbmZpZ1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICAvLyBjYWxsYmFja3NcbiAgICAgICAgdGhpcy5vbkZpbmlzaCA9IGNvbmZpZy5vbkZpbmlzaDtcbiAgICAgICAgdGhpcy5vblJlc2V0ID0gY29uZmlnLm9uUmVzZXQ7XG4gICAgfTtcblxuICAgIC8vIHN0YXJ0L2RpZmYgb2JqZWN0ID0gYXR0cnMubm9kZUlkLnR3ZWVuSWQuYXR0clxuICAgIEtvbnZhLlR3ZWVuLmF0dHJzID0ge307XG4gICAgLy8gdHdlZW5JZCA9IHR3ZWVucy5ub2RlSWQuYXR0clxuICAgIEtvbnZhLlR3ZWVuLnR3ZWVucyA9IHt9O1xuXG4gICAgS29udmEuVHdlZW4ucHJvdG90eXBlID0ge1xuICAgICAgICBfYWRkQXR0cjogZnVuY3Rpb24oa2V5LCBlbmQpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgICAgIG5vZGVJZCA9IG5vZGUuX2lkLFxuICAgICAgICAgICAgICAgIHN0YXJ0LCBkaWZmLCB0d2VlbklkLCBuLCBsZW4sIHRydWVFbmQsIHRydWVTdGFydDtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGNvbmZsaWN0IGZyb20gdHdlZW4gbWFwIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgdHdlZW5JZCA9IEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdW2tleV07XG5cbiAgICAgICAgICAgIGlmICh0d2VlbklkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdHdlZW5JZF1ba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHRvIHR3ZWVuIG1hcFxuICAgICAgICAgICAgc3RhcnQgPSBub2RlLmdldEF0dHIoa2V5KTtcblxuICAgICAgICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzQXJyYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgIGRpZmYgPSBbXTtcbiAgICAgICAgICAgICAgICBsZW4gPSBNYXRoLm1heChlbmQubGVuZ3RoLCBzdGFydC5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3BvaW50cycgJiYgZW5kLmxlbmd0aCAhPT0gc3RhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSB0d2VlbmluZyBwb2ludHMgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBzdGFydC5sZW5ndGggPT09IGVuZC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgLy8gS29udmEuVXRpbC5fcHJlcGFyZUFycmF5Rm9yVHdlZW4gdGhpbmtpbmcgdGhhdCBlbmQubGVuZ3RoID4gc3RhcnQubGVuZ3RoXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZC5sZW5ndGggPiBzdGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGluIHRoaXMgY2FzZSB3ZSB3aWxsIGluY3JlYXNlIG51bWJlciBvZiBzdGFydGluZyBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBLb252YS5VdGlsLl9wcmVwYXJlQXJyYXlGb3JUd2VlbihzdGFydCwgZW5kLCBub2RlLmNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3aWxsIGluY3JlYXNlIG51bWJlciBvZiBlZGluZyBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWVFbmQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBLb252YS5VdGlsLl9wcmVwYXJlQXJyYXlGb3JUd2VlbihlbmQsIHN0YXJ0LCBub2RlLmNsb3NlZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICAgICAgICBkaWZmLnB1c2goKGVuZFtuXSkgLSAoc3RhcnRbbl0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sb3JBdHRycy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBLb252YS5VdGlsLmNvbG9yVG9SR0JBKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kUkdCQSA9IEtvbnZhLlV0aWwuY29sb3JUb1JHQkEoZW5kKTtcbiAgICAgICAgICAgICAgICBkaWZmID0ge1xuICAgICAgICAgICAgICAgICAgICByOiBlbmRSR0JBLnIgLSBzdGFydC5yLFxuICAgICAgICAgICAgICAgICAgICBnOiBlbmRSR0JBLmcgLSBzdGFydC5nLFxuICAgICAgICAgICAgICAgICAgICBiOiBlbmRSR0JBLmIgLSBzdGFydC5iLFxuICAgICAgICAgICAgICAgICAgICBhOiBlbmRSR0JBLmEgLSBzdGFydC5hXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3RoaXMuX2lkXVtrZXldID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBkaWZmOiBkaWZmLFxuICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgIHRydWVFbmQ6IHRydWVFbmQsXG4gICAgICAgICAgICAgICAgdHJ1ZVN0YXJ0OiB0cnVlU3RhcnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXVtrZXldID0gdGhpcy5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIF90d2VlbkZ1bmM6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLFxuICAgICAgICAgICAgICAgIGF0dHJzID0gS29udmEuVHdlZW4uYXR0cnNbbm9kZS5faWRdW3RoaXMuX2lkXSxcbiAgICAgICAgICAgICAgICBrZXksIGF0dHIsIHN0YXJ0LCBkaWZmLCBuZXdWYWwsIG4sIGxlbiwgZW5kO1xuXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyc1trZXldO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gYXR0ci5zdGFydDtcbiAgICAgICAgICAgICAgICBkaWZmID0gYXR0ci5kaWZmO1xuICAgICAgICAgICAgICAgIGVuZCA9IGF0dHIuZW5kO1xuXG4gICAgICAgICAgICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzQXJyYXkoc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZW4gPSBNYXRoLm1heChzdGFydC5sZW5ndGgsIGVuZC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbC5wdXNoKChzdGFydFtuXSB8fCAwKSArIChkaWZmW25dICogaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xvckF0dHJzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gJ3JnYmEoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydC5yICsgZGlmZi5yICogaSkgKyAnLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQoc3RhcnQuZyArIGRpZmYuZyAqIGkpICsgJywnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHN0YXJ0LmIgKyBkaWZmLmIgKiBpKSArICcsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXJ0LmEgKyBkaWZmLmEgKiBpKSArICcpJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWwgPSBzdGFydCArIChkaWZmICogaSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyKGtleSwgbmV3VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2FkZExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy50d2Vlbi5vblBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmFuaW0uc3RhcnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnR3ZWVuLm9uUmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuYW5pbS5zdGFydCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gc3RvcCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMudHdlZW4ub25QYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuYW5pbS5zdG9wKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy50d2Vlbi5vbkZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhhdC5ub2RlO1xuXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdHdlZW5pbmcgIHBvaW50cyBvZiBsaW5lIHdlIG5lZWQgdG8gc2V0IG9yaWdpbmFsIGVuZFxuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IEtvbnZhLlR3ZWVuLmF0dHJzW25vZGUuX2lkXVt0aGF0Ll9pZF07XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLnBvaW50cyAmJiBhdHRycy5wb2ludHMudHJ1ZUVuZCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBvaW50cyhhdHRycy5wb2ludHMudHJ1ZUVuZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQub25GaW5pc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vbkZpbmlzaC5jYWxsKHRoYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnR3ZWVuLm9uUmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoYXQubm9kZTtcbiAgICAgICAgICAgICAgICAvLyBhZnRlciB0d2VlbmluZyAgcG9pbnRzIG9mIGxpbmUgd2UgbmVlZCB0byBzZXQgb3JpZ2luYWwgc3RhcnRcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlLl9pZF1bdGhhdC5faWRdO1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5wb2ludHMgJiYgYXR0cnMucG9pbnRzLnRydWVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBvaW50cyhhdHRycy5wb2ludHMudHJ1ZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhhdC5vblJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQub25SZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwbGF5XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgICAgICBwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudHdlZW4ucGxheSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXZlcnNlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgICAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudHdlZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXNldFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ud2Vlbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy50d2Vlbi5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZWVrXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHQgdGltZSBpbiBzZWNvbmRzIGJldHdlZW4gMCBhbmQgdGhlIGR1cmF0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgICAgICovXG4gICAgICAgIHNlZWs6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHRoaXMudHdlZW4uc2Vlayh0ICogMTAwMCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHBhdXNlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgICAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnR3ZWVuLnBhdXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpbmlzaFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ud2Vlbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAgICAgKi9cbiAgICAgICAgZmluaXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudHdlZW4uZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlc3Ryb3lcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSB0aGlzLm5vZGUuX2lkLFxuICAgICAgICAgICAgICAgIHRoaXNJZCA9IHRoaXMuX2lkLFxuICAgICAgICAgICAgICAgIGF0dHJzID0gS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF0sXG4gICAgICAgICAgICAgICAga2V5O1xuXG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG5cbiAgICAgICAgICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdW2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3RoaXNJZF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHdlZW4gbm9kZSBwcm9wZXJ0aWVzLiBTaG9ydGVyIHVzYWdlIG9mIHtAbGluayBLb252YS5Ud2Vlbn0gb2JqZWN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBLb252YS5Ob2RlI3RvXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gdHdlZW4gcGFyYW1zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGNpcmNsZS50byh7XG4gICAgICogIHggOiA1MCxcbiAgICAgKiAgZHVyYXRpb24gOiAwLjVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgb25GaW5pc2ggPSBwYXJhbXMub25GaW5pc2g7XG4gICAgICAgIHBhcmFtcy5ub2RlID0gdGhpcztcbiAgICAgICAgcGFyYW1zLm9uRmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgICAgICAgICAgIG9uRmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0d2VlbiA9IG5ldyBLb252YS5Ud2VlbihwYXJhbXMpO1xuICAgICAgICB0d2Vlbi5wbGF5KCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgKiBUaGVzZSBlYXNlcyB3ZXJlIHBvcnRlZCBmcm9tIGFuIEFkb2JlIEZsYXNoIHR3ZWVuaW5nIGxpYnJhcnkgdG8gSmF2YVNjcmlwdFxuICAgICogYnkgWGFyaWNcbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZSBFYXNpbmdzXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICovXG4gICAgS29udmEuRWFzaW5ncyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICogYmFjayBlYXNlIGluXG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0JhY2tFYXNlSW4nOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqICgocyArIDEpICogdCAtIHMpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogYmFjayBlYXNlIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdCYWNrRWFzZU91dCc6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBjICogKCggdCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGJhY2sgZWFzZSBpbiBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnQmFja0Vhc2VJbk91dCc6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIGlmKCh0IC89IGQgLyAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGVsYXN0aWMgZWFzZSBpblxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdFbGFzdGljRWFzZUluJzogZnVuY3Rpb24odCwgYiwgYywgZCwgYSwgcCkge1xuICAgICAgICAgICAgLy8gYWRkZWQgcyA9IDBcbiAgICAgICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgICAgIGlmKHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCh0IC89IGQpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIXApIHtcbiAgICAgICAgICAgICAgICBwID0gZCAqIDAuMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgICAgICAgICAgIGEgPSBjO1xuICAgICAgICAgICAgICAgIHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSkgKyBiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBlbGFzdGljIGVhc2Ugb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0VsYXN0aWNFYXNlT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCwgYSwgcCkge1xuICAgICAgICAgICAgLy8gYWRkZWQgcyA9IDBcbiAgICAgICAgICAgIHZhciBzID0gMDtcbiAgICAgICAgICAgIGlmKHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCh0IC89IGQpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIXApIHtcbiAgICAgICAgICAgICAgICBwID0gZCAqIDAuMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCFhIHx8IGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgICAgICAgICAgIGEgPSBjO1xuICAgICAgICAgICAgICAgIHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgYyArIGIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBlbGFzdGljIGVhc2UgaW4gb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0VsYXN0aWNFYXNlSW5PdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkLCBhLCBwKSB7XG4gICAgICAgICAgICAvLyBhZGRlZCBzID0gMFxuICAgICAgICAgICAgdmFyIHMgPSAwO1xuICAgICAgICAgICAgaWYodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoKHQgLz0gZCAvIDIpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIXApIHtcbiAgICAgICAgICAgICAgICBwID0gZCAqICgwLjMgKiAxLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWEgfHwgYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICAgICAgICAgICAgYSA9IGM7XG4gICAgICAgICAgICAgICAgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyBjICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogYm91bmNlIGVhc2Ugb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0JvdW5jZUVhc2VPdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZigodCAvPSBkKSA8ICgxIC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiB0ICogdCkgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih0IDwgKDIgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NSkgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih0IDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1KSArIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzUpICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogYm91bmNlIGVhc2UgaW5cbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnQm91bmNlRWFzZUluJzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIGMgLSBLb252YS5FYXNpbmdzLkJvdW5jZUVhc2VPdXQoZCAtIHQsIDAsIGMsIGQpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogYm91bmNlIGVhc2UgaW4gb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0JvdW5jZUVhc2VJbk91dCc6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIGlmKHQgPCBkIC8gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBLb252YS5FYXNpbmdzLkJvdW5jZUVhc2VJbih0ICogMiwgMCwgYywgZCkgKiAwLjUgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEtvbnZhLkVhc2luZ3MuQm91bmNlRWFzZU91dCh0ICogMiAtIGQsIDAsIGMsIGQpICogMC41ICsgYyAqIDAuNSArIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIGVhc2UgaW5cbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnRWFzZUluJzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKyBiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBlYXNlIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdFYXNlT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogZWFzZSBpbiBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgICAgICAnRWFzZUluT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgaWYoKHQgLz0gZCAvIDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtYyAvIDIgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSkgKyBiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBzdHJvbmcgZWFzZSBpblxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdTdHJvbmdFYXNlSW4nOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIHN0cm9uZyBlYXNlIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdTdHJvbmdFYXNlT3V0JzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgICAgICAgcmV0dXJuIGMgKiAoKCB0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxKSArIGI7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIHN0cm9uZyBlYXNlIGluIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgICAgICdTdHJvbmdFYXNlSW5PdXQnOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICAgICAgICBpZigodCAvPSBkIC8gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpICsgYjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogbGluZWFyXG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICAgICAgJ0xpbmVhcic6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgICAgICAgIHJldHVybiBjICogdCAvIGQgKyBiO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgS29udmEuREQgPSB7XG4gICAgICAgIC8vIHByb3BlcnRpZXNcbiAgICAgICAgYW5pbTogbmV3IEtvbnZhLkFuaW1hdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5kaXJ0eTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9KSxcbiAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIGp1c3REcmFnZ2VkOiBmYWxzZSxcbiAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9LFxuICAgICAgICBub2RlOiBudWxsLFxuXG4gICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgX2RyYWc6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgICAgICAgICAgbm9kZSA9IGRkLm5vZGU7XG5cbiAgICAgICAgICAgIGlmKG5vZGUpIHtcbiAgICAgICAgICAgICAgIGlmKCFkZC5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBub2RlLmdldFN0YWdlKCkuZ2V0UG9pbnRlclBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcmFnRGlzdGFuY2UgPSBub2RlLmRyYWdEaXN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHBvcy54IC0gZGQuc3RhcnRQb2ludGVyUG9zLngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMocG9zLnkgLSBkZC5zdGFydFBvaW50ZXJQb3MueSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgZHJhZ0Rpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0U3RhZ2UoKS5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICAgICAgbm9kZS5fc2V0RHJhZ1Bvc2l0aW9uKGV2dCk7XG4gICAgICAgICAgICAgICAgaWYoIWRkLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGQuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZmlyZSgnZHJhZ3N0YXJ0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RyYWdzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBleGVjdXRlIG9uZHJhZ21vdmUgaWYgZGVmaW5lZFxuICAgICAgICAgICAgICAgIG5vZGUuZmlyZSgnZHJhZ21vdmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkcmFnbW92ZScsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2VuZERyYWdCZWZvcmU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgICAgICAgICAgbm9kZSA9IGRkLm5vZGUsXG4gICAgICAgICAgICAgICAgbGF5ZXI7XG5cbiAgICAgICAgICAgIGlmKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBsYXllciA9IG5vZGUuZ2V0TGF5ZXIoKTtcbiAgICAgICAgICAgICAgICBkZC5hbmltLnN0b3AoKTtcblxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZmlyZSBkcmFnZW5kIGV2ZW50IGlmIHRoZSBkcmFnIGFuZCBkcm9wXG4gICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9uIGFjdHVhbGx5IHN0YXJ0ZWQuXG4gICAgICAgICAgICAgICAgaWYoZGQuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICBkZC5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRkLmp1c3REcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldnQuZHJhZ0VuZE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRkLm5vZGU7XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRMYXllcigpIHx8IGxheWVyIHx8IChub2RlIGluc3RhbmNlb2YgS29udmEuU3RhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAobGF5ZXIgfHwgbm9kZSkuZHJhdygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfZW5kRHJhZ0FmdGVyOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIGV2dCA9IGV2dCB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkcmFnRW5kTm9kZSA9IGV2dC5kcmFnRW5kTm9kZTtcblxuICAgICAgICAgICAgaWYgKGV2dCAmJiBkcmFnRW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIGRyYWdFbmROb2RlLmZpcmUoJ2RyYWdlbmQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkcmFnZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBkcmFnRW5kTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBOb2RlIGV4dGVuZGVyc1xuXG4gICAgLyoqXG4gICAgICogaW5pdGlhdGUgZHJhZyBhbmQgZHJvcFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zdGFydERyYWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgICAgICBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKSxcbiAgICAgICAgICAgIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgICAgICAgcG9zID0gc3RhZ2UuZ2V0UG9pbnRlclBvc2l0aW9uKCksXG4gICAgICAgICAgICBhcCA9IHRoaXMuZ2V0QWJzb2x1dGVQb3NpdGlvbigpO1xuXG4gICAgICAgIGlmKHBvcykge1xuICAgICAgICAgICAgaWYgKGRkLm5vZGUpIHtcbiAgICAgICAgICAgICAgICBkZC5ub2RlLnN0b3BEcmFnKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRkLm5vZGUgPSB0aGlzO1xuICAgICAgICAgICAgZGQuc3RhcnRQb2ludGVyUG9zID0gcG9zO1xuICAgICAgICAgICAgZGQub2Zmc2V0LnggPSBwb3MueCAtIGFwLng7XG4gICAgICAgICAgICBkZC5vZmZzZXQueSA9IHBvcy55IC0gYXAueTtcbiAgICAgICAgICAgIGRkLmFuaW0uc2V0TGF5ZXJzKGxheWVyIHx8IHRoaXMuZ2V0TGF5ZXJzKCkpO1xuICAgICAgICAgICAgZGQuYW5pbS5zdGFydCgpO1xuXG4gICAgICAgICAgICB0aGlzLl9zZXREcmFnUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5fc2V0RHJhZ1Bvc2l0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBkZCA9IEtvbnZhLkRELFxuICAgICAgICAgICAgcG9zID0gdGhpcy5nZXRTdGFnZSgpLmdldFBvaW50ZXJQb3NpdGlvbigpLFxuICAgICAgICAgICAgZGJmID0gdGhpcy5nZXREcmFnQm91bmRGdW5jKCk7XG4gICAgICAgIGlmICghcG9zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld05vZGVQb3MgPSB7XG4gICAgICAgICAgICB4OiBwb3MueCAtIGRkLm9mZnNldC54LFxuICAgICAgICAgICAgeTogcG9zLnkgLSBkZC5vZmZzZXQueVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKGRiZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdOb2RlUG9zID0gZGJmLmNhbGwodGhpcywgbmV3Tm9kZVBvcywgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEFic29sdXRlUG9zaXRpb24obmV3Tm9kZVBvcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9sYXN0UG9zIHx8IHRoaXMuX2xhc3RQb3MueCAhPT0gbmV3Tm9kZVBvcy54IHx8XG4gICAgICAgICAgICB0aGlzLl9sYXN0UG9zLnkgIT09IG5ld05vZGVQb3MueSkge1xuICAgICAgICAgICAgZGQuYW5pbS5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXN0UG9zID0gbmV3Tm9kZVBvcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc3RvcCBkcmFnIGFuZCBkcm9wXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnN0b3BEcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZCA9IEtvbnZhLkRELFxuICAgICAgICAgICAgZXZ0ID0ge307XG4gICAgICAgIGRkLl9lbmREcmFnQmVmb3JlKGV2dCk7XG4gICAgICAgIGRkLl9lbmREcmFnQWZ0ZXIoZXZ0KTtcbiAgICB9O1xuXG4gICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0RHJhZ2dhYmxlID0gZnVuY3Rpb24oZHJhZ2dhYmxlKSB7XG4gICAgICAgIHRoaXMuX3NldEF0dHIoJ2RyYWdnYWJsZScsIGRyYWdnYWJsZSk7XG4gICAgICAgIHRoaXMuX2RyYWdDaGFuZ2UoKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yaWdEZXN0cm95ID0gS29udmEuTm9kZS5wcm90b3R5cGUuZGVzdHJveTtcblxuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XG5cbiAgICAgICAgLy8gc3RvcCBERFxuICAgICAgICBpZihkZC5ub2RlICYmIGRkLm5vZGUuX2lkID09PSB0aGlzLl9pZCkge1xuXG4gICAgICAgICAgICB0aGlzLnN0b3BEcmFnKCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnRGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBpcyBjdXJyZW50bHkgaW4gZHJhZyBhbmQgZHJvcCBtb2RlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XG4gICAgICAgIHJldHVybiAhIShkZC5ub2RlICYmIGRkLm5vZGUuX2lkID09PSB0aGlzLl9pZCAmJiBkZC5pc0RyYWdnaW5nKTtcbiAgICB9O1xuXG4gICAgS29udmEuTm9kZS5wcm90b3R5cGUuX2xpc3RlbkRyYWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX2RyYWdDbGVhbnVwKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0Q2xhc3NOYW1lKCkgPT09ICdTdGFnZScpIHtcbiAgICAgICAgICAgIHRoaXMub24oJ2NvbnRlbnRNb3VzZWRvd24ua29udmEgY29udGVudFRvdWNoc3RhcnQua29udmEnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICBpZighS29udmEuREQubm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnN0YXJ0RHJhZyhldnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbignbW91c2Vkb3duLmtvbnZhIHRvdWNoc3RhcnQua29udmEnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgcmlnaHQgYW5kIG1pZGRsZSBidXR0b25zXG4gICAgICAgICAgICAgICAgaWYgKGV2dC5ldnQuYnV0dG9uID09PSAxIHx8IGV2dC5ldnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoIUtvbnZhLkRELm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zdGFydERyYWcoZXZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpc3RlbmluZyBpcyByZXF1aXJlZCBmb3IgZHJhZyBhbmQgZHJvcFxuICAgICAgICAvKlxuICAgICAgICB0aGlzLl9saXN0ZW5pbmdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kQW5jZXN0b3JDYWNoZSgnbGlzdGVuaW5nRW5hYmxlZCcpO1xuICAgICAgICAqL1xuICAgIH07XG5cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5fZHJhZ0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLmF0dHJzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuRHJhZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0NsZWFudXAoKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGZvcmNlIGRyYWcgYW5kIGRyb3AgdG8gZW5kXG4gICAgICAgICAgICAgKiBpZiB0aGlzIG5vZGUgaXMgY3VycmVudGx5IGluXG4gICAgICAgICAgICAgKiBkcmFnIGFuZCBkcm9wIG1vZGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICAgICAgdmFyIGRkID0gS29udmEuREQ7XG4gICAgICAgICAgICBpZihzdGFnZSAmJiBkZC5ub2RlICYmIGRkLm5vZGUuX2lkID09PSB0aGlzLl9pZCkge1xuICAgICAgICAgICAgICAgIGRkLm5vZGUuc3RvcERyYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5fZHJhZ0NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0Q2xhc3NOYW1lKCkgPT09ICdTdGFnZScpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjb250ZW50TW91c2Vkb3duLmtvbnZhJyk7XG4gICAgICAgICAgICB0aGlzLm9mZignY29udGVudFRvdWNoc3RhcnQua29udmEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdtb3VzZWRvd24ua29udmEnKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCd0b3VjaHN0YXJ0LmtvbnZhJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdCb3VuZEZ1bmMnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZHJhZyBib3VuZCBmdW5jdGlvbi4gIFRoaXMgaXMgdXNlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdFxuICAgICAqICBkcmFnIGFuZCBkcm9wIHBvc2l0aW9uXG4gICAgICogQG5hbWUgZHJhZ0JvdW5kRnVuY1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFnQm91bmRGdW5jXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGRyYWcgYm91bmQgZnVuY3Rpb25cbiAgICAgKiB2YXIgZHJhZ0JvdW5kRnVuYyA9IG5vZGUuZHJhZ0JvdW5kRnVuYygpO1xuICAgICAqXG4gICAgICogLy8gY3JlYXRlIHZlcnRpY2FsIGRyYWcgYW5kIGRyb3BcbiAgICAgKiBub2RlLmRyYWdCb3VuZEZ1bmMoZnVuY3Rpb24ocG9zKXtcbiAgICAgKiAgIHJldHVybiB7XG4gICAgICogICAgIHg6IHRoaXMuZ2V0QWJzb2x1dGVQb3NpdGlvbigpLngsXG4gICAgICogICAgIHk6IHBvcy55XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdnYWJsZScsIGZhbHNlKTtcbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdnYWJsZScpO1xuXG4gICAgIC8qKlxuICAgICAqIGdldC9zZXQgZHJhZ2dhYmxlIGZsYWdcbiAgICAgKiBAbmFtZSBkcmFnZ2FibGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkcmFnZ2FibGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBkcmFnZ2FibGUgZmxhZ1xuICAgICAqIHZhciBkcmFnZ2FibGUgPSBub2RlLmRyYWdnYWJsZSgpO1xuICAgICAqXG4gICAgICogLy8gZW5hYmxlIGRyYWcgYW5kIGRyb3BcbiAgICAgKiBub2RlLmRyYWdnYWJsZSh0cnVlKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2FibGUgZHJhZyBhbmQgZHJvcFxuICAgICAqIG5vZGUuZHJhZ2dhYmxlKGZhbHNlKTtcbiAgICAgKi9cblxuICAgIHZhciBodG1sID0gS29udmEuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIEtvbnZhLkRELl9lbmREcmFnQmVmb3JlLCB0cnVlKTtcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgS29udmEuREQuX2VuZERyYWdCZWZvcmUsIHRydWUpO1xuXG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBLb252YS5ERC5fZHJhZyk7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBLb252YS5ERC5fZHJhZyk7XG5cbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBLb252YS5ERC5fZW5kRHJhZ0FmdGVyLCBmYWxzZSk7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIEtvbnZhLkRELl9lbmREcmFnQWZ0ZXIsIGZhbHNlKTtcblxufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBSZWN0IGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNvcm5lclJhZGl1c11cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHJlY3QgPSBuZXcgS29udmEuUmVjdCh7XG4gICAgICogICB3aWR0aDogMTAwLFxuICAgICAqICAgaGVpZ2h0OiA1MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAqICAgc3Ryb2tlV2lkdGg6IDVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5SZWN0ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5SZWN0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZWN0JztcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSB0aGlzLmdldENvcm5lclJhZGl1cygpLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIGlmKCFjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAvLyBzaW1wbGUgcmVjdCAtIGRvbid0IGJvdGhlciBkb2luZyBhbGwgdGhhdCBjb21wbGljYXRlZCBtYXRocyBzdHVmZi5cbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGFyY1RvIHdvdWxkIGJlIG5pY2VyLCBidXQgYnJvd3NlciBzdXBwb3J0IGlzIHBhdGNoeSAoT3BlcmEpXG4gICAgICAgICAgICAgICAgY29ybmVyUmFkaXVzID0gTWF0aC5taW4oY29ybmVyUmFkaXVzLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGNvcm5lclJhZGl1cywgMCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggLSBjb3JuZXJSYWRpdXMsIDApO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHdpZHRoIC0gY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSAqIDMgLyAyLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIGhlaWdodCAtIGNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMod2lkdGggLSBjb3JuZXJSYWRpdXMsIGhlaWdodCAtIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCAwLCBNYXRoLlBJIC8gMiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNvcm5lclJhZGl1cywgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyhjb3JuZXJSYWRpdXMsIGhlaWdodCAtIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCBNYXRoLlBJIC8gMiwgTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIGNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMoY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgTWF0aC5QSSwgTWF0aC5QSSAqIDMgLyAyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuUmVjdCwgS29udmEuU2hhcGUpO1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuUmVjdCwgJ2Nvcm5lclJhZGl1cycsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY29ybmVyIHJhZGl1c1xuICAgICAqIEBuYW1lIGNvcm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVjdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29ybmVyUmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjb3JuZXIgcmFkaXVzXG4gICAgICogdmFyIGNvcm5lclJhZGl1cyA9IHJlY3QuY29ybmVyUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY29ybmVyIHJhZGl1c1xuICAgICAqIHJlY3QuY29ybmVyUmFkaXVzKDEwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5SZWN0KTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gdGhlIDAuMDAwMSBvZmZzZXQgZml4ZXMgYSBidWcgaW4gQ2hyb21lIDI3XG4gICAgdmFyIFBJeDIgPSAoTWF0aC5QSSAqIDIpIC0gMC4wMDAxLFxuICAgICAgICBDSVJDTEUgPSAnQ2lyY2xlJztcblxuICAgIC8qKlxuICAgICAqIENpcmNsZSBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnJhZGl1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBjcmVhdGUgY2lyY2xlXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBLb252YS5DaXJjbGUoe1xuICAgICAqICAgcmFkaXVzOiA0MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snXG4gICAgICogICBzdHJva2VXaWR0aDogNVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLkNpcmNsZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuQ2lyY2xlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gQ0lSQ0xFO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0UmFkaXVzKCksIDAsIFBJeDIsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSB3aWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkNpcmNsZSwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNpcmNsZSwgJ3JhZGl1cycsIDApO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5DaXJjbGUsICdyYWRpdXMnKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgcmFkaXVzXG4gICAgICogQG5hbWUgcmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5DaXJjbGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaXVzXG4gICAgICogdmFyIHJhZGl1cyA9IGNpcmNsZS5yYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpdXNcbiAgICAgKiBjaXJjbGUucmFkaXVzKDEwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5DaXJjbGUpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyB0aGUgMC4wMDAxIG9mZnNldCBmaXhlcyBhIGJ1ZyBpbiBDaHJvbWUgMjdcbiAgICB2YXIgUEl4MiA9IChNYXRoLlBJICogMikgLSAwLjAwMDEsXG4gICAgICAgIEVMTElQU0UgPSAnRWxsaXBzZSc7XG5cbiAgICAvKipcbiAgICAgKiBFbGxpcHNlIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcucmFkaXVzIGRlZmluZXMgeCBhbmQgeSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGVsbGlwc2UgPSBuZXcgS29udmEuRWxsaXBzZSh7XG4gICAgICogICByYWRpdXMgOiB7XG4gICAgICogICAgIHggOiA1MCxcbiAgICAgKiAgICAgeSA6IDUwXG4gICAgICogICB9LFxuICAgICAqICAgZmlsbDogJ3JlZCdcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5FbGxpcHNlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5FbGxpcHNlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gRUxMSVBTRTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByeCA9IHRoaXMuZ2V0UmFkaXVzWCgpLFxuICAgICAgICAgICAgICAgIHJ5ID0gdGhpcy5nZXRSYWRpdXNZKCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGlmKHJ4ICE9PSByeSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuc2NhbGUoMSwgcnkgLyByeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByeCwgMCwgUEl4MiwgZmFsc2UpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldFdpZHRoKClcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzWCgpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1c1koKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKHtcbiAgICAgICAgICAgICAgICB4OiB3aWR0aCAvIDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKHtcbiAgICAgICAgICAgICAgICB5OiBoZWlnaHQgLyAyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuRWxsaXBzZSwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5FbGxpcHNlLCAncmFkaXVzJywgWyd4JywgJ3knXSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHJhZGl1c1xuICAgICAqIEBuYW1lIHJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWxsaXBzZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cy54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cy55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByYWRpdXNcbiAgICAgKiB2YXIgcmFkaXVzID0gZWxsaXBzZS5yYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpdXNcbiAgICAgKiBlbGxpcHNlLnJhZGl1cyh7XG4gICAgICogICB4OiAyMDAsXG4gICAgICogICB5OiAxMDBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkVsbGlwc2UsICdyYWRpdXNYJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCByYWRpdXMgeFxuICAgICAqIEBuYW1lIHJhZGl1c1hcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkVsbGlwc2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHJhZGl1cyB4XG4gICAgICogdmFyIHJhZGl1c1ggPSBlbGxpcHNlLnJhZGl1c1goKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpdXMgeFxuICAgICAqIGVsbGlwc2UucmFkaXVzWCgyMDApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuRWxsaXBzZSwgJ3JhZGl1c1knLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHJhZGl1cyB5XG4gICAgICogQG5hbWUgcmFkaXVzWVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWxsaXBzZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaXVzIHlcbiAgICAgKiB2YXIgcmFkaXVzWSA9IGVsbGlwc2UucmFkaXVzWSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGl1cyB5XG4gICAgICogZWxsaXBzZS5yYWRpdXNZKDIwMCk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuRWxsaXBzZSk7XG5cbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gdGhlIDAuMDAwMSBvZmZzZXQgZml4ZXMgYSBidWcgaW4gQ2hyb21lIDI3XG4gICAgdmFyIFBJeDIgPSAoTWF0aC5QSSAqIDIpIC0gMC4wMDAxO1xuICAgIC8qKlxuICAgICAqIFJpbmcgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5pbm5lclJhZGl1c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcub3V0ZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xvY2t3aXNlXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcmluZyA9IG5ldyBLb252YS5SaW5nKHtcbiAgICAgKiAgIGlubmVyUmFkaXVzOiA0MCxcbiAgICAgKiAgIG91dGVyUmFkaXVzOiA4MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAqICAgc3Ryb2tlV2lkdGg6IDVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5SaW5nID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5SaW5nLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1JpbmcnO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0SW5uZXJSYWRpdXMoKSwgMCwgUEl4MiwgZmFsc2UpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odGhpcy5nZXRPdXRlclJhZGl1cygpLCAwKTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSwgUEl4MiwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldFdpZHRoKClcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0ZXJSYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRlclJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgICAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dGVyUmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRPdXRlclJhZGl1czogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyKCdvdXRlclJhZGl1cycsIHZhbCk7XG4gICAgICAgICAgICB0aGlzLnNldFdpZHRoKHZhbCAqIDIpO1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQodmFsICogMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlJpbmcsIEtvbnZhLlNoYXBlKTtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5SaW5nLCAnaW5uZXJSYWRpdXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgaW5uZXJSYWRpdXNcbiAgICAgKiBAbmFtZSBpbm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5uZXJSYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGlubmVyIHJhZGl1c1xuICAgICAqIHZhciBpbm5lclJhZGl1cyA9IHJpbmcuaW5uZXJSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBpbm5lciByYWRpdXNcbiAgICAgKiByaW5nLmlubmVyUmFkaXVzKDIwKTtcbiAgICAgKi9cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5SaW5nLCAnb3V0ZXJSYWRpdXMnLCAwKTtcbiAgICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuUmluZywgJ291dGVyUmFkaXVzJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG91dGVyUmFkaXVzXG4gICAgICogQG5hbWUgb3V0ZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyUmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBvdXRlciByYWRpdXNcbiAgICAgKiB2YXIgb3V0ZXJSYWRpdXMgPSByaW5nLm91dGVyUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogcmluZy5vdXRlclJhZGl1cygyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuUmluZyk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIFdlZGdlIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucmFkaXVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsb2Nrd2lzZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZHJhdyBhIHdlZGdlIHRoYXQncyBwb2ludGluZyBkb3dud2FyZHNcbiAgICAgKiB2YXIgd2VkZ2UgPSBuZXcgS29udmEuV2VkZ2Uoe1xuICAgICAqICAgcmFkaXVzOiA0MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snXG4gICAgICogICBzdHJva2VXaWR0aDogNSxcbiAgICAgKiAgIGFuZ2xlRGVnOiA2MCxcbiAgICAgKiAgIHJvdGF0aW9uRGVnOiAtMTIwXG4gICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuV2VkZ2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLldlZGdlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1dlZGdlJztcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLmdldFJhZGl1cygpLCAwLCBLb252YS5nZXRBbmdsZSh0aGlzLmdldEFuZ2xlKCkpLCB0aGlzLmdldENsb2Nrd2lzZSgpKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIDApO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgICAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhZGl1cyhoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuV2VkZ2UsIEtvbnZhLlNoYXBlKTtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5XZWRnZSwgJ3JhZGl1cycsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCByYWRpdXNcbiAgICAgKiBAbmFtZSByYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLldlZGdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHJhZGl1c1xuICAgICAqIHZhciByYWRpdXMgPSB3ZWRnZS5yYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpdXNcbiAgICAgKiB3ZWRnZS5yYWRpdXMoMTApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuV2VkZ2UsICdhbmdsZScsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQG5hbWUgYW5nbGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLldlZGdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgYW5nbGVcbiAgICAgKiB2YXIgYW5nbGUgPSB3ZWRnZS5hbmdsZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGFuZ2xlXG4gICAgICogd2VkZ2UuYW5nbGUoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuV2VkZ2UsICdjbG9ja3dpc2UnLCBmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsb2Nrd2lzZSBmbGFnXG4gICAgICogQG5hbWUgY2xvY2t3aXNlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5XZWRnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2xvY2t3aXNlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbG9ja3dpc2UgZmxhZ1xuICAgICAqIHZhciBjbG9ja3dpc2UgPSB3ZWRnZS5jbG9ja3dpc2UoKTtcbiAgICAgKlxuICAgICAqIC8vIGRyYXcgd2VkZ2UgY291bnRlci1jbG9ja3dpc2VcbiAgICAgKiB3ZWRnZS5jbG9ja3dpc2UoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZHJhdyB3ZWRnZSBjbG9ja3dpc2VcbiAgICAgKiB3ZWRnZS5jbG9ja3dpc2UodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmJhY2tDb21wYXQoS29udmEuV2VkZ2UsIHtcbiAgICAgICAgYW5nbGVEZWc6ICdhbmdsZScsXG4gICAgICAgIGdldEFuZ2xlRGVnOiAnZ2V0QW5nbGUnLFxuICAgICAgICBzZXRBbmdsZURlZzogJ3NldEFuZ2xlJ1xuICAgIH0pO1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLldlZGdlKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogQXJjIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLm91dGVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmNsb2Nrd2lzZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZHJhdyBhIEFyYyB0aGF0J3MgcG9pbnRpbmcgZG93bndhcmRzXG4gICAgICogdmFyIGFyYyA9IG5ldyBLb252YS5BcmMoe1xuICAgICAqICAgaW5uZXJSYWRpdXM6IDQwLFxuICAgICAqICAgb3V0ZXJSYWRpdXM6IDgwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaydcbiAgICAgKiAgIHN0cm9rZVdpZHRoOiA1LFxuICAgICAqICAgYW5nbGU6IDYwLFxuICAgICAqICAgcm90YXRpb25EZWc6IC0xMjBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5BcmMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLkFyYy5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9jZW50cm9pZDogdHJ1ZSxcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdBcmMnO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gS29udmEuZ2V0QW5nbGUodGhpcy5hbmdsZSgpKSxcbiAgICAgICAgICAgICAgICBjbG9ja3dpc2UgPSB0aGlzLmNsb2Nrd2lzZSgpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRPdXRlclJhZGl1cygpLCAwLCBhbmdsZSwgY2xvY2t3aXNlKTtcbiAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0SW5uZXJSYWRpdXMoKSwgYW5nbGUsIDAsICFjbG9ja3dpc2UpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRIZWlnaHQoKVxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldE91dGVyUmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRPdXRlclJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRlclJhZGl1cyhoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQXJjLCBLb252YS5TaGFwZSk7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJjLCAnaW5uZXJSYWRpdXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgaW5uZXJSYWRpdXNcbiAgICAgKiBAbmFtZSBpbm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJjLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaW5uZXIgcmFkaXVzXG4gICAgICogdmFyIGlubmVyUmFkaXVzID0gYXJjLmlubmVyUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgaW5uZXIgcmFkaXVzXG4gICAgICogYXJjLmlubmVyUmFkaXVzKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFyYywgJ291dGVyUmFkaXVzJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IG91dGVyUmFkaXVzXG4gICAgICogQG5hbWUgb3V0ZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFyYy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJSYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IG91dGVyIHJhZGl1c1xuICAgICAqIHZhciBvdXRlclJhZGl1cyA9IGFyYy5vdXRlclJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IG91dGVyIHJhZGl1c1xuICAgICAqIGFyYy5vdXRlclJhZGl1cygyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcmMsICdhbmdsZScsIDApO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQG5hbWUgYW5nbGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkFyYy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGFuZ2xlXG4gICAgICogdmFyIGFuZ2xlID0gYXJjLmFuZ2xlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgYW5nbGVcbiAgICAgKiBhcmMuYW5nbGUoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJjLCAnY2xvY2t3aXNlJywgZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBjbG9ja3dpc2UgZmxhZ1xuICAgICAqIEBuYW1lIGNsb2Nrd2lzZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJjLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvY2t3aXNlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xvY2t3aXNlIGZsYWdcbiAgICAgKiB2YXIgY2xvY2t3aXNlID0gYXJjLmNsb2Nrd2lzZSgpO1xuICAgICAqXG4gICAgICogLy8gZHJhdyBhcmMgY291bnRlci1jbG9ja3dpc2VcbiAgICAgKiBhcmMuY2xvY2t3aXNlKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGRyYXcgYXJjIGNsb2Nrd2lzZVxuICAgICAqIGFyYy5jbG9ja3dpc2UodHJ1ZSk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQXJjKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gQ09OU1RBTlRTXG4gICAgdmFyIElNQUdFID0gJ0ltYWdlJztcblxuICAgIC8qKlxuICAgICAqIEltYWdlIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGNvbmZpZy5pbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNyb3BdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBpbWFnZU9iaiA9IG5ldyBJbWFnZSgpO1xuICAgICAqIGltYWdlT2JqLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAqICAgdmFyIGltYWdlID0gbmV3IEtvbnZhLkltYWdlKHtcbiAgICAgKiAgICAgeDogMjAwLFxuICAgICAqICAgICB5OiA1MCxcbiAgICAgKiAgICAgaW1hZ2U6IGltYWdlT2JqLFxuICAgICAqICAgICB3aWR0aDogMTAwLFxuICAgICAqICAgICBoZWlnaHQ6IDEwMFxuICAgICAqICAgfSk7XG4gICAgICogfTtcbiAgICAgKiBpbWFnZU9iai5zcmMgPSAnL3BhdGgvdG8vaW1hZ2UuanBnJ1xuICAgICAqL1xuICAgIEtvbnZhLkltYWdlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5JbWFnZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBJTUFHRTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgICAgICB0aGlzLmhpdEZ1bmModGhpcy5faGl0RnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF91c2VCdWZmZXJDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmhhc1NoYWRvdygpIHx8IHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDEpICYmIHRoaXMuaGFzU3Ryb2tlKCkgJiYgdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBpbWFnZSA9IHRoaXMuZ2V0SW1hZ2UoKSxcbiAgICAgICAgICAgICAgICBjcm9wV2lkdGgsIGNyb3BIZWlnaHQsIHBhcmFtcztcblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgY3JvcFdpZHRoID0gdGhpcy5nZXRDcm9wV2lkdGgoKTtcbiAgICAgICAgICAgICAgICBjcm9wSGVpZ2h0ID0gdGhpcy5nZXRDcm9wSGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNyb3BXaWR0aCAmJiBjcm9wSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IFtpbWFnZSwgdGhpcy5nZXRDcm9wWCgpLCB0aGlzLmdldENyb3BZKCksIGNyb3BXaWR0aCwgY3JvcEhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gW2ltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZpbGwoKSB8fCB0aGlzLmhhc1N0cm9rZSgpKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2hpdEZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmdldEltYWdlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy53aWR0aCB8fCAoaW1hZ2UgPyBpbWFnZS53aWR0aCA6IDApO1xuICAgICAgICB9LFxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuaGVpZ2h0IHx8IChpbWFnZSA/IGltYWdlLmhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5JbWFnZSwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnaW1hZ2UnKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBpbWFnZVxuICAgICAqIEBuYW1lIHNldEltYWdlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGltYWdlXG4gICAgICogQG5hbWUgZ2V0SW1hZ2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtJbWFnZX1cbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3AnLCBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXSk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBjcm9wXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBuYW1lIGNyb3BcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNyb3BcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3JvcC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3AueVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjcm9wLndpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3AuaGVpZ2h0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjcm9wXG4gICAgICogdmFyIGNyb3AgPSBpbWFnZS5jcm9wKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY3JvcFxuICAgICAqIGltYWdlLmNyb3Aoe1xuICAgICAqICAgeDogMjAsXG4gICAgICogICB5OiAyMCxcbiAgICAgKiAgIHdpZHRoOiAyMCxcbiAgICAgKiAgIGhlaWdodDogMjBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnY3JvcFgnLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNyb3AgeFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbmFtZSBjcm9wWFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY3JvcCB4XG4gICAgICogdmFyIGNyb3BYID0gaW1hZ2UuY3JvcFgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjcm9wIHhcbiAgICAgKiBpbWFnZS5jcm9wWCgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3BZJywgMCk7XG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBjcm9wIHlcbiAgICAgKiBAbmFtZSBjcm9wWVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNyb3AgeVxuICAgICAqIHZhciBjcm9wWSA9IGltYWdlLmNyb3BZKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY3JvcCB5XG4gICAgICogaW1hZ2UuY3JvcFkoMjApO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuSW1hZ2UsICdjcm9wV2lkdGgnLCAwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNyb3Agd2lkdGhcbiAgICAgKiBAbmFtZSBjcm9wV2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY3JvcCB3aWR0aFxuICAgICAqIHZhciBjcm9wV2lkdGggPSBpbWFnZS5jcm9wV2lkdGgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjcm9wIHdpZHRoXG4gICAgICogaW1hZ2UuY3JvcFdpZHRoKDIwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkltYWdlLCAnY3JvcEhlaWdodCcsIDApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgY3JvcCBoZWlnaHRcbiAgICAgKiBAbmFtZSBjcm9wSGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjcm9wIGhlaWdodFxuICAgICAqIHZhciBjcm9wSGVpZ2h0ID0gaW1hZ2UuY3JvcEhlaWdodCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNyb3AgaGVpZ2h0XG4gICAgICogaW1hZ2UuY3JvcEhlaWdodCgyMCk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuSW1hZ2UpO1xuXG4gICAgLyoqXG4gICAgICogbG9hZCBpbWFnZSBmcm9tIGdpdmVuIHVybCBhbmQgY3JlYXRlIGBLb252YS5JbWFnZWAgaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBpbWFnZSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB3aXRoIEtvbnZhLkltYWdlIGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgS29udmEuSW1hZ2UuZnJvbVVSTChpbWFnZVVSTCwgZnVuY3Rpb24oaW1hZ2Upe1xuICAgICAqICAgIC8vIGltYWdlIGlzIEtvbnZhLkltYWdlIGluc3RhbmNlXG4gICAgICogICAgbGF5ZXIuYWRkKGltYWdlKTtcbiAgICAgKiAgICBsYXllci5kcmF3KCk7XG4gICAgICogIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLkltYWdlLmZyb21VUkwgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBLb252YS5JbWFnZSh7XG4gICAgICAgICAgICBpbWFnZTogaW1nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2FsbGJhY2soaW1hZ2UpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH07XG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBjb25zdGFudHNcbiAgICB2YXIgQVVUTyA9ICdhdXRvJyxcbiAgICAgICAgLy9DQU5WQVMgPSAnY2FudmFzJyxcbiAgICAgICAgQ0VOVEVSID0gJ2NlbnRlcicsXG4gICAgICAgIENIQU5HRV9LT05WQSA9ICdDaGFuZ2Uua29udmEnLFxuICAgICAgICBDT05URVhUXzJEID0gJzJkJyxcbiAgICAgICAgREFTSCA9ICctJyxcbiAgICAgICAgRU1QVFlfU1RSSU5HID0gJycsXG4gICAgICAgIExFRlQgPSAnbGVmdCcsXG4gICAgICAgIFRFWFQgPSAndGV4dCcsXG4gICAgICAgIFRFWFRfVVBQRVIgPSAnVGV4dCcsXG4gICAgICAgIE1JRERMRSA9ICdtaWRkbGUnLFxuICAgICAgICBOT1JNQUwgPSAnbm9ybWFsJyxcbiAgICAgICAgUFhfU1BBQ0UgPSAncHggJyxcbiAgICAgICAgU1BBQ0UgPSAnICcsXG4gICAgICAgIFJJR0hUID0gJ3JpZ2h0JyxcbiAgICAgICAgV09SRCA9ICd3b3JkJyxcbiAgICAgICAgQ0hBUiA9ICdjaGFyJyxcbiAgICAgICAgTk9ORSA9ICdub25lJyxcbiAgICAgICAgQVRUUl9DSEFOR0VfTElTVCA9IFsnZm9udEZhbWlseScsICdmb250U2l6ZScsICdmb250U3R5bGUnLCAnZm9udFZhcmlhbnQnLCAncGFkZGluZycsICdhbGlnbicsICdsaW5lSGVpZ2h0JywgJ3RleHQnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3dyYXAnXSxcblxuICAgICAgICAvLyBjYWNoZWQgdmFyaWFibGVzXG4gICAgICAgIGF0dHJDaGFuZ2VMaXN0TGVuID0gQVRUUl9DSEFOR0VfTElTVC5sZW5ndGgsXG4gICAgICAgIGR1bW15Q29udGV4dCA9IEtvbnZhLlV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLmdldENvbnRleHQoQ09OVEVYVF8yRCk7XG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRGYW1pbHldIGRlZmF1bHQgaXMgQXJpYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5mb250U2l6ZV0gaW4gcGl4ZWxzLiAgRGVmYXVsdCBpcyAxMlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRTdHlsZV0gY2FuIGJlIG5vcm1hbCwgYm9sZCwgb3IgaXRhbGljLiAgRGVmYXVsdCBpcyBub3JtYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250VmFyaWFudF0gY2FuIGJlIG5vcm1hbCBvciBzbWFsbC1jYXBzLiAgRGVmYXVsdCBpcyBub3JtYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnRleHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5hbGlnbl0gY2FuIGJlIGxlZnQsIGNlbnRlciwgb3IgcmlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wYWRkaW5nXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmxpbmVIZWlnaHRdIGRlZmF1bHQgaXMgMVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLndyYXBdIGNhbiBiZSB3b3JkLCBjaGFyLCBvciBub25lLiBEZWZhdWx0IGlzIHdvcmRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHRleHQgPSBuZXcgS29udmEuVGV4dCh7XG4gICAgICogICB4OiAxMCxcbiAgICAgKiAgIHk6IDE1LFxuICAgICAqICAgdGV4dDogJ1NpbXBsZSBUZXh0JyxcbiAgICAgKiAgIGZvbnRTaXplOiAzMCxcbiAgICAgKiAgIGZvbnRGYW1pbHk6ICdDYWxpYnJpJyxcbiAgICAgKiAgIGZpbGw6ICdncmVlbidcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5UZXh0ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX2ZpbGxGdW5jKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCh0aGlzLnBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3N0cm9rZUZ1bmMoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGhpcy5wYXJ0aWFsVGV4dCwgMCwgMCk7XG4gICAgfVxuXG4gICAgS29udmEuVGV4dC5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyBzZXQgZGVmYXVsdCBjb2xvciB0byBibGFja1xuICAgICAgICAgICAgaWYgKCFjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcyAmJiAhY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZmlsbCA9IGNvbmZpZy5maWxsIHx8ICdibGFjayc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaWYgKGNvbmZpZy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyAgICAgY29uZmlnLndpZHRoID0gQVVUTztcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGlmIChjb25maWcuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vICAgICBjb25maWcuaGVpZ2h0ID0gQVVUTztcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuXG4gICAgICAgICAgICB0aGlzLl9maWxsRnVuYyA9IF9maWxsRnVuYztcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZUZ1bmMgPSBfc3Ryb2tlRnVuYztcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gVEVYVF9VUFBFUjtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRleHQgZGF0YSBmb3IgY2VydGFpbiBhdHRyIGNoYW5nZXNcbiAgICAgICAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBhdHRyQ2hhbmdlTGlzdExlbjsgbisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbihBVFRSX0NIQU5HRV9MSVNUW25dICsgQ0hBTkdFX0tPTlZBLCB0aGlzLl9zZXRUZXh0RGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFRleHREYXRhKCk7XG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICAgICAgdGhpcy5oaXRGdW5jKHRoaXMuX2hpdEZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0UGFkZGluZygpLFxuICAgICAgICAgICAgICAgIHRleHRIZWlnaHQgPSB0aGlzLmdldFRleHRIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0UHggPSB0aGlzLmdldExpbmVIZWlnaHQoKSAqIHRleHRIZWlnaHQsXG4gICAgICAgICAgICAgICAgdGV4dEFyciA9IHRoaXMudGV4dEFycixcbiAgICAgICAgICAgICAgICB0ZXh0QXJyTGVuID0gdGV4dEFyci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdG90YWxXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBuO1xuXG4gICAgICAgICAgICBjb250ZXh0LnNldEF0dHIoJ2ZvbnQnLCB0aGlzLl9nZXRDb250ZXh0Rm9udCgpKTtcblxuICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QmFzZWxpbmUnLCBNSURETEUpO1xuICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QWxpZ24nLCBMRUZUKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShwLCAwKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgwLCBwICsgdGV4dEhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgwLCB0ZXh0SGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gZHJhdyB0ZXh0IGxpbmVzXG4gICAgICAgICAgICBmb3IobiA9IDA7IG4gPCB0ZXh0QXJyTGVuOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGV4dEFycltuXSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IG9iai50ZXh0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IG9iai53aWR0aDtcblxuICAgICAgICAgICAgICAgIC8vIGhvcml6b250YWwgYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5nZXRBbGlnbigpID09PSBSSUdIVCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh0b3RhbFdpZHRoIC0gd2lkdGggLSBwICogMiwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYodGhpcy5nZXRBbGlnbigpID09PSBDRU5URVIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoKHRvdGFsV2lkdGggLSB3aWR0aCAtIHAgKiAyKSAvIDIsIDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbFRleHQgPSB0ZXh0O1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMCwgbGluZUhlaWdodFB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9LFxuICAgICAgICBfaGl0RnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBLb252YS5VdGlsLl9pc1N0cmluZyh0ZXh0KSA/IHRleHQgOiAodGV4dCB8fCAnJykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHIoVEVYVCwgc3RyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHdpZHRoIG9mIHRleHQgYXJlYSwgd2hpY2ggaW5jbHVkZXMgcGFkZGluZ1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlzQXV0byA9ICh0aGlzLmF0dHJzLndpZHRoID09PSBBVVRPKSB8fCAodGhpcy5hdHRycy53aWR0aCA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybiBpc0F1dG8gPyB0aGlzLmdldFRleHRXaWR0aCgpICsgdGhpcy5nZXRQYWRkaW5nKCkgKiAyIDogdGhpcy5hdHRycy53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0IGFyZWEsIHdoaWNoIHRha2VzIGludG8gYWNjb3VudCBtdWx0aS1saW5lIHRleHQsIGxpbmUgaGVpZ2h0cywgYW5kIHBhZGRpbmdcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGlzQXV0byA9ICh0aGlzLmF0dHJzLmhlaWdodCA9PT0gQVVUTykgfHwgKHRoaXMuYXR0cnMuaGVpZ2h0ID09PSB1bmRlZmluZWQpO1xuICAgICAgICAgIHJldHVybiBpc0F1dG8gPyAodGhpcy5nZXRUZXh0SGVpZ2h0KCkgKiB0aGlzLnRleHRBcnIubGVuZ3RoICogdGhpcy5nZXRMaW5lSGVpZ2h0KCkpICsgdGhpcy5nZXRQYWRkaW5nKCkgKiAyIDogdGhpcy5hdHRycy5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGV4dCB3aWR0aFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGV4dFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHRXaWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCB0ZXh0IGhlaWdodFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGV4dEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0SGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0VGV4dFNpemU6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBfY29udGV4dCA9IGR1bW15Q29udGV4dCxcbiAgICAgICAgICAgICAgICBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKSxcbiAgICAgICAgICAgICAgICBtZXRyaWNzO1xuXG4gICAgICAgICAgICBfY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBfY29udGV4dC5mb250ID0gdGhpcy5fZ2V0Q29udGV4dEZvbnQoKTtcblxuICAgICAgICAgICAgbWV0cmljcyA9IF9jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgICAgICAgICAgX2NvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogbWV0cmljcy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGZvbnRTaXplLCAxMClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRDb250ZXh0Rm9udDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBJRSBkb24ndCB3YW50IHRvIHdvcmsgd2l0aCB1c3VhbCBmb250IHN0eWxlXG4gICAgICAgICAgICAvLyBib2xkIHdhcyBub3Qgd29ya2luZ1xuICAgICAgICAgICAgLy8gcmVtb3ZpbmcgZm9udCB2YXJpYW50IHdpbGwgc29sdmVcbiAgICAgICAgICAgIC8vIGZpeCBmb3I6IGh0dHBzOi8vZ2l0aHViLmNvbS9rb252YWpzL2tvbnZhL2lzc3Vlcy85NFxuICAgICAgICAgICAgaWYgKEtvbnZhLlVBLmlzSUUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb250U3R5bGUoKSArIFNQQUNFICsgdGhpcy5nZXRGb250U2l6ZSgpICsgUFhfU1BBQ0UgKyB0aGlzLmdldEZvbnRGYW1pbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZvbnRTdHlsZSgpICsgU1BBQ0UgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEZvbnRWYXJpYW50KCkgKyBTUEFDRSArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Rm9udFNpemUoKSArIFBYX1NQQUNFICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRGb250RmFtaWx5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9hZGRUZXh0TGluZTogZnVuY3Rpb24gKGxpbmUsIHdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0QXJyLnB1c2goe3RleHQ6IGxpbmUsIHdpZHRoOiB3aWR0aH0pO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0VGV4dFdpZHRoOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGR1bW15Q29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgX3NldFRleHREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmdldFRleHQoKS5zcGxpdCgnXFxuJyksXG4gICAgICAgICAgICAgICAgZm9udFNpemUgPSArdGhpcy5nZXRGb250U2l6ZSgpLFxuICAgICAgICAgICAgICAgIHRleHRXaWR0aCA9IDAsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodFB4ID0gdGhpcy5nZXRMaW5lSGVpZ2h0KCkgKiBmb250U2l6ZSxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMuYXR0cnMud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5hdHRycy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgZml4ZWRXaWR0aCA9IHdpZHRoICE9PSBBVVRPLFxuICAgICAgICAgICAgICAgIGZpeGVkSGVpZ2h0ID0gaGVpZ2h0ICE9PSBBVVRPLFxuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSB0aGlzLmdldFBhZGRpbmcoKSxcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IHdpZHRoIC0gcGFkZGluZyAqIDIsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0UHggPSBoZWlnaHQgLSBwYWRkaW5nICogMixcbiAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0UHggPSAwLFxuICAgICAgICAgICAgICAgIHdyYXAgPSB0aGlzLmdldFdyYXAoKSxcbiAgICAgICAgICAgICAgICBzaG91bGRXcmFwID0gd3JhcCAhPT0gTk9ORSxcbiAgICAgICAgICAgICAgICB3cmFwQXRXb3JkID0gd3JhcCAhPT0gQ0hBUiAmJiBzaG91bGRXcmFwO1xuXG4gICAgICAgICAgICB0aGlzLnRleHRBcnIgPSBbXTtcbiAgICAgICAgICAgIGR1bW15Q29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBkdW1teUNvbnRleHQuZm9udCA9IHRoaXMuX2dldENvbnRleHRGb250KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoOyBpIDwgbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldLFxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgobGluZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpeGVkV2lkdGggJiYgbGluZVdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICogaWYgd2lkdGggaXMgZml4ZWQgYW5kIGxpbmUgZG9lcyBub3QgZml0IGVudGlyZWx5XG4gICAgICAgICAgICAgICAgICAgICAqIGJyZWFrIHRoZSBsaW5lIGludG8gbXVsdGlwbGUgZml0dGluZyBsaW5lc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHVzZSBiaW5hcnkgc2VhcmNoIHRvIGZpbmQgdGhlIGxvbmdlc3Qgc3Vic3RyaW5nIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoYXQgd291bGQgZml0IGluIHRoZSBzcGVjaWZpZWQgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBsaW5lLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9ICcnLCBtYXRjaFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RyID0gbGluZS5zbGljZSgwLCBtaWQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RyV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgoc3Vic3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic3RyV2lkdGggPD0gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBzdWJzdHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoV2lkdGggPSBzdWJzdHJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAnbG93JyBpcyBub3cgdGhlIGluZGV4IG9mIHRoZSBzdWJzdHJpbmcgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAnbWF0Y2gnIGlzIHRoZSBzdWJzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICdtYXRjaFdpZHRoJyBpcyB0aGUgc3Vic3RyaW5nIHdpZHRoIGluIHB4XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZml0dGluZyBzdWJzdHJpbmcgd2FzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdyYXBBdFdvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGZpbmQgYSBzcGFjZSBvciBkYXNoIHdoZXJlIHdyYXBwaW5nIGNvdWxkIGJlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBJbmRleCA9IE1hdGgubWF4KG1hdGNoLmxhc3RJbmRleE9mKFNQQUNFKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5sYXN0SW5kZXhPZihEQVNIKSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod3JhcEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmUtY3V0IHRoZSBzdWJzdHJpbmcgZm91bmQgYXQgdGhlIHNwYWNlL2Rhc2ggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvdyA9IHdyYXBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2guc2xpY2UoMCwgbG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgobWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRleHRMaW5lKG1hdGNoLCBtYXRjaFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGgsIG1hdGNoV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIZWlnaHRQeCArPSBsaW5lSGVpZ2h0UHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRXcmFwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaXhlZEhlaWdodCAmJiBjdXJyZW50SGVpZ2h0UHggKyBsaW5lSGVpZ2h0UHggPiBtYXhIZWlnaHRQeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc3RvcCB3cmFwcGluZyBpZiB3cmFwcGluZyBpcyBkaXNhYmxlZCBvciBpZiBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogb25lIG1vcmUgbGluZSB3b3VsZCBvdmVyZmxvdyB0aGUgZml4ZWQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UobG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByZW1haW5pbmcgdGV4dCB3b3VsZCBmaXQgb24gb25lIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZVdpZHRoIDw9IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBkb2VzLCBhZGQgdGhlIGxpbmUgYW5kIGJyZWFrIG91dCBvZiB0aGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobGluZSwgbGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIZWlnaHRQeCArPSBsaW5lSGVpZ2h0UHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGgsIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGV2ZW4gb25lIGNoYXJhY3RlciBjb3VsZCBmaXQgaW4gdGhlIGVsZW1lbnQsIGFib3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHdpZHRoIGlzIGF1dG9tYXRpY2FsbHkgYWRqdXN0ZWQgdG8gbWF4IGxpbmUgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobGluZSwgbGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEhlaWdodFB4ICs9IGxpbmVIZWlnaHRQeDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFdpZHRoID0gTWF0aC5tYXgodGV4dFdpZHRoLCBsaW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiBlbGVtZW50IGhlaWdodCBpcyBmaXhlZCwgYWJvcnQgaWYgYWRkaW5nIG9uZSBtb3JlIGxpbmUgd291bGQgb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICBpZiAoZml4ZWRIZWlnaHQgJiYgY3VycmVudEhlaWdodFB4ICsgbGluZUhlaWdodFB4ID4gbWF4SGVpZ2h0UHgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVtbXlDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHRoaXMudGV4dEhlaWdodCA9IGZvbnRTaXplO1xuICAgICAgICAgICAgdGhpcy50ZXh0V2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlRleHQsIEtvbnZhLlNoYXBlKTtcblxuICAgIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnZm9udEZhbWlseScsICdBcmlhbCcpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBmb250IGZhbWlseVxuICAgICAqIEBuYW1lIGZvbnRGYW1pbHlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRGYW1pbHlcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZvbnQgZmFtaWx5XG4gICAgICogdmFyIGZvbnRGYW1pbHkgPSB0ZXh0LmZvbnRGYW1pbHkoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmb250IGZhbWlseVxuICAgICAqIHRleHQuZm9udEZhbWlseSgnQXJpYWwnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdmb250U2l6ZScsIDEyKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgZm9udCBzaXplIGluIHBpeGVsc1xuICAgICAqIEBuYW1lIGZvbnRTaXplXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb250U2l6ZVxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZm9udCBzaXplXG4gICAgICogdmFyIGZvbnRTaXplID0gdGV4dC5mb250U2l6ZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZvbnQgc2l6ZSB0byAyMnB4XG4gICAgICogdGV4dC5mb250U2l6ZSgyMik7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0LCAnZm9udFN0eWxlJywgTk9STUFMKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBmb250IHN0eWxlLiAgQ2FuIGJlICdub3JtYWwnLCAnaXRhbGljJywgb3IgJ2JvbGQnLiAgJ25vcm1hbCcgaXMgdGhlIGRlZmF1bHQuXG4gICAgICogQG5hbWUgZm9udFN0eWxlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250U3R5bGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZvbnQgc3R5bGVcbiAgICAgKiB2YXIgZm9udFN0eWxlID0gdGV4dC5mb250U3R5bGUoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBmb250IHN0eWxlXG4gICAgICogdGV4dC5mb250U3R5bGUoJ2JvbGQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdmb250VmFyaWFudCcsIE5PUk1BTCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgZm9udCB2YXJpYW50LiAgQ2FuIGJlICdub3JtYWwnIG9yICdzbWFsbC1jYXBzJy4gICdub3JtYWwnIGlzIHRoZSBkZWZhdWx0LlxuICAgICAqIEBuYW1lIGZvbnRWYXJpYW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250VmFyaWFudFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZm9udCB2YXJpYW50XG4gICAgICogdmFyIGZvbnRWYXJpYW50ID0gdGV4dC5mb250VmFyaWFudCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZvbnQgdmFyaWFudFxuICAgICAqIHRleHQuZm9udFZhcmlhbnQoJ3NtYWxsLWNhcHMnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdwYWRkaW5nJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgcGFkZGluZ1xuICAgICAqIEBuYW1lIHBhZGRpbmdcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhZGRpbmdcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHBhZGRpbmdcbiAgICAgKiB2YXIgcGFkZGluZyA9IHRleHQucGFkZGluZygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHBhZGRpbmcgdG8gMTAgcGl4ZWxzXG4gICAgICogdGV4dC5wYWRkaW5nKDEwKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdhbGlnbicsIExFRlQpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBob3Jpem9udGFsIGFsaWduIG9mIHRleHQuICBDYW4gYmUgJ2xlZnQnLCAnY2VudGVyJywgb3IgJ3JpZ2h0J1xuICAgICAqIEBuYW1lIGFsaWduXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlnblxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgdGV4dCBhbGlnblxuICAgICAqIHZhciBhbGlnbiA9IHRleHQuYWxpZ24oKTtcbiAgICAgKlxuICAgICAqIC8vIGNlbnRlciB0ZXh0XG4gICAgICogdGV4dC5hbGlnbignY2VudGVyJyk7XG4gICAgICpcbiAgICAgKiAvLyBhbGlnbiB0ZXh0IHRvIHJpZ2h0XG4gICAgICogdGV4dC5hbGlnbigncmlnaHQnKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdsaW5lSGVpZ2h0JywgMSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGxpbmUgaGVpZ2h0LiAgVGhlIGRlZmF1bHQgaXMgMS5cbiAgICAgKiBAbmFtZSBsaW5lSGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBsaW5lIGhlaWdodFxuICAgICAqIHZhciBsaW5lSGVpZ2h0ID0gdGV4dC5saW5lSGVpZ2h0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgdGhlIGxpbmUgaGVpZ2h0XG4gICAgICogdGV4dC5saW5lSGVpZ2h0KDIpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ3dyYXAnLCBXT1JEKTtcblxuICAgIC8qKlxuICAgICAqIGdldC9zZXQgd3JhcC4gIENhbiBiZSB3b3JkLCBjaGFyLCBvciBub25lLiBEZWZhdWx0IGlzIHdvcmQuXG4gICAgICogQG5hbWUgd3JhcFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd3JhcFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgd3JhcFxuICAgICAqIHZhciB3cmFwID0gdGV4dC53cmFwKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgd3JhcFxuICAgICAqIHRleHQud3JhcCgnd29yZCcpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuVGV4dCwgJ3RleHQnLCBFTVBUWV9TVFJJTkcpO1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcihLb252YS5UZXh0LCAndGV4dCcpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCB0ZXh0XG4gICAgICogQG5hbWUgZ2V0VGV4dFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgdGV4dFxuICAgICAqIHZhciB0ZXh0ID0gdGV4dC50ZXh0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgdGV4dFxuICAgICAqIHRleHQudGV4dCgnSGVsbG8gd29ybGQhJyk7XG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVGV4dCk7XG59KSgpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBMaW5lIGNvbnN0cnVjdG9yLiZuYnNwOyBMaW5lcyBhcmUgZGVmaW5lZCBieSBhbiBhcnJheSBvZiBwb2ludHMgYW5kXG4gICAgICogIGEgdGVuc2lvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWcucG9pbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcudGVuc2lvbl0gSGlnaGVyIHZhbHVlcyB3aWxsIHJlc3VsdCBpbiBhIG1vcmUgY3VydnkgbGluZS4gIEEgdmFsdWUgb2YgMCB3aWxsIHJlc3VsdCBpbiBubyBpbnRlcnBvbGF0aW9uLlxuICAgICAqICAgVGhlIGRlZmF1bHQgaXMgMFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbG9zZWRdIGRlZmluZXMgd2hldGhlciBvciBub3QgdGhlIGxpbmUgc2hhcGUgaXMgY2xvc2VkLCBjcmVhdGluZyBhIHBvbHlnb24gb3IgYmxvYlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbGluZSA9IG5ldyBLb252YS5MaW5lKHtcbiAgICAgKiAgIHg6IDEwMCxcbiAgICAgKiAgIHk6IDUwLFxuICAgICAqICAgcG9pbnRzOiBbNzMsIDcwLCAzNDAsIDIzLCA0NTAsIDYwLCA1MDAsIDIwXSxcbiAgICAgKiAgIHN0cm9rZTogJ3JlZCcsXG4gICAgICogICB0ZW5zaW9uOiAxXG4gICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuTGluZSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLkxpbmUucHJvdG90eXBlID0ge1xuICAgICAgICBfX19pbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdMaW5lJztcblxuICAgICAgICAgICAgdGhpcy5vbigncG9pbnRzQ2hhbmdlLmtvbnZhIHRlbnNpb25DaGFuZ2Uua29udmEgY2xvc2VkQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoJ3RlbnNpb25Qb2ludHMnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCksXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB0ZW5zaW9uID0gdGhpcy5nZXRUZW5zaW9uKCksXG4gICAgICAgICAgICAgICAgY2xvc2VkID0gdGhpcy5nZXRDbG9zZWQoKSxcbiAgICAgICAgICAgICAgICB0cCwgbGVuLCBuO1xuXG4gICAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgICAgICAgLy8gdGVuc2lvblxuICAgICAgICAgICAgaWYgKHRlbnNpb24gIT09IDAgJiYgbGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgIHRwID0gdGhpcy5nZXRUZW5zaW9uUG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgbGVuID0gdHAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG4gPSBjbG9zZWQgPyAwIDogNDtcblxuICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh0cFswXSwgdHBbMV0sIHRwWzJdLCB0cFszXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW4gLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdLCB0cFtuKytdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8odHBbbGVuIC0gMl0sIHRwW2xlbiAtIDFdLCBwb2ludHNbbGVuZ3RoIC0gMl0sIHBvaW50c1tsZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gdGVuc2lvblxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChuID0gMjsgbiA8IGxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50c1tuXSwgcG9pbnRzW24gKyAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbG9zZWQgZS5nLiBwb2x5Z29ucyBhbmQgYmxvYnNcbiAgICAgICAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3BlbiBlLmcuIGxpbmVzIGFuZCBzcGxpbmVzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRUZW5zaW9uUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoJ3RlbnNpb25Qb2ludHMnLCB0aGlzLl9nZXRUZW5zaW9uUG9pbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldFRlbnNpb25Qb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldENsb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRlbnNpb25Qb2ludHNDbG9zZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEtvbnZhLlV0aWwuX2V4cGFuZFBvaW50cyh0aGlzLmdldFBvaW50cygpLCB0aGlzLmdldFRlbnNpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRUZW5zaW9uUG9pbnRzQ2xvc2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0UG9pbnRzKCksXG4gICAgICAgICAgICAgICAgbGVuID0gcC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGVuc2lvbiA9IHRoaXMuZ2V0VGVuc2lvbigpLFxuICAgICAgICAgICAgICAgIHV0aWwgPSBLb252YS5VdGlsLFxuICAgICAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50cyA9IHV0aWwuX2dldENvbnRyb2xQb2ludHMoXG4gICAgICAgICAgICAgICAgICAgIHBbbGVuIC0gMl0sXG4gICAgICAgICAgICAgICAgICAgIHBbbGVuIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgIHBbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBbMl0sXG4gICAgICAgICAgICAgICAgICAgIHBbM10sXG4gICAgICAgICAgICAgICAgICAgIHRlbnNpb25cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGxhc3RDb250cm9sUG9pbnRzID0gdXRpbC5fZ2V0Q29udHJvbFBvaW50cyhcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSA0XSxcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSAzXSxcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSAyXSxcbiAgICAgICAgICAgICAgICAgICAgcFtsZW4gLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgcFswXSxcbiAgICAgICAgICAgICAgICAgICAgcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgdGVuc2lvblxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbWlkZGxlID0gS29udmEuVXRpbC5fZXhwYW5kUG9pbnRzKHAsIHRlbnNpb24pLFxuICAgICAgICAgICAgICAgIHRwID0gW1xuICAgICAgICAgICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1szXVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAuY29uY2F0KG1pZGRsZSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250cm9sUG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBwW2xlbiAtIDJdLFxuICAgICAgICAgICAgICAgICAgICBwW2xlbiAtIDFdLFxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udHJvbFBvaW50c1syXSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbM10sXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDb250cm9sUG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBwWzBdLFxuICAgICAgICAgICAgICAgICAgICBwWzFdXG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlbGZSZWN0KCkud2lkdGg7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZlJlY3QoKS5oZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG92ZXJsb2FkIHNpemUgZGV0ZWN0aW9uXG4gICAgICAgIGdldFNlbGZSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VGVuc2lvbigpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5fZ2V0VGVuc2lvblBvaW50cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pblggPSBwb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgbWF4WCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciBtaW5ZID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgdmFyIG1heFkgPSBwb2ludHNbMV07XG4gICAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIHggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQobWluWCksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChtaW5ZKSxcbiAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChtYXhYIC0gbWluWCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKG1heFkgLSBtaW5ZKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuTGluZSwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxpbmUsICdjbG9zZWQnLCBmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGNsb3NlZCBmbGFnLiAgVGhlIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgKiBAbmFtZSBjbG9zZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkxpbmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjbG9zZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbG9zZWQgZmxhZ1xuICAgICAqIHZhciBjbG9zZWQgPSBsaW5lLmNsb3NlZCgpO1xuICAgICAqXG4gICAgICogLy8gY2xvc2UgdGhlIHNoYXBlXG4gICAgICogbGluZS5jbG9zZWQodHJ1ZSk7XG4gICAgICpcbiAgICAgKiAvLyBvcGVuIHRoZSBzaGFwZVxuICAgICAqIGxpbmUuY2xvc2VkKGZhbHNlKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxpbmUsICd0ZW5zaW9uJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHRlbnNpb25cbiAgICAgKiBAbmFtZSB0ZW5zaW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5MaW5lLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBIaWdoZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIGEgbW9yZSBjdXJ2eSBsaW5lLiAgQSB2YWx1ZSBvZiAwIHdpbGwgcmVzdWx0IGluIG5vIGludGVycG9sYXRpb24uXG4gICAgICogICBUaGUgZGVmYXVsdCBpcyAwXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB0ZW5zaW9uXG4gICAgICogdmFyIHRlbnNpb24gPSBsaW5lLnRlbnNpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCB0ZW5zaW9uXG4gICAgICogbGluZS50ZW5zaW9uKDMpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTGluZSwgJ3BvaW50cycsIFtdKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHBvaW50cyBhcnJheVxuICAgICAqIEBuYW1lIHBvaW50c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTGluZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcG9pbnRzXG4gICAgICogdmFyIHBvaW50cyA9IGxpbmUucG9pbnRzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgcG9pbnRzXG4gICAgICogbGluZS5wb2ludHMoWzEwLCAyMCwgMzAsIDQwLCA1MCwgNjBdKTtcbiAgICAgKlxuICAgICAqIC8vIHB1c2ggYSBuZXcgcG9pbnRcbiAgICAgKiBsaW5lLnBvaW50cyhsaW5lLnBvaW50cygpLmNvbmNhdChbNzAsIDgwXSkpO1xuICAgICAqL1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkxpbmUpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBTcHJpdGUgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5hbmltYXRpb24gYW5pbWF0aW9uIGtleVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcuYW5pbWF0aW9ucyBhbmltYXRpb24gbWFwXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbY29uZmlnLmZyYW1lSW5kZXhdIGFuaW1hdGlvbiBmcmFtZSBpbmRleFxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGNvbmZpZy5pbWFnZSBpbWFnZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGltYWdlT2JqID0gbmV3IEltYWdlKCk7XG4gICAgICogaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICogICB2YXIgc3ByaXRlID0gbmV3IEtvbnZhLlNwcml0ZSh7XG4gICAgICogICAgIHg6IDIwMCxcbiAgICAgKiAgICAgeTogMTAwLFxuICAgICAqICAgICBpbWFnZTogaW1hZ2VPYmosXG4gICAgICogICAgIGFuaW1hdGlvbjogJ3N0YW5kaW5nJyxcbiAgICAgKiAgICAgYW5pbWF0aW9uczoge1xuICAgICAqICAgICAgIHN0YW5kaW5nOiBbXG4gICAgICogICAgICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcbiAgICAgKiAgICAgICAgIDAsIDAsIDQ5LCAxMDksXG4gICAgICogICAgICAgICA1MiwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDEwNSwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDE1OCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDIxMCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDI2MiwgMCwgNDksIDEwOVxuICAgICAqICAgICAgIF0sXG4gICAgICogICAgICAga2lja2luZzogW1xuICAgICAqICAgICAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodCAoNiBmcmFtZXMpXG4gICAgICogICAgICAgICAwLCAxMDksIDQ1LCA5OCxcbiAgICAgKiAgICAgICAgIDQ1LCAxMDksIDQ1LCA5OCxcbiAgICAgKiAgICAgICAgIDk1LCAxMDksIDYzLCA5OCxcbiAgICAgKiAgICAgICAgIDE1NiwgMTA5LCA3MCwgOTgsXG4gICAgICogICAgICAgICAyMjksIDEwOSwgNjAsIDk4LFxuICAgICAqICAgICAgICAgMjg3LCAxMDksIDQxLCA5OFxuICAgICAqICAgICAgIF1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgZnJhbWVSYXRlOiA3LFxuICAgICAqICAgICBmcmFtZUluZGV4OiAwXG4gICAgICogICB9KTtcbiAgICAgKiB9O1xuICAgICAqIGltYWdlT2JqLnNyYyA9ICcvcGF0aC90by9pbWFnZS5qcGcnXG4gICAgICovXG4gICAgS29udmEuU3ByaXRlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5TcHJpdGUucHJvdG90eXBlID0ge1xuICAgICAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1Nwcml0ZSc7XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5hbmltID0gbmV3IEtvbnZhLkFuaW1hdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCBuZWVkIHRvIHJlZHJhdyBsYXllciB3ZSBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWQgPSB0aGF0Ll91cGRhdGVkO1xuICAgICAgICAgICAgICAgIHRoYXQuX3VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vbignYW5pbWF0aW9uQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgaW5kZXggd2hlbiBhbmltYXRpb24gY2hhbmdlc1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVJbmRleCgwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vbignZnJhbWVJbmRleENoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBzbW9vdGggY2hhbmdlIGZvciBmcmFtZVJhdGVcbiAgICAgICAgICAgIHRoaXMub24oJ2ZyYW1lUmF0ZUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hbmltLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgICAgICB0aGlzLmhpdEZ1bmModGhpcy5faGl0RnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBhbmltID0gdGhpcy5nZXRBbmltYXRpb24oKSxcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuZnJhbWVJbmRleCgpLFxuICAgICAgICAgICAgICAgIGl4NCA9IGluZGV4ICogNCxcbiAgICAgICAgICAgICAgICBzZXQgPSB0aGlzLmdldEFuaW1hdGlvbnMoKVthbmltXSxcbiAgICAgICAgICAgICAgICBvZmZzZXRzID0gdGhpcy5mcmFtZU9mZnNldHMoKSxcbiAgICAgICAgICAgICAgICB4ID0gc2V0W2l4NCArIDBdLFxuICAgICAgICAgICAgICAgIHkgPSBzZXRbaXg0ICsgMV0sXG4gICAgICAgICAgICAgICAgd2lkdGggPSBzZXRbaXg0ICsgMl0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2V0W2l4NCArIDNdLFxuICAgICAgICAgICAgICAgIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGaWxsKCkgfHwgdGhpcy5oYXNTdHJva2UoKSkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbYW5pbV0sXG4gICAgICAgICAgICAgICAgICAgIGl4MiA9IGluZGV4ICogMjtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQsIG9mZnNldFtpeDIgKyAwXSwgb2Zmc2V0W2l4MiArIDFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfaGl0RnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGFuaW0gPSB0aGlzLmdldEFuaW1hdGlvbigpLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5mcmFtZUluZGV4KCksXG4gICAgICAgICAgICAgICAgaXg0ID0gaW5kZXggKiA0LFxuICAgICAgICAgICAgICAgIHNldCA9IHRoaXMuZ2V0QW5pbWF0aW9ucygpW2FuaW1dLFxuICAgICAgICAgICAgICAgIG9mZnNldHMgPSB0aGlzLmZyYW1lT2Zmc2V0cygpLFxuICAgICAgICAgICAgICAgIHdpZHRoID0gc2V0W2l4NCArIDJdLFxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHNldFtpeDQgKyAzXTtcblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChvZmZzZXRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG9mZnNldHNbYW5pbV07XG4gICAgICAgICAgICAgICAgdmFyIGl4MiA9IGluZGV4ICogMjtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3Qob2Zmc2V0W2l4MiArIDBdLCBvZmZzZXRbaXgyICsgMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5maWxsU2hhcGUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIF91c2VCdWZmZXJDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmhhc1NoYWRvdygpIHx8IHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDEpICYmIHRoaXMuaGFzU3Ryb2tlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zZXRJbnRlcnZhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fdXBkYXRlSW5kZXgoKTtcbiAgICAgICAgICAgIH0sIDEwMDAgLyB0aGlzLmdldEZyYW1lUmF0ZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0YXJ0IHNwcml0ZSBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogYW5pbWF0aW9uIG9iamVjdCBoYXMgbm8gZXhlY3V0YWJsZSBmdW5jdGlvbiBiZWNhdXNlXG4gICAgICAgICAgICAgKiAgdGhlIHVwZGF0ZXMgYXJlIGRvbmUgd2l0aCBhIGZpeGVkIEZQUyB3aXRoIHRoZSBzZXRJbnRlcnZhbFxuICAgICAgICAgICAgICogIGJlbG93LiAgVGhlIGFuaW0gb2JqZWN0IG9ubHkgbmVlZHMgdGhlIGxheWVyIHJlZmVyZW5jZSBmb3JcbiAgICAgICAgICAgICAqICByZWRyYXdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5hbmltLnNldExheWVycyhsYXllcik7XG4gICAgICAgICAgICB0aGlzLl9zZXRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgdGhpcy5hbmltLnN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzdG9wIHNwcml0ZSBhbmltYXRpb25cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW0uc3RvcCgpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRldGVybWluZSBpZiBhbmltYXRpb24gb2Ygc3ByaXRlIGlzIHJ1bm5pbmcgb3Igbm90LiAgcmV0dXJucyB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc1J1bm5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbS5pc1J1bm5pbmcoKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3VwZGF0ZUluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZnJhbWVJbmRleCgpLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbiA9IHRoaXMuZ2V0QW5pbWF0aW9uKCksXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucyA9IHRoaXMuZ2V0QW5pbWF0aW9ucygpLFxuICAgICAgICAgICAgICAgIGFuaW0gPSBhbmltYXRpb25zW2FuaW1hdGlvbl0sXG4gICAgICAgICAgICAgICAgbGVuID0gYW5pbS5sZW5ndGggLyA0O1xuXG4gICAgICAgICAgICBpZihpbmRleCA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lSW5kZXgoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVJbmRleCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU3ByaXRlLCBLb252YS5TaGFwZSk7XG5cbiAgICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnYW5pbWF0aW9uJyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGFuaW1hdGlvbiBrZXlcbiAgICAgKiBAbmFtZSBhbmltYXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYW5pbSBhbmltYXRpb24ga2V5XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBhbmltYXRpb24ga2V5XG4gICAgICogdmFyIGFuaW1hdGlvbiA9IHNwcml0ZS5hbmltYXRpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBhbmltYXRpb24ga2V5XG4gICAgICogc3ByaXRlLmFuaW1hdGlvbigna2lja2luZycpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnYW5pbWF0aW9ucycpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBhbmltYXRpb25zIG1hcFxuICAgICAqIEBuYW1lIGFuaW1hdGlvbnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYW5pbWF0aW9uc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgYW5pbWF0aW9ucyBtYXBcbiAgICAgKiB2YXIgYW5pbWF0aW9ucyA9IHNwcml0ZS5hbmltYXRpb25zKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgYW5pbWF0aW9ucyBtYXBcbiAgICAgKiBzcHJpdGUuYW5pbWF0aW9ucyh7XG4gICAgICogICBzdGFuZGluZzogW1xuICAgICAqICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcbiAgICAgKiAgICAgMCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgNTIsIDAsIDQ5LCAxMDksXG4gICAgICogICAgIDEwNSwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgMTU4LCAwLCA0OSwgMTA5LFxuICAgICAqICAgICAyMTAsIDAsIDQ5LCAxMDksXG4gICAgICogICAgIDI2MiwgMCwgNDksIDEwOVxuICAgICAqICAgXSxcbiAgICAgKiAgIGtpY2tpbmc6IFtcbiAgICAgKiAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodCAoNiBmcmFtZXMpXG4gICAgICogICAgIDAsIDEwOSwgNDUsIDk4LFxuICAgICAqICAgICA0NSwgMTA5LCA0NSwgOTgsXG4gICAgICogICAgIDk1LCAxMDksIDYzLCA5OCxcbiAgICAgKiAgICAgMTU2LCAxMDksIDcwLCA5OCxcbiAgICAgKiAgICAgMjI5LCAxMDksIDYwLCA5OCxcbiAgICAgKiAgICAgMjg3LCAxMDksIDQxLCA5OFxuICAgICAqICAgXVxuICAgICAqIH0pO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnZnJhbWVPZmZzZXRzJyk7XG5cbiAgICAvKipcbiAgICAqIGdldC9zZXQgb2Zmc2V0cyBtYXBcbiAgICAqIEBuYW1lIG9mZnNldHNcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0c1xuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqIEBleGFtcGxlXG4gICAgKiAvLyBnZXQgb2Zmc2V0cyBtYXBcbiAgICAqIHZhciBvZmZzZXRzID0gc3ByaXRlLm9mZnNldHMoKTtcbiAgICAqXG4gICAgKiAvLyBzZXQgb2Zmc2V0cyBtYXBcbiAgICAqIHNwcml0ZS5vZmZzZXRzKHtcbiAgICAqICAgc3RhbmRpbmc6IFtcbiAgICAqICAgICAvLyB4LCB5ICg2IGZyYW1lcylcbiAgICAqICAgICAwLCAwLFxuICAgICogICAgIDAsIDAsXG4gICAgKiAgICAgNSwgMCxcbiAgICAqICAgICAwLCAwLFxuICAgICogICAgIDAsIDMsXG4gICAgKiAgICAgMiwgMFxuICAgICogICBdLFxuICAgICogICBraWNraW5nOiBbXG4gICAgKiAgICAgLy8geCwgeSAoNiBmcmFtZXMpXG4gICAgKiAgICAgMCwgNSxcbiAgICAqICAgICA1LCAwLFxuICAgICogICAgIDEwLCAwLFxuICAgICogICAgIDAsIDAsXG4gICAgKiAgICAgMiwgMSxcbiAgICAqICAgICAwLCAwXG4gICAgKiAgIF1cbiAgICAqIH0pO1xuICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdpbWFnZScpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBpbWFnZVxuICAgICAqIEBuYW1lIGltYWdlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2V9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaW1hZ2VcbiAgICAgKiB2YXIgaW1hZ2UgPSBzcHJpdGUuaW1hZ2UoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBpbWFnZVxuICAgICAqIHNwcml0ZS5pbWFnZShpbWFnZU9iaik7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdmcmFtZUluZGV4JywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQvc2V0IGFuaW1hdGlvbiBmcmFtZSBpbmRleFxuICAgICAqIEBuYW1lIGZyYW1lSW5kZXhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGZyYW1lSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBhbmltYXRpb24gZnJhbWUgaW5kZXhcbiAgICAgKiB2YXIgZnJhbWVJbmRleCA9IHNwcml0ZS5mcmFtZUluZGV4KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgYW5pbWF0aW9uIGZyYW1lIGluZGV4XG4gICAgICogc3ByaXRlLmZyYW1lSW5kZXgoMyk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdmcmFtZVJhdGUnLCAxNyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IGZyYW1lIHJhdGUgaW4gZnJhbWVzIHBlciBzZWNvbmQuICBJbmNyZWFzZSB0aGlzIG51bWJlciB0byBtYWtlIHRoZSBzcHJpdGVcbiAgICAgKiAgYW5pbWF0aW9uIHJ1biBmYXN0ZXIsIGFuZCBkZWNyZWFzZSB0aGUgbnVtYmVyIHRvIG1ha2UgdGhlIHNwcml0ZSBhbmltYXRpb24gcnVuIHNsb3dlclxuICAgICAqICBUaGUgZGVmYXVsdCBpcyAxNyBmcmFtZXMgcGVyIHNlY29uZFxuICAgICAqIEBuYW1lIGZyYW1lUmF0ZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZnJhbWVSYXRlXG4gICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgZnJhbWUgcmF0ZVxuICAgICAqIHZhciBmcmFtZVJhdGUgPSBzcHJpdGUuZnJhbWVSYXRlKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgZnJhbWUgcmF0ZSB0byAyIGZyYW1lcyBwZXIgc2Vjb25kXG4gICAgICogc3ByaXRlLmZyYW1lUmF0ZSgyKTtcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYmFja0NvbXBhdChLb252YS5TcHJpdGUsIHtcbiAgICAgICAgaW5kZXg6ICdmcmFtZUluZGV4JyxcbiAgICAgICAgZ2V0SW5kZXg6ICdnZXRGcmFtZUluZGV4JyxcbiAgICAgICAgc2V0SW5kZXg6ICdzZXRGcmFtZUluZGV4J1xuICAgIH0pO1xuXG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlNwcml0ZSk7XG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlICBuby1zaGFkb3csIG1heC1sZW4sIG1heC1kZXB0aCAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogUGF0aCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAYXV0aG9yIEphc29uIEZvbGxhc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRhdGEgU1ZHIGRhdGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwYXRoID0gbmV3IEtvbnZhLlBhdGgoe1xuICAgICAqICAgeDogMjQwLFxuICAgICAqICAgeTogNDAsXG4gICAgICogICBkYXRhOiAnTTEyLjU4Miw5LjU1MUMzLjI1MSwxNi4yMzcsMC45MjEsMjkuMDIxLDcuMDgsMzguNTY0bC0yLjM2LDEuNjg5bDQuODkzLDIuMjYybDQuODkzLDIuMjYybC0wLjU2OC01LjM2bC0wLjU2Ny01LjM1OWwtMi4zNjUsMS42OTRjLTQuNjU3LTcuMzc1LTIuODMtMTcuMTg1LDQuMzUyLTIyLjMzYzcuNDUxLTUuMzM4LDE3LjgxNy0zLjYyNSwyMy4xNTYsMy44MjRjNS4zMzcsNy40NDksMy42MjUsMTcuODEzLTMuODIxLDIzLjE1MmwyLjg1NywzLjk4OGM5LjYxNy02Ljg5MywxMS44MjctMjAuMjc3LDQuOTM1LTI5Ljg5NkMzNS41OTEsNC44NywyMi4yMDQsMi42NTgsMTIuNTgyLDkuNTUxeicsXG4gICAgICogICBmaWxsOiAnZ3JlZW4nLFxuICAgICAqICAgc2NhbGU6IDJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5QYXRoID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuUGF0aC5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1BhdGgnO1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFBcnJheSA9IEtvbnZhLlBhdGgucGFyc2VQYXRoRGF0YSh0aGlzLmdldERhdGEoKSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdkYXRhQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuZGF0YUFycmF5ID0gS29udmEuUGF0aC5wYXJzZVBhdGhEYXRhKHRoaXMuZ2V0RGF0YSgpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY2EgPSB0aGlzLmRhdGFBcnJheTtcblxuICAgICAgICAgICAgLy8gY29udGV4dCBwb3NpdGlvblxuICAgICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY2EubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGNhW25dLmNvbW1hbmQ7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBjYVtuXS5wb2ludHM7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocFswXSwgcFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdLCBwWzRdLCBwWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IHBbMF0sIGN5ID0gcFsxXSwgcnggPSBwWzJdLCByeSA9IHBbM10sIHRoZXRhID0gcFs0XSwgZFRoZXRhID0gcFs1XSwgcHNpID0gcFs2XSwgZnMgPSBwWzddO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IChyeCA+IHJ5KSA/IHJ4IDogcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVYID0gKHJ4ID4gcnkpID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVZID0gKHJ4ID4gcnkpID8gcnkgLyByeCA6IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIDEgLSBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLmRhdGFBcnJheS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KGRhdGEucG9pbnRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG1pblggPSBwb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgbWF4WCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciBtaW5ZID0gcG9pbnRzWzFdO1xuICAgICAgICAgICAgdmFyIG1heFkgPSBwb2ludHNbMV07XG4gICAgICAgICAgICB2YXIgeCwgeTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIHggPSBwb2ludHNbaSAqIDJdOyB5ID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgICAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICAgICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKG1pblgpLFxuICAgICAgICAgICAgICAgIHk6IE1hdGgucm91bmQobWluWSksXG4gICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQobWF4WCAtIG1pblgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChtYXhZIC0gbWluWSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlBhdGgsIEtvbnZhLlNoYXBlKTtcblxuICAgIEtvbnZhLlBhdGguZ2V0TGluZUxlbmd0aCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgICB9O1xuICAgIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkxpbmUgPSBmdW5jdGlvbihkaXN0LCBQMXgsIFAxeSwgUDJ4LCBQMnksIGZyb21YLCBmcm9tWSkge1xuICAgICAgICBpZihmcm9tWCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmcm9tWCA9IFAxeDtcbiAgICAgICAgfVxuICAgICAgICBpZihmcm9tWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmcm9tWSA9IFAxeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtID0gKFAyeSAtIFAxeSkgLyAoKFAyeCAtIFAxeCkgKyAwLjAwMDAwMDAxKTtcbiAgICAgICAgdmFyIHJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAvICgxICsgbSAqIG0pKTtcbiAgICAgICAgaWYoUDJ4IDwgUDF4KSB7XG4gICAgICAgICAgICBydW4gKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpc2UgPSBtICogcnVuO1xuICAgICAgICB2YXIgcHQ7XG5cbiAgICAgICAgaWYgKFAyeCA9PT0gUDF4KSB7IC8vIHZlcnRpY2FsIGxpbmVcbiAgICAgICAgICAgIHB0ID0ge1xuICAgICAgICAgICAgICAgIHg6IGZyb21YLFxuICAgICAgICAgICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmKChmcm9tWSAtIFAxeSkgLyAoKGZyb21YIC0gUDF4KSArIDAuMDAwMDAwMDEpID09PSBtKSB7XG4gICAgICAgICAgICBwdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBmcm9tWCArIHJ1bixcbiAgICAgICAgICAgICAgICB5OiBmcm9tWSArIHJpc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXgsIGl5O1xuXG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5nZXRMaW5lTGVuZ3RoKFAxeCwgUDF5LCBQMngsIFAyeSk7XG4gICAgICAgICAgICBpZihsZW4gPCAwLjAwMDAwMDAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1ID0gKCgoZnJvbVggLSBQMXgpICogKFAyeCAtIFAxeCkpICsgKChmcm9tWSAtIFAxeSkgKiAoUDJ5IC0gUDF5KSkpO1xuICAgICAgICAgICAgdSA9IHUgLyAobGVuICogbGVuKTtcbiAgICAgICAgICAgIGl4ID0gUDF4ICsgdSAqIChQMnggLSBQMXgpO1xuICAgICAgICAgICAgaXkgPSBQMXkgKyB1ICogKFAyeSAtIFAxeSk7XG5cbiAgICAgICAgICAgIHZhciBwUmlzZSA9IHRoaXMuZ2V0TGluZUxlbmd0aChmcm9tWCwgZnJvbVksIGl4LCBpeSk7XG4gICAgICAgICAgICB2YXIgcFJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAtIHBSaXNlICogcFJpc2UpO1xuICAgICAgICAgICAgcnVuID0gTWF0aC5zcXJ0KHBSdW4gKiBwUnVuIC8gKDEgKyBtICogbSkpO1xuICAgICAgICAgICAgaWYoUDJ4IDwgUDF4KSB7XG4gICAgICAgICAgICAgICAgcnVuICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmlzZSA9IG0gKiBydW47XG4gICAgICAgICAgICBwdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBpeCArIHJ1bixcbiAgICAgICAgICAgICAgICB5OiBpeSArIHJpc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHQ7XG4gICAgfTtcblxuICAgIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyID0gZnVuY3Rpb24ocGN0LCBQMXgsIFAxeSwgUDJ4LCBQMnksIFAzeCwgUDN5LCBQNHgsIFA0eSkge1xuICAgICAgICBmdW5jdGlvbiBDQjEodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBDQjIodCkge1xuICAgICAgICAgICAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gQ0IzKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIENCNCh0KSB7XG4gICAgICAgICAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gUDR4ICogQ0IxKHBjdCkgKyBQM3ggKiBDQjIocGN0KSArIFAyeCAqIENCMyhwY3QpICsgUDF4ICogQ0I0KHBjdCk7XG4gICAgICAgIHZhciB5ID0gUDR5ICogQ0IxKHBjdCkgKyBQM3kgKiBDQjIocGN0KSArIFAyeSAqIENCMyhwY3QpICsgUDF5ICogQ0I0KHBjdCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBLb252YS5QYXRoLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbihwY3QsIFAxeCwgUDF5LCBQMngsIFAyeSwgUDN4LCBQM3kpIHtcbiAgICAgICAgZnVuY3Rpb24gUUIxKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ICogdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBRQjIodCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKiB0ICogKDEgLSB0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBRQjModCkge1xuICAgICAgICAgICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gUDN4ICogUUIxKHBjdCkgKyBQMnggKiBRQjIocGN0KSArIFAxeCAqIFFCMyhwY3QpO1xuICAgICAgICB2YXIgeSA9IFAzeSAqIFFCMShwY3QpICsgUDJ5ICogUUIyKHBjdCkgKyBQMXkgKiBRQjMocGN0KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMgPSBmdW5jdGlvbihjeCwgY3ksIHJ4LCByeSwgdGhldGEsIHBzaSkge1xuICAgICAgICB2YXIgY29zUHNpID0gTWF0aC5jb3MocHNpKSwgc2luUHNpID0gTWF0aC5zaW4ocHNpKTtcbiAgICAgICAgdmFyIHB0ID0ge1xuICAgICAgICAgICAgeDogcnggKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgICB5OiByeSAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY3ggKyAocHQueCAqIGNvc1BzaSAtIHB0LnkgKiBzaW5Qc2kpLFxuICAgICAgICAgICAgeTogY3kgKyAocHQueCAqIHNpblBzaSArIHB0LnkgKiBjb3NQc2kpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKlxuICAgICAqIGdldCBwYXJzZWQgZGF0YSBhcnJheSBmcm9tIHRoZSBkYXRhXG4gICAgICogIHN0cmluZy4gIFYsIHYsIEgsIGgsIGFuZCBsIGRhdGEgYXJlIGNvbnZlcnRlZCB0b1xuICAgICAqICBMIGRhdGEgZm9yIHRoZSBwdXJwb3NlIG9mIGhpZ2ggcGVyZm9ybWFuY2UgUGF0aFxuICAgICAqICByZW5kZXJpbmdcbiAgICAgKi9cbiAgICBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8vIFBhdGggRGF0YSBTZWdtZW50IG11c3QgYmVnaW4gd2l0aCBhIG1vdmVUb1xuICAgICAgICAvL20gKHggeSkrICBSZWxhdGl2ZSBtb3ZlVG8gKHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIGxpbmVUbylcbiAgICAgICAgLy9NICh4IHkpKyAgQWJzb2x1dGUgbW92ZVRvIChzdWJzZXF1ZW50IHBvaW50cyBhcmUgdHJlYXRlZCBhcyBsaW5lVG8pXG4gICAgICAgIC8vbCAoeCB5KSsgIFJlbGF0aXZlIGxpbmVUb1xuICAgICAgICAvL0wgKHggeSkrICBBYnNvbHV0ZSBMaW5lVG9cbiAgICAgICAgLy9oICh4KSsgICAgUmVsYXRpdmUgaG9yaXpvbnRhbCBsaW5lVG9cbiAgICAgICAgLy9IICh4KSsgICAgQWJzb2x1dGUgaG9yaXpvbnRhbCBsaW5lVG9cbiAgICAgICAgLy92ICh5KSsgICAgUmVsYXRpdmUgdmVydGljYWwgbGluZVRvXG4gICAgICAgIC8vViAoeSkrICAgIEFic29sdXRlIHZlcnRpY2FsIGxpbmVUb1xuICAgICAgICAvL3ogKGNsb3NlcGF0aClcbiAgICAgICAgLy9aIChjbG9zZXBhdGgpXG4gICAgICAgIC8vYyAoeDEgeTEgeDIgeTIgeCB5KSsgUmVsYXRpdmUgQmV6aWVyIGN1cnZlXG4gICAgICAgIC8vQyAoeDEgeTEgeDIgeTIgeCB5KSsgQWJzb2x1dGUgQmV6aWVyIGN1cnZlXG4gICAgICAgIC8vcSAoeDEgeTEgeCB5KSsgICAgICAgUmVsYXRpdmUgUXVhZHJhdGljIEJlemllclxuICAgICAgICAvL1EgKHgxIHkxIHggeSkrICAgICAgIEFic29sdXRlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAgICAgLy90ICh4IHkpKyAgICBTaG9ydGhhbmQvU21vb3RoIFJlbGF0aXZlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAgICAgLy9UICh4IHkpKyAgICBTaG9ydGhhbmQvU21vb3RoIEFic29sdXRlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAgICAgLy9zICh4MiB5MiB4IHkpKyAgICAgICBTaG9ydGhhbmQvU21vb3RoIFJlbGF0aXZlIEJlemllciBjdXJ2ZVxuICAgICAgICAvL1MgKHgyIHkyIHggeSkrICAgICAgIFNob3J0aGFuZC9TbW9vdGggQWJzb2x1dGUgQmV6aWVyIGN1cnZlXG4gICAgICAgIC8vYSAocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSsgICAgIFJlbGF0aXZlIEVsbGlwdGljYWwgQXJjXG4gICAgICAgIC8vQSAocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSsgIEFic29sdXRlIEVsbGlwdGljYWwgQXJjXG5cbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IGlmIGRhdGEgaXMgbm90IGRlZmluZWRcbiAgICAgICAgaWYoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbW1hbmQgc3RyaW5nXG4gICAgICAgIHZhciBjcyA9IGRhdGE7XG5cbiAgICAgICAgLy8gY29tbWFuZCBjaGFyc1xuICAgICAgICB2YXIgY2MgPSBbJ20nLCAnTScsICdsJywgJ0wnLCAndicsICdWJywgJ2gnLCAnSCcsICd6JywgJ1onLCAnYycsICdDJywgJ3EnLCAnUScsICd0JywgJ1QnLCAncycsICdTJywgJ2EnLCAnQSddO1xuICAgICAgICAvLyBjb252ZXJ0IHdoaXRlIHNwYWNlcyB0byBjb21tYXNcbiAgICAgICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoJyAnLCAnZycpLCAnLCcpO1xuICAgICAgICAvLyBjcmVhdGUgcGlwZXMgc28gdGhhdCB3ZSBjYW4gc3BsaXQgdGhlIGRhdGFcbiAgICAgICAgZm9yKHZhciBuID0gMDsgbiA8IGNjLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBjcyA9IGNzLnJlcGxhY2UobmV3IFJlZ0V4cChjY1tuXSwgJ2cnKSwgJ3wnICsgY2Nbbl0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBhcnJheVxuICAgICAgICB2YXIgYXJyID0gY3Muc3BsaXQoJ3wnKTtcbiAgICAgICAgdmFyIGNhID0gW107XG4gICAgICAgIC8vIGluaXQgY29udGV4dCBwb2ludFxuICAgICAgICB2YXIgY3B4ID0gMDtcbiAgICAgICAgdmFyIGNweSA9IDA7XG4gICAgICAgIGZvciggbiA9IDE7IG4gPCBhcnIubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBhcnJbbl07XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoMCk7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgLC0gZm9yIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCcsLScsICdnJyksICctJyk7XG4gICAgICAgICAgICAvLyBhZGQgY29tbWFzIHNvIHRoYXQgaXQncyBlYXN5IHRvIHNwbGl0XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCctJywgJ2cnKSwgJywtJyk7XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCdlLC0nLCAnZycpLCAnZS0nKTtcbiAgICAgICAgICAgIHZhciBwID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBpZihwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHN0cmluZ3MgdG8gZmxvYXRzXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUocC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYoaXNOYU4ocFswXSkpIHsvLyBjYXNlIGZvciBhIHRyYWlsaW5nIGNvbW1hIGJlZm9yZSBuZXh0IGNvbW1hbmRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFggPSBjcHgsIHN0YXJ0WSA9IGNweTtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHZhciBmcm9tIHdpdGhpbiB0aGUgc3dpdGNoIHRvIHVwIGhlcmUgKGpzaGludClcbiAgICAgICAgICAgICAgICB2YXIgcHJldkNtZCwgY3RsUHR4LCBjdGxQdHk7ICAgICAvLyBTcywgVHRcbiAgICAgICAgICAgICAgICB2YXIgcngsIHJ5LCBwc2ksIGZhLCBmcywgeDEsIHkxOyAvLyBBYVxuXG5cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBLZWVwIHRoZSBsaW5lVG8ncyBhYm92ZSB0aGUgbW92ZVRvJ3MgaW4gdGhpcyBzd2l0Y2hcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IGxpbmVUbyBoYW5kbGVycyBuZWVkIHRvIGJlIGFib3ZlIHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnTSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciBjbG9zaW5nIHRoZSBwYXRoIG1vdmUgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIHBhdGggKGlmIGFueSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYS5sZW5ndGggPiAyICYmIGNhW2NhLmxlbmd0aCAtIDFdLmNvbW1hbmQgPT09ICd6Jyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpZHggPSBjYS5sZW5ndGggLSAyOyBpZHggPj0gMDsgaWR4LS0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYVtpZHhdLmNvbW1hbmQgPT09ICdNJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBjYVtpZHhdLnBvaW50c1swXSArIGR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gY2FbaWR4XS5wb2ludHNbMV0gKyBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIHJlbGF0aXZlIGxpbmVUb1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ00nO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIGFic29sdXRlIGxpbmVUb1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHAuc2hpZnQoKSwgcC5zaGlmdCgpLCBwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSwgY3B4ICsgcC5zaGlmdCgpLCBjcHkgKyBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcmV2Q21kLmNvbW1hbmQgPT09ICdDJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcmV2Q21kLmNvbW1hbmQgPT09ICdDJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdDJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHAuc2hpZnQoKSwgcC5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCArIHAuc2hpZnQoKSwgY3B5ICsgcC5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gJ1EnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJldkNtZC5jb21tYW5kID09PSAnUScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnUSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJldkNtZC5jb21tYW5kID09PSAnUScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHggKyAoY3B4IC0gcHJldkNtZC5wb2ludHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9ICdRJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSB0aGlzLmNvbnZlcnRFbmRwb2ludFRvQ2VudGVyUGFyYW1ldGVyaXphdGlvbih4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwc2kgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IGNweTsgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSAnQSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSB0aGlzLmNvbnZlcnRFbmRwb2ludFRvQ2VudGVyUGFyYW1ldGVyaXphdGlvbih4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBjbWQgfHwgYyxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBzdGFydFlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aExlbmd0aDogdGhpcy5jYWxjTGVuZ3RoKHN0YXJ0WCwgc3RhcnRZLCBjbWQgfHwgYywgcG9pbnRzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihjID09PSAneicgfHwgYyA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgY2EucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICd6JyxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aExlbmd0aDogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhO1xuICAgIH07XG4gICAgS29udmEuUGF0aC5jYWxjTGVuZ3RoID0gZnVuY3Rpb24oeCwgeSwgY21kLCBwb2ludHMpIHtcbiAgICAgICAgdmFyIGxlbiwgcDEsIHAyLCB0O1xuICAgICAgICB2YXIgcGF0aCA9IEtvbnZhLlBhdGg7XG5cbiAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmdldExpbmVMZW5ndGgoeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgICAgICAgICAgcDEgPSBwYXRoLmdldFBvaW50T25DdWJpY0JlemllcigwLCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICAgICAgICAgICAgICBmb3IoIHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xuICAgICAgICAgICAgICAgICAgICBwMiA9IHBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyKHQsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgICAgICAgICAgcDEgPSBwYXRoLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoMCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgICBmb3IoIHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xuICAgICAgICAgICAgICAgICAgICBwMiA9IHBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllcih0LCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gbGluZSBzZWdtZW50c1xuICAgICAgICAgICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBwb2ludHNbNF07XG4gICAgICAgICAgICAgICAgLy8gNCA9IHRoZXRhXG4gICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IHBvaW50c1s1XTtcbiAgICAgICAgICAgICAgICAvLyA1ID0gZFRoZXRhXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgICAgICAgICB2YXIgaW5jID0gTWF0aC5QSSAvIDE4MC4wO1xuICAgICAgICAgICAgICAgIC8vIDEgZGVncmVlIHJlc29sdXRpb25cbiAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhzdGFydCAtIGVuZCkgPCBpbmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBmb3IgcHVycG9zZSBvZiBjYWxjdWxhdGluZyBhcmMgbGVuZ3RoLCBub3QgZ29pbmcgdG8gd29ycnkgYWJvdXQgcm90YXRpbmcgWC1heGlzIGJ5IGFuZ2xlIHBzaVxuICAgICAgICAgICAgICAgIHAxID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHN0YXJ0LCAwKTtcbiAgICAgICAgICAgICAgICBpZihkVGhldGEgPCAwKSB7Ly8gY2xvY2t3aXNlXG4gICAgICAgICAgICAgICAgICAgIGZvciggdCA9IHN0YXJ0IC0gaW5jOyB0ID4gZW5kOyB0IC09IGluYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgdCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsvLyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgICAgICAgICAgICAgICAgICBmb3IoIHQgPSBzdGFydCArIGluYzsgdCA8IGVuZDsgdCArPSBpbmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgZW5kLCAwKTtcbiAgICAgICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgS29udmEuUGF0aC5jb252ZXJ0RW5kcG9pbnRUb0NlbnRlclBhcmFtZXRlcml6YXRpb24gPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgZmEsIGZzLCByeCwgcnksIHBzaURlZykge1xuICAgICAgICAvLyBEZXJpdmVkIGZyb206IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbiAgICAgICAgdmFyIHBzaSA9IHBzaURlZyAqIChNYXRoLlBJIC8gMTgwLjApO1xuICAgICAgICB2YXIgeHAgPSBNYXRoLmNvcyhwc2kpICogKHgxIC0geDIpIC8gMi4wICsgTWF0aC5zaW4ocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgICAgICAgdmFyIHlwID0gLTEgKiBNYXRoLnNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgTWF0aC5jb3MocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcblxuICAgICAgICB2YXIgbGFtYmRhID0gKHhwICogeHApIC8gKHJ4ICogcngpICsgKHlwICogeXApIC8gKHJ5ICogcnkpO1xuXG4gICAgICAgIGlmKGxhbWJkYSA+IDEpIHtcbiAgICAgICAgICAgIHJ4ICo9IE1hdGguc3FydChsYW1iZGEpO1xuICAgICAgICAgICAgcnkgKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IE1hdGguc3FydCgoKChyeCAqIHJ4KSAqIChyeSAqIHJ5KSkgLSAoKHJ4ICogcngpICogKHlwICogeXApKSAtICgocnkgKiByeSkgKiAoeHAgKiB4cCkpKSAvICgocnggKiByeCkgKiAoeXAgKiB5cCkgKyAocnkgKiByeSkgKiAoeHAgKiB4cCkpKTtcblxuICAgICAgICBpZihmYSA9PT0gZnMpIHtcbiAgICAgICAgICAgIGYgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaXNOYU4oZikpIHtcbiAgICAgICAgICAgIGYgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN4cCA9IGYgKiByeCAqIHlwIC8gcnk7XG4gICAgICAgIHZhciBjeXAgPSBmICogLXJ5ICogeHAgLyByeDtcblxuICAgICAgICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjAgKyBNYXRoLmNvcyhwc2kpICogY3hwIC0gTWF0aC5zaW4ocHNpKSAqIGN5cDtcbiAgICAgICAgdmFyIGN5ID0gKHkxICsgeTIpIC8gMi4wICsgTWF0aC5zaW4ocHNpKSAqIGN4cCArIE1hdGguY29zKHBzaSkgKiBjeXA7XG5cbiAgICAgICAgdmFyIHZNYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdlJhdGlvID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgICAgICAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdKSAvICh2TWFnKHUpICogdk1hZyh2KSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2QW5nbGUgPSBmdW5jdGlvbih1LCB2KSB7XG4gICAgICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHZSYXRpbyh1LCB2KSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGV0YSA9IHZBbmdsZShbMSwgMF0sIFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV0pO1xuICAgICAgICB2YXIgdSA9IFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV07XG4gICAgICAgIHZhciB2ID0gWygtMSAqIHhwIC0gY3hwKSAvIHJ4LCAoLTEgKiB5cCAtIGN5cCkgLyByeV07XG4gICAgICAgIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG5cbiAgICAgICAgaWYodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGlmKHZSYXRpbyh1LCB2KSA+PSAxKSB7XG4gICAgICAgICAgICBkVGhldGEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSAtIDIgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGlmKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3gsIGN5LCByeCwgcnksIHRoZXRhLCBkVGhldGEsIHBzaSwgZnNdO1xuICAgIH07XG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlBhdGgsICdkYXRhJyk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgU1ZHIHBhdGggZGF0YSBzdHJpbmcuICBUaGlzIG1ldGhvZFxuICAgICAqICBhbHNvIGF1dG9tYXRpY2FsbHkgcGFyc2VzIHRoZSBkYXRhIHN0cmluZ1xuICAgICAqICBpbnRvIGEgZGF0YSBhcnJheS4gIEN1cnJlbnRseSBzdXBwb3J0ZWQgU1ZHIGRhdGE6XG4gICAgICogIE0sIG0sIEwsIGwsIEgsIGgsIFYsIHYsIFEsIHEsIFQsIHQsIEMsIGMsIFMsIHMsIEEsIGEsIFosIHpcbiAgICAgKiBAbmFtZSBzZXREYXRhXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5QYXRoLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBTVkcgcGF0aCBjb21tYW5kIHN0cmluZ1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogZ2V0IFNWRyBwYXRoIGRhdGEgc3RyaW5nXG4gICAgICogQG5hbWUgZ2V0RGF0YVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUGF0aC5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5QYXRoKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIEVNUFRZX1NUUklORyA9ICcnLFxuICAgICAgICAvL0NBTElCUkkgPSAnQ2FsaWJyaScsXG4gICAgICAgIE5PUk1BTCA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogUGF0aCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAYXV0aG9yIEphc29uIEZvbGxhc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250RmFtaWx5XSBkZWZhdWx0IGlzIENhbGlicmlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5mb250U2l6ZV0gZGVmYXVsdCBpcyAxMlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRTdHlsZV0gY2FuIGJlIG5vcm1hbCwgYm9sZCwgb3IgaXRhbGljLiAgRGVmYXVsdCBpcyBub3JtYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250VmFyaWFudF0gY2FuIGJlIG5vcm1hbCBvciBzbWFsbC1jYXBzLiAgRGVmYXVsdCBpcyBub3JtYWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnRleHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRhdGEgU1ZHIGRhdGEgc3RyaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciB0ZXh0cGF0aCA9IG5ldyBLb252YS5UZXh0UGF0aCh7XG4gICAgICogICB4OiAxMDAsXG4gICAgICogICB5OiA1MCxcbiAgICAgKiAgIGZpbGw6ICcjMzMzJyxcbiAgICAgKiAgIGZvbnRTaXplOiAnMjQnLFxuICAgICAqICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgKiAgIHRleHQ6ICdBbGwgdGhlIHdvcmxkXFwncyBhIHN0YWdlLCBhbmQgYWxsIHRoZSBtZW4gYW5kIHdvbWVuIG1lcmVseSBwbGF5ZXJzLicsXG4gICAgICogICBkYXRhOiAnTTEwLDEwIEMwLDAgMTAsMTUwIDEwMCwxMDAgUzMwMCwxNTAgNDAwLDUwJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIEtvbnZhLlRleHRQYXRoID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMucGFydGlhbFRleHQsIDAsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc3Ryb2tlRnVuYyhjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0aGlzLnBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICB9XG5cbiAgICBLb252YS5UZXh0UGF0aC5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5kdW1teUNhbnZhcyA9IEtvbnZhLlV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhQXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuXG4gICAgICAgICAgICAvLyBvdmVycmlkZXNcbiAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZG4ndCB0aGlzIGJlIG9uIHRoZSBwcm90b3R5cGU/XG4gICAgICAgICAgICB0aGlzLl9maWxsRnVuYyA9IF9maWxsRnVuYztcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZUZ1bmMgPSBfc3Ryb2tlRnVuYztcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxGdW5jSGl0ID0gX2ZpbGxGdW5jO1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlRnVuY0hpdCA9IF9zdHJva2VGdW5jO1xuXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdUZXh0UGF0aCc7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YUFycmF5ID0gS29udmEuUGF0aC5wYXJzZVBhdGhEYXRhKHRoaXMuYXR0cnMuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdkYXRhQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5hdHRycy5kYXRhKTtcbiAgICAgICAgICAgICAgICB0aGF0Ll9zZXRUZXh0RGF0YSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0ZXh0IGRhdGEgZm9yIGNlcnRhaW4gYXR0ciBjaGFuZ2VzXG4gICAgICAgICAgICB0aGlzLm9uKCd0ZXh0Q2hhbmdlLmtvbnZhIGxldHRlclNwYWNpbmdDaGFuZ2Uua29udmEnLCB0aGF0Ll9zZXRUZXh0RGF0YSk7XG4gICAgICAgICAgICB0aGF0Ll9zZXRUZXh0RGF0YSgpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgICAgIHRoaXMuaGl0RnVuYyh0aGlzLl9oaXRGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyKCdmb250JywgdGhpcy5fZ2V0Q29udGV4dEZvbnQoKSk7XG4gICAgICAgICAgICBjb250ZXh0LnNldEF0dHIodGhpcy5nZXRUZXh0QmFzZWxpbmUoKSwgJ21pZGRsZScpO1xuICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyKCd0ZXh0QWxpZ24nLCAnbGVmdCcpO1xuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgICAgIHZhciBnbHlwaEluZm8gPSB0aGlzLmdseXBoSW5mbztcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBnbHlwaEluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIHZhciBwMCA9IGdseXBoSW5mb1tpXS5wMDtcblxuICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHAwLngsIHAwLnkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQucm90YXRlKGdseXBoSW5mb1tpXS5yb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsVGV4dCA9IGdseXBoSW5mb1tpXS50ZXh0O1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgICAgICAvLy8vIFRvIGFzc2lzdCB3aXRoIGRlYnVnZ2luZyB2aXN1YWxseSwgdW5jb21tZW50IGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgKGkgJSAyKVxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnY3lhbic7XG4gICAgICAgICAgICAgICAgLy8gZWxzZVxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgICAgICAgICAgIC8vIHZhciBwMSA9IGdseXBoSW5mb1tpXS5wMTtcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LmxpbmVUbyhwMS54LCBwMS55KTtcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9oaXRGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgIHZhciBnbHlwaEluZm8gPSB0aGlzLmdseXBoSW5mbztcbiAgICAgICAgICBpZiAoZ2x5cGhJbmZvLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICB2YXIgcDAgPSBnbHlwaEluZm9bMF0ucDA7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGdseXBoSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgcDEgPSBnbHlwaEluZm9baV0ucDE7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHAxLngsIHAxLnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0LnNldEF0dHIoJ2xpbmVXaWR0aCcsIHRoaXMuZ2V0Rm9udFNpemUoKSk7XG4gICAgICAgICAgY29udGV4dC5zZXRBdHRyKCdzdHJva2VTdHlsZScsIHRoaXMuY29sb3JLZXkpO1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGV4dCB3aWR0aCBpbiBwaXhlbHNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dFdpZHRoO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IHRleHQgaGVpZ2h0IGluIHBpeGVsc1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dEhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCB0ZXh0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgS29udmEuVGV4dC5wcm90b3R5cGUuc2V0VGV4dC5jYWxsKHRoaXMsIHRleHQpO1xuICAgICAgICB9LFxuICAgICAgICBfZ2V0VGV4dFNpemU6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHZhciBkdW1teUNhbnZhcyA9IHRoaXMuZHVtbXlDYW52YXM7XG4gICAgICAgICAgICB2YXIgX2NvbnRleHQgPSBkdW1teUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICBfY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgICAgIF9jb250ZXh0LmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xuICAgICAgICAgICAgdmFyIG1ldHJpY3MgPSBfY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcblxuICAgICAgICAgICAgX2NvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBtZXRyaWNzLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQodGhpcy5hdHRycy5mb250U2l6ZSwgMTApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBfc2V0VGV4dERhdGE6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX2dldFRleHRTaXplKHRoaXMuYXR0cnMudGV4dCk7XG4gICAgICAgICAgICB2YXIgbGV0dGVyU3BhY2luZyA9IHRoaXMuZ2V0TGV0dGVyU3BhY2luZygpO1xuXG4gICAgICAgICAgICB0aGlzLnRleHRXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSBzaXplLmhlaWdodDtcblxuICAgICAgICAgICAgdGhpcy5nbHlwaEluZm8gPSBbXTtcblxuICAgICAgICAgICAgdmFyIGNoYXJBcnIgPSB0aGlzLmdldFRleHQoKS5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgIHZhciBwMCwgcDEsIHBhdGhDbWQ7XG5cbiAgICAgICAgICAgIHZhciBwSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBnZXROZXh0UGF0aFNlZ21lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gdGhhdC5kYXRhQXJyYXk7XG5cbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSBwSW5kZXggKyAxOyBqIDwgcGF0aERhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYocGF0aERhdGFbal0ucGF0aExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBJbmRleCA9IGo7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoRGF0YVtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHBhdGhEYXRhW2pdLmNvbW1hbmQgPT09ICdNJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcDAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogcGF0aERhdGFbal0ucG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHBhdGhEYXRhW2pdLnBvaW50c1sxXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZmluZFNlZ21lbnRUb0ZpdENoYXJhY3RlciA9IGZ1bmN0aW9uKGMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBnbHlwaFdpZHRoID0gdGhhdC5fZ2V0VGV4dFNpemUoYykud2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJMZW4gPSAwO1xuICAgICAgICAgICAgICAgIHZhciBhdHRlbXB0cyA9IDA7XG5cbiAgICAgICAgICAgICAgICBwMSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB3aGlsZShNYXRoLmFicyhnbHlwaFdpZHRoIC0gY3VyckxlbikgLyBnbHlwaFdpZHRoID4gMC4wMSAmJiBhdHRlbXB0cyA8IDI1KSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzKys7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdW11bGF0aXZlUGF0aExlbmd0aCA9IGN1cnJMZW47XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHBhdGhDbWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aENtZCA9IGdldE5leHRQYXRoU2VnbWVudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwYXRoQ21kICYmIGN1bXVsYXRpdmVQYXRoTGVuZ3RoICsgcGF0aENtZC5wYXRoTGVuZ3RoIDwgZ2x5cGhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1bXVsYXRpdmVQYXRoTGVuZ3RoICs9IHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoQ21kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocGF0aENtZCA9PT0ge30gfHwgcDAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZWVkTmV3U2VnbWVudCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aENtZC5jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihLb252YS5QYXRoLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcGF0aENtZC5wb2ludHNbMF0sIHBhdGhDbWQucG9pbnRzWzFdKSA+IGdseXBoV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBLb252YS5QYXRoLmdldFBvaW50T25MaW5lKGdseXBoV2lkdGgsIHAwLngsIHAwLnksIHBhdGhDbWQucG9pbnRzWzBdLCBwYXRoQ21kLnBvaW50c1sxXSwgcDAueCwgcDAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoQ21kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcGF0aENtZC5wb2ludHNbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNCA9IHRoZXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRUaGV0YSA9IHBhdGhDbWQucG9pbnRzWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDUgPSBkVGhldGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gcGF0aENtZC5wb2ludHNbNF0gKyBkVGhldGE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VCA9PT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gc3RhcnQgKyAwLjAwMDAwMDAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGluIGNhc2Ugc3RhcnQgaXMgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZ2x5cGhXaWR0aCA+IGN1cnJMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgKz0gKE1hdGguUEkgLyAxODAuMCkgKiBkVGhldGEgLyBNYXRoLmFicyhkVGhldGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgLT0gTWF0aC5QSSAvIDM2MC4wICogZFRoZXRhIC8gTWF0aC5hYnMoZFRoZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVkaXQgZm9yIGJ1ZyBmaXg6IEB0aGVydGggaHR0cHM6Ly9naXRodWIuY29tL2VyaWNkcm93ZWxsL0tvbnZhSlMvaXNzdWVzLzI0OVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9sZCBjb2RlIGZhaWxlZCB0byByZW5kZXIgdGV4dCBhbG9uZyBhcmMgb2YgdGhpcyBwYXRoOiBcIk0gNTAgNTAgYSAxNTAgNTAgMCAwIDEgMjUwIDUwIGwgNTAgMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZFRoZXRhIDwgMCAmJiBjdXJyZW50VCA8IGVuZCB8fCBkVGhldGEgPj0gMCAmJiBjdXJyZW50VCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMSA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocGF0aENtZC5wb2ludHNbMF0sIHBhdGhDbWQucG9pbnRzWzFdLCBwYXRoQ21kLnBvaW50c1syXSwgcGF0aENtZC5wb2ludHNbM10sIGN1cnJlbnRULCBwYXRoQ21kLnBvaW50c1s2XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihnbHlwaFdpZHRoID4gcGF0aENtZC5wYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDAuMDAwMDAwMDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGdseXBoV2lkdGggLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnbHlwaFdpZHRoID4gY3Vyckxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCArPSAoZ2x5cGhXaWR0aCAtIGN1cnJMZW4pIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgLT0gKGN1cnJMZW4gLSBnbHlwaFdpZHRoKSAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VCA+IDEuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMSA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyKGN1cnJlbnRULCBwYXRoQ21kLnN0YXJ0LngsIHBhdGhDbWQuc3RhcnQueSwgcGF0aENtZC5wb2ludHNbMF0sIHBhdGhDbWQucG9pbnRzWzFdLCBwYXRoQ21kLnBvaW50c1syXSwgcGF0aENtZC5wb2ludHNbM10sIHBhdGhDbWQucG9pbnRzWzRdLCBwYXRoQ21kLnBvaW50c1s1XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJyZW50VCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGdseXBoV2lkdGggLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZ2x5cGhXaWR0aCA+IGN1cnJMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgKz0gKGdseXBoV2lkdGggLSBjdXJyTGVuKSAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUIC09IChjdXJyTGVuIC0gZ2x5cGhXaWR0aCkgLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudFQgPiAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWROZXdTZWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBLb252YS5QYXRoLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoY3VycmVudFQsIHBhdGhDbWQuc3RhcnQueCwgcGF0aENtZC5zdGFydC55LCBwYXRoQ21kLnBvaW50c1swXSwgcGF0aENtZC5wb2ludHNbMV0sIHBhdGhDbWQucG9pbnRzWzJdLCBwYXRoQ21kLnBvaW50c1szXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHAxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJMZW4gPSBLb252YS5QYXRoLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcDEueCwgcDEueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihuZWVkTmV3U2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhDbWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNoYXJBcnIubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgcDEgc3VjaCB0aGF0IGxpbmUgc2VnbWVudCBiZXR3ZWVuIHAwIGFuZCBwMSBpcyBhcHByb3guIHdpZHRoIG9mIGdseXBoXG4gICAgICAgICAgICAgICAgZmluZFNlZ21lbnRUb0ZpdENoYXJhY3RlcihjaGFyQXJyW2ldKTtcblxuICAgICAgICAgICAgICAgIGlmKHAwID09PSB1bmRlZmluZWQgfHwgcDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBLb252YS5QYXRoLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcDEueCwgcDEueSk7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBTaW5jZSBnbHlwaHMgYXJlIHJlbmRlcmVkIG9uZSBhdCBhIHRpbWUsIGFueSBrZXJuaW5nIHBhaXIgZGF0YSBidWlsdCBpbnRvIHRoZSBmb250IHdpbGwgbm90IGJlIHVzZWQuXG4gICAgICAgICAgICAgICAgLy8gQ2FuIGZvcmVzZWUgaGF2aW5nIGEgcm91Z2ggcGFpciB0YWJsZSBidWlsdCBpbiB0aGF0IHRoZSBkZXZlbG9wZXIgY2FuIG92ZXJyaWRlIGFzIG5lZWRlZC5cblxuICAgICAgICAgICAgICAgIHZhciBrZXJuID0gMDtcbiAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlciBmb3IgZnV0dXJlIGltcGxlbWVudGF0aW9uXG5cbiAgICAgICAgICAgICAgICB2YXIgbWlkcG9pbnQgPSBLb252YS5QYXRoLmdldFBvaW50T25MaW5lKGtlcm4gKyB3aWR0aCAvIDIuMCwgcDAueCwgcDAueSwgcDEueCwgcDEueSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSBNYXRoLmF0YW4yKChwMS55IC0gcDAueSksIChwMS54IC0gcDAueCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2x5cGhJbmZvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3Bvc2VYOiBtaWRwb2ludC54LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3Bvc2VZOiBtaWRwb2ludC55LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGFyQXJyW2ldLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHAwOiBwMCxcbiAgICAgICAgICAgICAgICAgICAgcDE6IHAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcDAgPSBwMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmdseXBoSW5mby5mb3JFYWNoKGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChpbmZvLnAwLngpO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGluZm8ucDAueSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goaW5mby5wMS54KTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChpbmZvLnAxLnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWluWCA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xuICAgICAgICAgICAgdmFyIG1pblkgPSBwb2ludHNbMF07XG4gICAgICAgICAgICB2YXIgbWF4WSA9IHBvaW50c1swXTtcbiAgICAgICAgICAgIHZhciB4LCB5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBvaW50c1tpICogMl07IHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQobWluWCkgLSBmb250U2l6ZSxcbiAgICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKG1pblkpIC0gZm9udFNpemUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQobWF4WCAtIG1pblgpICsgZm9udFNpemUgKiAyLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChtYXhZIC0gbWluWSkgKyBmb250U2l6ZSAqIDJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbWFwIFRleHRQYXRoIG1ldGhvZHMgdG8gVGV4dFxuICAgIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZS5fZ2V0Q29udGV4dEZvbnQgPSBLb252YS5UZXh0LnByb3RvdHlwZS5fZ2V0Q29udGV4dEZvbnQ7XG5cbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5UZXh0UGF0aCwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIHNldHRlcnMgYW5kIGdldHRlcnNcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2ZvbnRGYW1pbHknLCAnQXJpYWwnKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBmb250IGZhbWlseVxuICAgICAqIEBuYW1lIHNldEZvbnRGYW1pbHlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250RmFtaWx5XG4gICAgICovXG5cbiAgICAgLyoqXG4gICAgICogZ2V0IGZvbnQgZmFtaWx5XG4gICAgICogQG5hbWUgZ2V0Rm9udEZhbWlseVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2ZvbnRTaXplJywgMTIpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGZvbnQgc2l6ZVxuICAgICAqIEBuYW1lIHNldEZvbnRTaXplXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge2ludH0gZm9udFNpemVcbiAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgZm9udCBzaXplXG4gICAgICogQG5hbWUgZ2V0Rm9udFNpemVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdmb250U3R5bGUnLCBOT1JNQUwpO1xuXG4gICAgLyoqXG4gICAgICogc2V0IGZvbnQgc3R5bGUuICBDYW4gYmUgJ25vcm1hbCcsICdpdGFsaWMnLCBvciAnYm9sZCcuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cbiAgICAgKiBAbmFtZSBzZXRGb250U3R5bGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb250U3R5bGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHRQYXRoLCAnbGV0dGVyU3BhY2luZycsIDApO1xuXG4gICAgIC8qKlxuICAgICAgKiBzZXQgbGV0dGVyIHNwYWNpbmcgcHJvcGVydHkuIERlZmF1bHQgdmFsdWUgaXMgMC5cbiAgICAgICogQG5hbWUgbGV0dGVyU3BhY2luZ1xuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldHRlclNwYWNpbmdcbiAgICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ3RleHRCYXNlbGluZScsICdtaWRkbGUnKTtcblxuICAgICAvKipcbiAgICAgICogc2V0IHRleHRCYXNlbGluZSBwcm9wZXJ0eS4gRGVmYXVsdCB2YWx1ZSBpcyAnbWlkZGxlJy5cbiAgICAgICogQ2FuIGJlICd0b3AnLCAnYm90dG9tJywgJ21pZGRsZScsICdhbHBoYWJldGljJywgJ2hhbmdpbmcnXG4gICAgICAqIEBuYW1lIHRleHRCYXNlbGluZVxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHRleHRCYXNlbGluZVxuICAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgZm9udCBzdHlsZVxuICAgICAqIEBuYW1lIGdldEZvbnRTdHlsZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2ZvbnRWYXJpYW50JywgTk9STUFMKTtcblxuXG5cbiAgICAvKipcbiAgICAgKiBzZXQgZm9udCB2YXJpYW50LiAgQ2FuIGJlICdub3JtYWwnIG9yICdzbWFsbC1jYXBzJy4gICdub3JtYWwnIGlzIHRoZSBkZWZhdWx0LlxuICAgICAqIEBuYW1lIHNldEZvbnRWYXJpYW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udFZhcmlhbnRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBnZXQgZm9udCB2YXJpYW50XG4gICAgICogQG5hbWUgZ2V0Rm9udFZhcmlhbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuVGV4dFBhdGgsICd0ZXh0JywgRU1QVFlfU1RSSU5HKTtcblxuICAgIC8qKlxuICAgICAqIGdldCB0ZXh0XG4gICAgICogQG5hbWUgZ2V0VGV4dFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVGV4dFBhdGgpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiBSZWd1bGFyUG9seWdvbiBjb25zdHJ1Y3Rvci4mbmJzcDsgRXhhbXBsZXMgaW5jbHVkZSB0cmlhbmdsZXMsIHNxdWFyZXMsIHBlbnRhZ29ucywgaGV4YWdvbnMsIGV0Yy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5zaWRlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcucmFkaXVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBoZXhhZ29uID0gbmV3IEtvbnZhLlJlZ3VsYXJQb2x5Z29uKHtcbiAgICAgKiAgIHg6IDEwMCxcbiAgICAgKiAgIHk6IDIwMCxcbiAgICAgKiAgIHNpZGVzOiA2LFxuICAgICAqICAgcmFkaXVzOiA3MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAqICAgc3Ryb2tlV2lkdGg6IDRcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBLb252YS5SZWd1bGFyUG9seWdvbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlID0ge1xuICAgICAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUmVndWxhclBvbHlnb24nO1xuICAgICAgICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHNpZGVzID0gdGhpcy5hdHRycy5zaWRlcyxcbiAgICAgICAgICAgICAgICByYWRpdXMgPSB0aGlzLmF0dHJzLnJhZGl1cyxcbiAgICAgICAgICAgICAgICBuLCB4LCB5O1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgMCAtIHJhZGl1cyk7XG5cbiAgICAgICAgICAgIGZvcihuID0gMTsgbiA8IHNpZGVzOyBuKyspIHtcbiAgICAgICAgICAgICAgICB4ID0gcmFkaXVzICogTWF0aC5zaW4obiAqIDIgKiBNYXRoLlBJIC8gc2lkZXMpO1xuICAgICAgICAgICAgICAgIHkgPSAtMSAqIHJhZGl1cyAqIE1hdGguY29zKG4gKiAyICogTWF0aC5QSSAvIHNpZGVzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRIZWlnaHQoKVxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXG4gICAgICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYWRpdXMod2lkdGggLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5SZWd1bGFyUG9seWdvbiwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlJlZ3VsYXJQb2x5Z29uLCAncmFkaXVzJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgcmFkaXVzXG4gICAgICogQG5hbWUgc2V0UmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5SZWd1bGFyUG9seWdvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICovXG5cbiAgICAgLyoqXG4gICAgICogZ2V0IHJhZGl1c1xuICAgICAqIEBuYW1lIGdldFJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5SZWd1bGFyUG9seWdvbiwgJ3NpZGVzJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgbnVtYmVyIG9mIHNpZGVzXG4gICAgICogQG5hbWUgc2V0U2lkZXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7aW50fSBzaWRlc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogZ2V0IG51bWJlciBvZiBzaWRlc1xuICAgICAqIEBuYW1lIGdldFNpZGVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5SZWd1bGFyUG9seWdvbi5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5SZWd1bGFyUG9seWdvbik7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8qKlxuICAgICAqIFN0YXIgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBjb25maWcubnVtUG9pbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5pbm5lclJhZGl1c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcub3V0ZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHN0YXIgPSBuZXcgS29udmEuU3Rhcih7XG4gICAgICogICB4OiAxMDAsXG4gICAgICogICB5OiAyMDAsXG4gICAgICogICBudW1Qb2ludHM6IDUsXG4gICAgICogICBpbm5lclJhZGl1czogNzAsXG4gICAgICogICBvdXRlclJhZGl1czogNzAsXG4gICAgICogICBmaWxsOiAncmVkJyxcbiAgICAgKiAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICAgKiAgIHN0cm9rZVdpZHRoOiA0XG4gICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuU3RhciA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgICB9O1xuXG4gICAgS29udmEuU3Rhci5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9jZW50cm9pZDogdHJ1ZSxcbiAgICAgICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICdTdGFyJztcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBpbm5lclJhZGl1cyA9IHRoaXMuaW5uZXJSYWRpdXMoKSxcbiAgICAgICAgICAgICAgICBvdXRlclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMoKSxcbiAgICAgICAgICAgICAgICBudW1Qb2ludHMgPSB0aGlzLm51bVBvaW50cygpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgMCAtIG91dGVyUmFkaXVzKTtcblxuICAgICAgICAgICAgZm9yKHZhciBuID0gMTsgbiA8IG51bVBvaW50cyAqIDI7IG4rKykge1xuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBuICUgMiA9PT0gMCA/IG91dGVyUmFkaXVzIDogaW5uZXJSYWRpdXM7XG4gICAgICAgICAgICAgICAgdmFyIHggPSByYWRpdXMgKiBNYXRoLnNpbihuICogTWF0aC5QSSAvIG51bVBvaW50cyk7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSAtMSAqIHJhZGl1cyAqIE1hdGguY29zKG4gKiBNYXRoLlBJIC8gbnVtUG9pbnRzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRIZWlnaHQoKVxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICAgICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dGVyUmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICAgICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRlclJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPdXRlclJhZGl1cyhoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU3RhciwgS29udmEuU2hhcGUpO1xuXG4gICAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICAgIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlN0YXIsICdudW1Qb2ludHMnLCA1KTtcblxuICAgIC8qKlxuICAgICAqIHNldCBudW1iZXIgb2YgcG9pbnRzXG4gICAgICogQG5hbWUgc2V0TnVtUG9pbnRzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gcG9pbnRzXG4gICAgICovXG5cbiAgICAgLyoqXG4gICAgICogZ2V0IG51bWJlciBvZiBwb2ludHNcbiAgICAgKiBAbmFtZSBnZXROdW1Qb2ludHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TdGFyLCAnaW5uZXJSYWRpdXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBpbm5lciByYWRpdXNcbiAgICAgKiBAbmFtZSBzZXRJbm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3Rhci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICovXG5cbiAgICAgLyoqXG4gICAgICogZ2V0IGlubmVyIHJhZGl1c1xuICAgICAqIEBuYW1lIGdldElubmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3RhciwgJ291dGVyUmFkaXVzJywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogQG5hbWUgc2V0T3V0ZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAqIGdldCBvdXRlciByYWRpdXNcbiAgICAgKiBAbmFtZSBnZXRPdXRlclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3Rhci5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5TdGFyKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gY29uc3RhbnRzXG4gICAgdmFyIEFUVFJfQ0hBTkdFX0xJU1QgPSBbJ2ZvbnRGYW1pbHknLCAnZm9udFNpemUnLCAnZm9udFN0eWxlJywgJ3BhZGRpbmcnLCAnbGluZUhlaWdodCcsICd0ZXh0J10sXG4gICAgICAgIENIQU5HRV9LT05WQSA9ICdDaGFuZ2Uua29udmEnLFxuICAgICAgICBOT05FID0gJ25vbmUnLFxuICAgICAgICBVUCA9ICd1cCcsXG4gICAgICAgIFJJR0hUID0gJ3JpZ2h0JyxcbiAgICAgICAgRE9XTiA9ICdkb3duJyxcbiAgICAgICAgTEVGVCA9ICdsZWZ0JyxcbiAgICAgICAgTEFCRUwgPSAnTGFiZWwnLFxuXG4gICAgIC8vIGNhY2hlZCB2YXJpYWJsZXNcbiAgICAgYXR0ckNoYW5nZUxpc3RMZW4gPSBBVFRSX0NIQU5HRV9MSVNULmxlbmd0aDtcblxuICAgIC8qKlxuICAgICAqIExhYmVsIGNvbnN0cnVjdG9yLiZuYnNwOyBMYWJlbHMgYXJlIGdyb3VwcyB0aGF0IGNvbnRhaW4gYSBUZXh0IGFuZCBUYWcgc2hhcGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGNyZWF0ZSBsYWJlbFxuICAgICAqIHZhciBsYWJlbCA9IG5ldyBLb252YS5MYWJlbCh7XG4gICAgICogICB4OiAxMDAsXG4gICAgICogICB5OiAxMDAsXG4gICAgICogICBkcmFnZ2FibGU6IHRydWVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGFkZCBhIHRhZyB0byB0aGUgbGFiZWxcbiAgICAgKiBsYWJlbC5hZGQobmV3IEtvbnZhLlRhZyh7XG4gICAgICogICBmaWxsOiAnI2JiYicsXG4gICAgICogICBzdHJva2U6ICcjMzMzJyxcbiAgICAgKiAgIHNoYWRvd0NvbG9yOiAnYmxhY2snLFxuICAgICAqICAgc2hhZG93Qmx1cjogMTAsXG4gICAgICogICBzaGFkb3dPZmZzZXQ6IFsxMCwgMTBdLFxuICAgICAqICAgc2hhZG93T3BhY2l0eTogMC4yLFxuICAgICAqICAgbGluZUpvaW46ICdyb3VuZCcsXG4gICAgICogICBwb2ludGVyRGlyZWN0aW9uOiAndXAnLFxuICAgICAqICAgcG9pbnRlcldpZHRoOiAyMCxcbiAgICAgKiAgIHBvaW50ZXJIZWlnaHQ6IDIwLFxuICAgICAqICAgY29ybmVyUmFkaXVzOiA1XG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gYWRkIHRleHQgdG8gdGhlIGxhYmVsXG4gICAgICogbGFiZWwuYWRkKG5ldyBLb252YS5UZXh0KHtcbiAgICAgKiAgIHRleHQ6ICdIZWxsbyBXb3JsZCEnLFxuICAgICAqICAgZm9udFNpemU6IDUwLFxuICAgICAqICAgbGluZUhlaWdodDogMS4yLFxuICAgICAqICAgcGFkZGluZzogMTAsXG4gICAgICogICBmaWxsOiAnZ3JlZW4nXG4gICAgICogIH0pKTtcbiAgICAgKi9cbiAgICBLb252YS5MYWJlbCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB0aGlzLl9fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLkxhYmVsLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX19fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICBLb252YS5Hcm91cC5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IExBQkVMO1xuXG4gICAgICAgICAgICB0aGlzLm9uKCdhZGQua29udmEnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9hZGRMaXN0ZW5lcnMoZXZ0LmNoaWxkKTtcbiAgICAgICAgICAgICAgICB0aGF0Ll9zeW5jKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldCBUZXh0IHNoYXBlIGZvciB0aGUgbGFiZWwuICBZb3UgbmVlZCB0byBhY2Nlc3MgdGhlIFRleHQgc2hhcGUgaW4gb3JkZXIgdG8gdXBkYXRlXG4gICAgICAgICAqIHRoZSB0ZXh0IHByb3BlcnRpZXNcbiAgICAgICAgICogQG5hbWUgZ2V0VGV4dFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYWJlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZCgnVGV4dCcpWzBdO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IFRhZyBzaGFwZSBmb3IgdGhlIGxhYmVsLiAgWW91IG5lZWQgdG8gYWNjZXNzIHRoZSBUYWcgc2hhcGUgaW4gb3JkZXIgdG8gdXBkYXRlXG4gICAgICAgICAqIHRoZSBwb2ludGVyIHByb3BlcnRpZXMgYW5kIHRoZSBjb3JuZXIgcmFkaXVzXG4gICAgICAgICAqIEBuYW1lIGdldFRhZ1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYWJlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFRhZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kKCdUYWcnKVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgX2FkZExpc3RlbmVyczogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIG47XG4gICAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX3N5bmMoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGV4dCBkYXRhIGZvciBjZXJ0YWluIGF0dHIgY2hhbmdlc1xuICAgICAgICAgICAgZm9yKG4gPSAwOyBuIDwgYXR0ckNoYW5nZUxpc3RMZW47IG4rKykge1xuICAgICAgICAgICAgICAgIHRleHQub24oQVRUUl9DSEFOR0VfTElTVFtuXSArIENIQU5HRV9LT05WQSwgZnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRleHQoKS5nZXRXaWR0aCgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dCgpLmdldEhlaWdodCgpO1xuICAgICAgICB9LFxuICAgICAgICBfc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dCgpLFxuICAgICAgICAgICAgICAgIHRhZyA9IHRoaXMuZ2V0VGFnKCksXG4gICAgICAgICAgICAgICAgd2lkdGgsIGhlaWdodCwgcG9pbnRlckRpcmVjdGlvbiwgcG9pbnRlcldpZHRoLCB4LCB5LCBwb2ludGVySGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAodGV4dCAmJiB0YWcpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHRleHQuZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0ZXh0LmdldEhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJEaXJlY3Rpb24gPSB0YWcuZ2V0UG9pbnRlckRpcmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJXaWR0aCA9IHRhZy5nZXRQb2ludGVyV2lkdGgoKTtcbiAgICAgICAgICAgICAgICBwb2ludGVySGVpZ2h0ID0gdGFnLmdldFBvaW50ZXJIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgICAgICB5ID0gMDtcblxuICAgICAgICAgICAgICAgIHN3aXRjaChwb2ludGVyRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVVA6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IC0xICogcG9pbnRlckhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFJJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHdpZHRoICsgcG9pbnRlcldpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBET1dOOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBoZWlnaHQgKyBwb2ludGVySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSAtMSAqIHBvaW50ZXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFnLnNldEF0dHJzKHtcbiAgICAgICAgICAgICAgICAgICAgeDogLTEgKiB4LFxuICAgICAgICAgICAgICAgICAgICB5OiAtMSAqIHksXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRleHQuc2V0QXR0cnMoe1xuICAgICAgICAgICAgICAgICAgICB4OiAtMSAqIHgsXG4gICAgICAgICAgICAgICAgICAgIHk6IC0xICogeVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkxhYmVsLCBLb252YS5Hcm91cCk7XG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuTGFiZWwpO1xuXG4gICAgLyoqXG4gICAgICogVGFnIGNvbnN0cnVjdG9yLiZuYnNwOyBBIFRhZyBjYW4gYmUgY29uZmlndXJlZFxuICAgICAqICB0byBoYXZlIGEgcG9pbnRlciBlbGVtZW50IHRoYXQgcG9pbnRzIHVwLCByaWdodCwgZG93biwgb3IgbGVmdFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5wb2ludGVyRGlyZWN0aW9uXSBjYW4gYmUgdXAsIHJpZ2h0LCBkb3duLCBsZWZ0LCBvciBub25lOyB0aGUgZGVmYXVsdFxuICAgICAqICBpcyBub25lLiAgV2hlbiBhIHBvaW50ZXIgaXMgcHJlc2VudCwgdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBsYWJlbCBpcyByZWxhdGl2ZSB0byB0aGUgdGlwIG9mIHRoZSBwb2ludGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnBvaW50ZXJXaWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wb2ludGVySGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNvcm5lclJhZGl1c11cbiAgICAgKi9cbiAgICBLb252YS5UYWcgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gICAgfTtcblxuICAgIEtvbnZhLlRhZy5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnVGFnJztcbiAgICAgICAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICAgIH0sXG4gICAgICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJEaXJlY3Rpb24gPSB0aGlzLmdldFBvaW50ZXJEaXJlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBwb2ludGVyV2lkdGggPSB0aGlzLmdldFBvaW50ZXJXaWR0aCgpLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJIZWlnaHQgPSB0aGlzLmdldFBvaW50ZXJIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICBjb3JuZXJSYWRpdXMgPSBNYXRoLm1pbih0aGlzLmdldENvcm5lclJhZGl1cygpLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgaWYgKCFjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oY29ybmVyUmFkaXVzLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvaW50ZXJEaXJlY3Rpb24gPT09IFVQKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oKHdpZHRoIC0gcG9pbnRlcldpZHRoKSAvIDIsIDApO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoIC8gMiwgLTEgKiBwb2ludGVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggKyBwb2ludGVyV2lkdGgpIC8gMiwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoIC0gY29ybmVyUmFkaXVzLCAwKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyh3aWR0aCAtIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIE1hdGguUEkgKiAzIC8gMiwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gUklHSFQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgKGhlaWdodCAtIHBvaW50ZXJIZWlnaHQpIC8gMik7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggKyBwb2ludGVyV2lkdGgsIGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCAoaGVpZ2h0ICsgcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIWNvcm5lclJhZGl1cykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0IC0gY29ybmVyUmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyh3aWR0aCAtIGNvcm5lclJhZGl1cywgaGVpZ2h0IC0gY29ybmVyUmFkaXVzLCBjb3JuZXJSYWRpdXMsIDAsIE1hdGguUEkgLyAyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb2ludGVyRGlyZWN0aW9uID09PSBET1dOKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oKHdpZHRoICsgcG9pbnRlcldpZHRoKSAvIDIsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggLyAyLCBoZWlnaHQgKyBwb2ludGVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggLSBwb2ludGVyV2lkdGgpIC8gMiwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIWNvcm5lclJhZGl1cykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIGhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNvcm5lclJhZGl1cywgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyhjb3JuZXJSYWRpdXMsIGhlaWdodCAtIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCBNYXRoLlBJIC8gMiwgTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gTEVGVCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDAsIChoZWlnaHQgKyBwb2ludGVySGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKC0xICogcG9pbnRlcldpZHRoLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAoaGVpZ2h0IC0gcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoY29ybmVyUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMCwgY29ybmVyUmFkaXVzKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyhjb3JuZXJSYWRpdXMsIGNvcm5lclJhZGl1cywgY29ybmVyUmFkaXVzLCBNYXRoLlBJLCBNYXRoLlBJICogMyAvIDIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgeCA9IDAsXG4gICAgICAgICAgICAgICAgeSA9IDAsXG4gICAgICAgICAgICAgICAgcG9pbnRlcldpZHRoID0gdGhpcy5nZXRQb2ludGVyV2lkdGgoKSxcbiAgICAgICAgICAgICAgICBwb2ludGVySGVpZ2h0ID0gdGhpcy5nZXRQb2ludGVySGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gdGhpcy5wb2ludGVyRGlyZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gVVApIHtcbiAgICAgICAgICAgICAgICB5IC09IHBvaW50ZXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ICs9IHBvaW50ZXJIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRE9XTikge1xuICAgICAgICAgICAgICAgIGhlaWdodCArPSBwb2ludGVySGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IExFRlQpIHtcbiAgICAgICAgICAgICAgICAvLyBBUkdIISEhIEkgaGF2ZSBubyBpZGVhIHdoeSBzaG91bGQgSSB1c2VkIG1hZ2ljIDEuNSEhISEhISEhIVxuICAgICAgICAgICAgICAgIHggLT0gcG9pbnRlcldpZHRoICogMS41O1xuICAgICAgICAgICAgICAgIHdpZHRoICs9IHBvaW50ZXJXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBSSUdIVCkge1xuICAgICAgICAgICAgICAgIHdpZHRoICs9IHBvaW50ZXJXaWR0aCAqIDEuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBLb252YS5VdGlsLmV4dGVuZChLb252YS5UYWcsIEtvbnZhLlNoYXBlKTtcbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UYWcsICdwb2ludGVyRGlyZWN0aW9uJywgTk9ORSk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgcG9pbnRlciBEaXJlY3Rpb25cbiAgICAgKiBAbmFtZSBzZXRQb2ludGVyRGlyZWN0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50ZXJEaXJlY3Rpb24gY2FuIGJlIHVwLCByaWdodCwgZG93biwgbGVmdCwgb3Igbm9uZS4gIFRoZVxuICAgICAqICBkZWZhdWx0IGlzIG5vbmVcbiAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgcG9pbnRlciBEaXJlY3Rpb25cbiAgICAgKiBAbmFtZSBnZXRQb2ludGVyRGlyZWN0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UYWcsICdwb2ludGVyV2lkdGgnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBwb2ludGVyIHdpZHRoXG4gICAgICogQG5hbWUgc2V0UG9pbnRlcldpZHRoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50ZXJXaWR0aFxuICAgICAqL1xuXG4gICAgIC8qKlxuICAgICAqIGdldCBwb2ludGVyIHdpZHRoXG4gICAgICogQG5hbWUgZ2V0UG9pbnRlcldpZHRoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UYWcsICdwb2ludGVySGVpZ2h0JywgMCk7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgcG9pbnRlciBoZWlnaHRcbiAgICAgKiBAbmFtZSBzZXRQb2ludGVySGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50ZXJIZWlnaHRcbiAgICAgKi9cblxuICAgICAvKipcbiAgICAgKiBnZXQgcG9pbnRlciBoZWlnaHRcbiAgICAgKiBAbmFtZSBnZXRQb2ludGVySGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UYWcsICdjb3JuZXJSYWRpdXMnLCAwKTtcblxuICAgIC8qKlxuICAgICAqIHNldCBjb3JuZXIgcmFkaXVzXG4gICAgICogQG5hbWUgc2V0Q29ybmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvcm5lciByYWRpdXNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIGdldCBjb3JuZXIgcmFkaXVzXG4gICAgICogQG5hbWUgZ2V0Q29ybmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVGFnKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLyoqXG4gICAgICogQXJyb3cgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29uZmlnLnBvaW50c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnRlbnNpb25dIEhpZ2hlciB2YWx1ZXMgd2lsbCByZXN1bHQgaW4gYSBtb3JlIGN1cnZ5IGxpbmUuICBBIHZhbHVlIG9mIDAgd2lsbCByZXN1bHQgaW4gbm8gaW50ZXJwb2xhdGlvbi5cbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIDBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnBvaW50ZXJMZW5ndGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnBvaW50ZXJXaWR0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgbGluZSA9IG5ldyBLb252YS5MaW5lKHtcbiAgICAgKiAgIHBvaW50czogWzczLCA3MCwgMzQwLCAyMywgNDUwLCA2MCwgNTAwLCAyMF0sXG4gICAgICogICBzdHJva2U6ICdyZWQnLFxuICAgICAqICAgdGVuc2lvbjogMSxcbiAgICAgKiAgIHBvaW50ZXJMZW5ndGggOiAxMCxcbiAgICAgKiAgIHBvaW50ZXJXaWR0aCA6IDEyXG4gICAgICogfSk7XG4gICAgICovXG4gICAgS29udmEuQXJyb3cgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX19faW5pdChjb25maWcpO1xuICAgIH07XG5cbiAgICBLb252YS5BcnJvdy5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9fX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgICAgIEtvbnZhLkxpbmUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQXJyb3cnO1xuICAgICAgICB9LFxuICAgICAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgIEtvbnZhLkxpbmUucHJvdG90eXBlLl9zY2VuZUZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cygpO1xuICAgICAgICAgICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGR4ID0gcG9pbnRzW24gLSAyXSAtIHBvaW50c1tuIC0gNF07XG4gICAgICAgICAgICB2YXIgZHkgPSBwb2ludHNbbiAtIDFdIC0gcG9pbnRzW24gLSAzXTtcbiAgICAgICAgICAgIHZhciByYWRpYW5zID0gKE1hdGguYXRhbjIoZHksIGR4KSArIFBJMikgJSBQSTI7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5wb2ludGVyTGVuZ3RoKCk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnBvaW50ZXJXaWR0aCgpO1xuXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShwb2ludHNbbiAtIDJdLCBwb2ludHNbbiAtIDFdKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocmFkaWFucyk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygtbGVuZ3RoLCB3aWR0aCAvIDIpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygtbGVuZ3RoLCAtd2lkdGggLyAyKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBvaW50ZXJBdEJlZ2lubmluZygpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgICAgICAgICBkeCA9IHBvaW50c1syXSAtIHBvaW50c1swXTtcbiAgICAgICAgICAgICAgICBkeSA9IHBvaW50c1szXSAtIHBvaW50c1sxXTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKChNYXRoLmF0YW4yKC1keSwgLWR4KSArIFBJMikgJSBQSTIpO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbygtbGVuZ3RoLCB3aWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgLXdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkFycm93LCBLb252YS5MaW5lKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHBvaW50ZXJMZW5ndGhcbiAgICAgKiBAbmFtZSBwb2ludGVyTGVuZ3RoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BcnJvdy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gTGVuZ3RoIG9mIHBvaW50ZXIgb2YgYXJyb3cuXG4gICAgICogICBUaGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHRlbnNpb25cbiAgICAgKiB2YXIgcG9pbnRlckxlbmd0aCA9IGxpbmUucG9pbnRlckxlbmd0aCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHRlbnNpb25cbiAgICAgKiBsaW5lLnBvaW50ZXJMZW5ndGgoMTUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJyb3csICdwb2ludGVyTGVuZ3RoJywgMTApO1xuICAgIC8qKlxuICAgICAqIGdldC9zZXQgcG9pbnRlcldpZHRoXG4gICAgICogQG5hbWUgcG9pbnRlcldpZHRoXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BcnJvdy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gV2lkdGggb2YgcG9pbnRlciBvZiBhcnJvdy5cbiAgICAgKiAgIFRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgdGVuc2lvblxuICAgICAqIHZhciBwb2ludGVyV2lkdGggPSBsaW5lLnBvaW50ZXJXaWR0aCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHRlbnNpb25cbiAgICAgKiBsaW5lLnBvaW50ZXJXaWR0aCgxNSk7XG4gICAgICovXG5cbiAgICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcnJvdywgJ3BvaW50ZXJXaWR0aCcsIDEwKTtcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHBvaW50ZXJBdEJlZ2lubmluZ1xuICAgICAqIEBuYW1lIHBvaW50ZXJBdEJlZ2lubmluZ1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJyb3cucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFNob3VsZCBwb2ludGVyIGRpc3BsYXllZCBhdCBiZWdpbm5pbmcgb2YgYXJyb3cuXG4gICAgICogICBUaGUgZGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCB0ZW5zaW9uXG4gICAgICogdmFyIHBvaW50ZXJBdEJlZ2lubmluZyA9IGxpbmUucG9pbnRlckF0QmVnaW5uaW5nKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgdGVuc2lvblxuICAgICAqIGxpbmUucG9pbnRlckF0QmVnaW5uaW5nKHRydWUpO1xuICAgICAqL1xuXG4gICAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJyb3csICdwb2ludGVyQXRCZWdpbm5pbmcnLCBmYWxzZSk7XG4gICAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkFycm93KTtcblxufSkoKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2tvbnZhL2tvbnZhLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogKGlnbm9yZWQpICovXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBjYW52YXMgKGlnbm9yZWQpXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogKGlnbm9yZWQpICovXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBqc2RvbSAoaWdub3JlZClcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgeyBDaXJjbGUgfSBmcm9tICdrb252YSc7XHJcbmltcG9ydCBXaXJlIGZyb20gJy4vV2lyZS5qcyc7XHJcblxyXG5jbGFzcyBJbnB1dCBleHRlbmRzIENpcmNsZSB7XHJcbiAgY29uc3RydWN0b3IoeCwgeSwgc3RhbmQpIHtcclxuICAgIHN1cGVyKHtcclxuICAgICAgeDogeCxcclxuICAgICAgeTogeSxcclxuICAgICAgcmFkaXVzOiA4LFxyXG4gICAgICBzdHJva2U6ICdibGFjaycsXHJcbiAgICAgIHN0cm9rZVdpZHRoOiAyLFxyXG4gICAgICBmaWxsOiAncmdiYSgxMiwxMiwxMiwwLjIpJ1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyogcGFyYW1ldGVycyAqL1xyXG4gICAgdGhpcy5zdGFuZCA9IHN0YW5kO1xyXG4gICAgdGhpcy54ID0gdGhpcy5hdHRycy54O1xyXG4gICAgdGhpcy55ID0gdGhpcy5hdHRycy55O1xyXG4gICAgdGhpcy5jb25uZWN0ZWRJbnB1dCA9IG51bGw7XHJcbiAgICB0aGlzLmNvbm5lY3RpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMudHlwZSA9ICdJbnB1dCc7XHJcbiAgICB0aGlzLnBvaW50ZXIgPSBudWxsO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIGlucHV0IHg6JHt0aGlzLnh9IHk6JHt0aGlzLnl9YCk7XHJcbiAgICAvKiBoYW5kbGVycyAqL1xyXG4gICAgdGhpcy5vbignbW91c2VvdmVyJywgKCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygnSG92ZXJlZCcpO1xyXG4gICAgICBpZiAodGhpcy5jb25uZWN0ZWRJbnB1dCA9PSBudWxsICYmIHRoaXMucG9pbnRlciA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5wb2ludGVyID0gbmV3IENpcmNsZSh7XHJcbiAgICAgICAgICB4OiB0aGlzLngsXHJcbiAgICAgICAgICB5OiB0aGlzLnksXHJcbiAgICAgICAgICByYWRpdXM6IDgsXHJcbiAgICAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnN0YW5kLmFkZEVsZW1lbnQodGhpcy5wb2ludGVyKTtcclxuICAgICAgICB0aGlzLnBvaW50ZXIub24oJ2RyYWdzdGFydCcsIChlKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnRHJhZyBzdGFydCcpOztcclxuICAgICAgICAgIHRoaXMud2lyZSA9IG5ldyBXaXJlKFt0aGlzLngsdGhpcy55XSk7XHJcbiAgICAgICAgICB0aGlzLnN0YW5kLmFkZEVsZW1lbnQodGhpcy53aXJlKTtcclxuICAgICAgICAgIHRoaXMuY29ubmVjdGluZyA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5wb2ludGVyLm9uKCdkcmFnbW92ZScsIChlKSA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnRHJhZyBtb3ZlJyk7XHJcbiAgICAgICAgICB3aXJpbmcoZSwgdGhpcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5wb2ludGVyLm9uKCdkcmFnZW5kJywgKGUpID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdEcmFnIGVuZCcpO1xyXG4gICAgICAgICAgZGlzd2lyaW5nKGUsIHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHRoaXMub24oJ2RibGNsaWNrJywgKGUpID0+IHtcclxuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGNvbm5lY3QoaW5wdXQpIHtcclxuICAgIHRoaXMud2lyZS5wb2ludHMoW1xyXG4gICAgICB0aGlzLngsXHJcbiAgICAgIHRoaXMueSxcclxuICAgICAgaW5wdXQueCxcclxuICAgICAgaW5wdXQueVxyXG4gICAgXSk7XHJcbiAgICB0aGlzLndpcmUuc2V0U2lkZXModGhpcywgaW5wdXQpO1xyXG4gICAgdGhpcy5jb25uZWN0ZWRJbnB1dCA9IGlucHV0O1xyXG4gICAgaW5wdXQuY29ubmVjdGVkSW5wdXQgPSB0aGlzO1xyXG4gICAgdGhpcy5jb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0YW5kLnBhbmVsLmRyYXcoKTtcclxuICB9XHJcblxyXG4gIGRpc2Nvbm5lY3QoKSB7XHJcbiAgICB0aGlzLmNvbm5lY3RlZElucHV0ID0gbnVsbDtcclxuICAgIHRoaXMucG9pbnRlciA9IG51bGw7XHJcbiAgICB0aGlzLndpcmUgPSBudWxsO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdpcmluZyhlLCBfdGhpcykge1xyXG4gIF90aGlzLndpcmUucG9pbnRzKFtcclxuICAgIF90aGlzLngsXHJcbiAgICBfdGhpcy55LFxyXG4gICAgZS5ldnQub2Zmc2V0WCxcclxuICAgIGUuZXZ0Lm9mZnNldFlcclxuICBdKTtcclxuICBfdGhpcy5zdGFuZC5wYW5lbC5kcmF3KCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrSW5wdXQoeCwgeSwgaW5wdXQpIHtcclxuICBmb3IgKGxldCBjb21wb25lbnQgb2YgaW5wdXQuc3RhbmQuY29tcG9uZW50cykge1xyXG4gICAgaWYgKGNvbXBvbmVudC50eXBlID09PSAnSW5wdXQnKSB7XHJcbiAgICAgIGlmIChjb21wb25lbnQuY29ubmVjdGVkSW5wdXQgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocGFyc2VJbnQoY29tcG9uZW50LngpICsgOCA+PSB4ICYmIHBhcnNlSW50KGNvbXBvbmVudC54KSAtIDggPD0geCAmJiBwYXJzZUludChjb21wb25lbnQueSkgKyA4ID49IHkgJiYgcGFyc2VJbnQoY29tcG9uZW50LnkpIC0gOCA8PSB5KSB7XHJcbiAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZXN1bHQ6IHRydWUsXHJcbiAgICAgICAgICAgIGlucHV0OiBjb21wb25lbnRcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc3VsdDogZmFsc2VcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpc3dpcmluZyhlLCBfdGhpcykge1xyXG4gIGxldCBjaGVjayA9IGNoZWNrSW5wdXQoZS5ldnQub2Zmc2V0WCwgZS5ldnQub2Zmc2V0WSwgX3RoaXMpO1xyXG4gIGNvbnNvbGUubG9nKGBjaGVjayA9PSAke2NoZWNrLnJlc3VsdH1gKTtcclxuICBpZiAoY2hlY2sucmVzdWx0ID09PSB0cnVlKSB7XHJcbiAgICBfdGhpcy5jb25uZWN0KGNoZWNrLmlucHV0KTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc29sZS5lcnJvcignQ29ubmVjdGlvbiBmYWlsZWQnKTtcclxuICAgIF90aGlzLndpcmUuZGVzdHJveSgpO1xyXG4gICAgX3RoaXMucG9pbnRlci5kZXN0cm95KCk7XHJcbiAgICBfdGhpcy5zdGFuZC5wYW5lbC5kcmF3KCk7XHJcbiAgICBfdGhpcy5kaXNjb25uZWN0KCk7XHJcbiAgfVxyXG4gIF90aGlzLmNvbm5lY3RpbmcgPSBmYWxzZTtcclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBJbnB1dDtcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2pzaGludC1sb2FkZXIhLi9saWIvU3RhbmRDb21wb25lbnRzL0lucHV0LmpzXG4gKiovIiwiaW1wb3J0IHsgTGluZSB9IGZyb20gJ2tvbnZhJztcclxuXHJcbmNsYXNzIFdpcmUgZXh0ZW5kcyBMaW5lIHtcclxuICBjb25zdHJ1Y3Rvcihwb2ludHMpIHtcclxuICAgIHN1cGVyKHtcclxuICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgIHN0cm9rZTogJ2JsYWNrJyxcclxuICAgICAgc3Ryb2tlV2lkdGg6IDJcclxuICAgIH0pO1xyXG5cclxuICAgIC8qIHBhcmFtZXRlcnMgKi9cclxuICAgIHRoaXMudHlwZSA9ICdXaXJlJztcclxuICAgIHRoaXMuc2lkZU9uZSA9IG51bGw7XHJcbiAgICB0aGlzLnNpZGVUd28gPSBudWxsO1xyXG4gIH1cclxuICBcclxuICBzZXRTaWRlcyhpbnB1dE9uZSwgaW5wdXRUd28pIHtcclxuICAgIHRoaXMuc2lkZU9uZSA9IGlucHV0T25lO1xyXG4gICAgdGhpcy5zaWRlVHdvID0gaW5wdXRUd287XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXaXJlO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vanNoaW50LWxvYWRlciEuL2xpYi9TdGFuZENvbXBvbmVudHMvV2lyZS5qc1xuICoqLyIsImxldCBsYWJzID0ge1xyXG4gICdMYWJfMCc6IFtcclxuICAgIHtcclxuICAgICAgdHlwZTogJ01ldGVyJyxcclxuICAgICAgeDogODAsXHJcbiAgICAgIHk6IDUwLFxyXG4gICAgICBwYXJhbTogJ0EnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnTWV0ZXInLFxyXG4gICAgICB4OiAyMDAsXHJcbiAgICAgIHk6IDUwLFxyXG4gICAgICBwYXJhbTogJ0EnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnTWV0ZXInLFxyXG4gICAgICB4OiAzMjAsXHJcbiAgICAgIHk6IDUwLFxyXG4gICAgICBwYXJhbTogJ1YnXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnTWV0ZXInLFxyXG4gICAgICB4OiA0NDAsXHJcbiAgICAgIHk6IDUwLFxyXG4gICAgICBwYXJhbTogJ1YnXHJcbiAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgdHlwZTogJ1Jlc2lzdGVyJyxcclxuICAgICAgICB4OiA4MCxcclxuICAgICAgICB5OiAxNTAsXHJcbiAgICAgICAgdmFsdWU6ICcxMCdcclxuICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0eXBlOiAnUmVzaXN0ZXInLFxyXG4gICAgICAgICAgeDogODAsXHJcbiAgICAgICAgICB5OiAyMDAsXHJcbiAgICAgICAgICB2YWx1ZTogJzEwMCdcclxuICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlOiAnUmVzaXN0ZXInLFxyXG4gICAgICAgICAgICB4OiA4MCxcclxuICAgICAgICAgICAgeTogMjUwLFxyXG4gICAgICAgICAgICB2YWx1ZTogJzEwMDAnXHJcbiAgICAgICAgICB9XHJcbiAgXSxcclxuICAnTGFiXzEnOiBbXHJcbiAgICAgIHtcclxuICAgICAgICB0eXBlOiAnSW5wdXQnLFxyXG4gICAgICAgIHg6ICcyNTAnLFxyXG4gICAgICAgIHk6ICc1MCdcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6ICdJbnB1dCcsXHJcbiAgICAgICAgeDogJzE1MCcsXHJcbiAgICAgICAgeTogJzE1MCdcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6ICdJbnB1dCcsXHJcbiAgICAgICAgeDogJzUwJyxcclxuICAgICAgICB5OiAnMjUwJ1xyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgdHlwZTogJ01ldGVyJyxcclxuICAgICAgICBwYXJhbTogJ0EnLFxyXG4gICAgICAgIHg6ICczMDAnLFxyXG4gICAgICAgIHk6ICczMDAnXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICB0eXBlOiAnTWV0ZXInLFxyXG4gICAgICAgIHBhcmFtOiAnVicsXHJcbiAgICAgICAgeDogJzEwMCcsXHJcbiAgICAgICAgeTogJzMwMCdcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6ICdSZXNpc3RlcicsXHJcbiAgICAgICAgdmFsdWU6ICcyMDAnLFxyXG4gICAgICAgIHg6ICcxMDAnLFxyXG4gICAgICAgIHk6ICc0MDAnXHJcbiAgICAgIH1cclxuICAgIF0sXHJcbiAgJ0xhYl8yJzogW1xyXG4gICAgICB7XHJcbiAgICAgICAgdHlwZTogJ0lucHV0JyxcclxuICAgICAgICB4OiAnMjUwJyxcclxuICAgICAgICB5OiAnMjUwJ1xyXG4gICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHR5cGU6ICdJbnB1dCcsXHJcbiAgICAgICAgICB4OiAnMTUwJyxcclxuICAgICAgICAgIHk6ICcxNTAnXHJcbiAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdHlwZTogJ0lucHV0JyxcclxuICAgICAgICAgICAgeDogJzUwJyxcclxuICAgICAgICAgICAgeTogJzUwJ1xyXG4gICAgICAgICAgfVxyXG4gICAgXSxcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbGFicztcclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2pzaGludC1sb2FkZXIhLi9saWIvc3RvcmFnZS9kYXRhLmpzXG4gKiovIiwiaW1wb3J0IHsgUmVjdCwgTGFiZWwsIFRleHQgfSBmcm9tICdrb252YSc7XHJcbmltcG9ydCBJbnB1dCBmcm9tICcuL0lucHV0LmpzJztcclxuXHJcbmNsYXNzIE1ldGVyIGV4dGVuZHMgUmVjdCB7XHJcbiAgY29uc3RydWN0b3IoeCwgeSwgcGFyYW0sIHN0YW5kKSB7XHJcbiAgICBzdXBlcih7XHJcbiAgICAgIHg6IHgsXHJcbiAgICAgIHk6IHksXHJcbiAgICAgIHdpZHRoOiA1MCxcclxuICAgICAgaGVpZ2h0OiAyNSxcclxuICAgICAgZmlsbDogJ3JnYmEoMTIsMTIsMTIsMC4xKScsXHJcbiAgICAgIHN0cm9rZTogJ2JsYWNrJyxcclxuICAgICAgc3Ryb2tlV2lkdGg6IDJcclxuICAgIH0pO1xyXG5cclxuICAgIC8qIHBhcmFtZXRlcnMgKi9cclxuICAgIHRoaXMudmFsdWUgPSAxMjtcclxuICAgIHRoaXMucGFyYW0gPSBwYXJhbTtcclxuICAgIHRoaXMuc3RhbmQgPSBzdGFuZDtcclxuICAgIHRoaXMueCA9IHRoaXMuYXR0cnMueDtcclxuICAgIHRoaXMueSA9IHRoaXMuYXR0cnMueTtcclxuICAgIHRoaXMuaW5wdXRPbmUgPSBuZXcgSW5wdXQodGhpcy54IC0gMjAsIHBhcnNlSW50KHRoaXMueSkgKyAxMi41LCB0aGlzLnN0YW5kKTtcclxuICAgIHRoaXMuaW5wdXRUd28gPSBuZXcgSW5wdXQodGhpcy54ICsgNzAsIHBhcnNlSW50KHRoaXMueSkgKyAxMi41LCB0aGlzLnN0YW5kKVxyXG4gICAgdGhpcy5kaXNwbGF5ID0gbmV3IExhYmVsKHtcclxuICAgICAgICB4OiB0aGlzLngsXHJcbiAgICAgICAgeTogdGhpcy55LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kaXNwbGF5LmFkZChuZXcgVGV4dCh7XHJcbiAgICAgICAgdGV4dDogdGhpcy5fZ2V0VmFsdWUoKSxcclxuICAgICAgICBmb250RmFtaWx5OiAnQ2FsaWJyaScsXHJcbiAgICAgICAgZm9udFNpemU6IDE4LFxyXG4gICAgICAgIHBhZGRpbmc6IDUsXHJcbiAgICAgICAgZmlsbDogJ2JsYWNrJ1xyXG4gICAgfSkpO1xyXG4gICAgdGhpcy5zdGFuZC5hZGRFbGVtZW50cyhbdGhpcy5pbnB1dE9uZSwgdGhpcy5pbnB1dFR3bywgdGhpcy5kaXNwbGF5XSk7XHJcbiAgICAvKiBoYW5kbGVycyAqL1xyXG5cclxuICB9XHJcblxyXG4gIF9nZXRWYWx1ZSgpIHsgcmV0dXJuIGAke3RoaXMudmFsdWV9ICR7dGhpcy5wYXJhbX1gfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWV0ZXI7XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9qc2hpbnQtbG9hZGVyIS4vbGliL1N0YW5kQ29tcG9uZW50cy9NZXRlci5qc1xuICoqLyIsImltcG9ydCB7IFJlY3QsIExhYmVsLCBUZXh0IH0gZnJvbSAna29udmEnO1xyXG5pbXBvcnQgSW5wdXQgZnJvbSAnLi9JbnB1dC5qcyc7XHJcblxyXG5jbGFzcyBSZXNpc3RlciBleHRlbmRzIFJlY3Qge1xyXG4gIGNvbnN0cnVjdG9yKHgsIHksIHZhbCwgc3RhbmQgICkge1xyXG4gICAgc3VwZXIoe1xyXG4gICAgICB4OiB4LFxyXG4gICAgICB5OiB5LFxyXG4gICAgICB3aWR0aDogNjUsXHJcbiAgICAgIGhlaWdodDogMjUsXHJcbiAgICAgIHN0cm9rZTogJ2JsYWNrJyxcclxuICAgICAgc3Ryb2tlV2lkdGg6IDIsXHJcbiAgICAgIGZpbGw6ICdyZ2JhKDEyLDEyLDEyLDAuMSknXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKiBwYXJhbWV0ZXJzICovXHJcbiAgICB0aGlzLnggPSB0aGlzLmF0dHJzLng7XHJcbiAgICB0aGlzLnkgPSB0aGlzLmF0dHJzLnk7XHJcbiAgICB0aGlzLnZhbHVlID0gYCR7dmFsfU9tYDtcclxuICAgIHRoaXMuc3RhbmQgPSBzdGFuZDtcclxuICAgIHRoaXMuaW5wdXRPbmUgPSBuZXcgSW5wdXQodGhpcy54IC0gMjAsIHBhcnNlSW50KHRoaXMueSkgKyAxMi41LCB0aGlzLnN0YW5kKTtcclxuICAgIHRoaXMuaW5wdXRUd28gPSBuZXcgSW5wdXQodGhpcy54ICsgODUsIHBhcnNlSW50KHRoaXMueSkgKyAxMi41LCB0aGlzLnN0YW5kKVxyXG4gICAgdGhpcy5kaXNwbGF5ID0gbmV3IExhYmVsKHtcclxuICAgICAgICB4OiB0aGlzLngsXHJcbiAgICAgICAgeTogdGhpcy55LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5kaXNwbGF5LmFkZChuZXcgVGV4dCh7XHJcbiAgICAgICAgdGV4dDogdGhpcy52YWx1ZSxcclxuICAgICAgICBmb250RmFtaWx5OiAnQ2FsaWJyaScsXHJcbiAgICAgICAgZm9udFNpemU6IDE0LFxyXG4gICAgICAgIHBhZGRpbmc6IDUsXHJcbiAgICAgICAgZmlsbDogJ2JsYWNrJ1xyXG4gICAgfSkpO1xyXG4gICAgdGhpcy5zdGFuZC5hZGRFbGVtZW50cyhbdGhpcy5pbnB1dE9uZSwgdGhpcy5pbnB1dFR3bywgdGhpcy5kaXNwbGF5XSk7XHJcbiAgICAvKiBoYW5kbGVycyAqL1xyXG5cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlc2lzdGVyO1xyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vanNoaW50LWxvYWRlciEuL2xpYi9TdGFuZENvbXBvbmVudHMvUmVzaXN0ZXIuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9